<!DOCTYPE html>

<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   Concepteur Pédagogique - Learning Designer - v. 1.0
  </title>
<!-- NOTE: Tailwind CDN uses a JIT compiler; SRI is not applicable. Consider migrating to a build step for production. -->
<script src="https://cdn.tailwindcss.com"></script>
<script>
// Stub: full implementation loaded later with __uiDiag system
if (typeof __ldSilentErr === 'undefined') { var __ldSilentErr = function(e){ try { if(window.__uiDiagLogError) window.__uiDiagLogError(String(e&&e.message||e||'silent catch'),'catch'); } catch(_){} }; window.__ldSilentErr = __ldSilentErr; }

// ---- Export filename helper (fallback, global) ----
(function(){
  try{
    if (typeof window.__ldBuildExportFilename === 'function') return;
    if (typeof window._ldBuildExportFilename === 'function') { window.__ldBuildExportFilename = window._ldBuildExportFilename; return; }

    const pad = (n)=>String(n).padStart(2,'0');
    const stamp = ()=>{
      const d=new Date();
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
    };
    const strip = (s)=>String(s||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    const safe = (s)=>strip(s).replace(/[^A-Za-z0-9]+/g,'_').replace(/^_+|_+$/g,'').replace(/_+/g,'_') || 'export';

    const getTitle = ()=>{
      const el = document.querySelector('[data-training-title], #training-title, input[name="trainingTitle"], .training-title-input');
      const v = el && ('value' in el) ? el.value : (el ? el.textContent : '');
      return v || document.title || 'export';
    };

    window.__ldBuildExportFilename = function(ext,label){
      const base = safe(getTitle());
      const lbl = label ? `_${safe(label)}` : '';
      return `${base}${lbl}_${stamp()}.${ext}`;
    };
    window._ldBuildExportFilename = window.__ldBuildExportFilename;
  }catch(_){ __ldSilentErr(_); }
})();

// ---- Learning type select visual sync (grey when 'none') ----
function __ldSyncLearningTypeSelectVisual(sel){
  try{
    if(!sel || !sel.classList) return;
    const v = (sel.value || '').toString();
    const isNone = (v === 'none' || v === '');
    sel.classList.toggle('ld-select-none', isNone);
  }catch(_){ __ldSilentErr(_); }
}
document.addEventListener('change', (e)=>{
  const t = e.target;
  if(t && t.classList && t.classList.contains('learning-type-select')){
    __ldSyncLearningTypeSelectVisual(t);
  }
}, true);
document.addEventListener('DOMContentLoaded', ()=>{
  try{
    document.querySelectorAll('.learning-type-select').forEach(__ldSyncLearningTypeSelectVisual);
  }catch(_){ __ldSilentErr(_); }
});




</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"
        integrity="sha384-eeLEhtwdMwD3X9y+8P3Cn7Idl/M+w8H4uZqkgD/2eJVkWIN1yKzEj6XegJ9dL3q0"
        crossorigin="anonymous" defer></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
        integrity="sha384-vtjasyidUo0kW94K5MXDXntzOJpQgBKXmE7e2Ga4LG0skTTLeBi97eFAXsqewJjw"
        crossorigin="anonymous" defer></script>
<script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js"
        integrity="sha384-4xaIisuLEy2lo2HkB2C4rEf7v8jbTb2kuogX6TkuEt9feTWKBSFSOzsqNNbV+sKh"
        crossorigin="anonymous" defer></script>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet"/>
<style>

/* Locked duration unit selects (global unit controlled in initial parameters) */
.ld-locked-unit { opacity: 1 !important; background-color: #f8fafc !important; color: #475569 !important; }


/* Learning type select: keep 'Aucun' option visually greyed out */
.learning-type-select option[value="none"],
.learning-type-select option.ld-opt-none{
  background-color:#f1f5f9;
  color:#64748b;
}
.learning-type-select.ld-select-none{
  background-color:#f1f5f9 !important;
  color:#64748b !important;
}


/* Textareas: consistent vertical resizing */
textarea{resize:vertical;}
.ld-ta-compact, .ld-ta-expanded{resize:vertical;}

   @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        /* Prevent layout shift when the vertical scrollbar appears/disappears (e.g., wizard tab switch) */
        html { scrollbar-gutter: stable; }
        body { overflow-y: scroll; }


        /* Control toolbar color system */
        :root {
          --ld-control-text: #475569; /* slate-600 */
          --ld-control-text-muted: #64748b; /* slate-500 */
          --ld-control-text-hover: #4338ca; /* indigo-700 */
          --ld-control-border: #e2e8f0; /* slate-200 */
          --ld-control-bg: #ffffff;
          --ld-control-bg-hover: #f8fafc; /* slate-50 */
          --ld-control-focus-ring: #818cf8; /* indigo-400 */
          --ld-control-group-bg: rgba(248, 250, 252, 0.5); /* slate-50/50 */
        }

        /* Mode contraste élevé */
        body.contrast-plus {
          --ld-control-text: #334155; /* slate-700 */
          --ld-control-text-hover: #3730a3; /* indigo-800 */
          --ld-control-border: #94a3b8; /* slate-400 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #0f172a;
            font-size: 0.92rem;line-height: 1.4;
        }

        
        
        /* Collapsible UI: hide native disclosure markers for consistent design */
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }
.pattern-stripes {
            background-image: linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);
            background-size: 8px 8px;
        }
        
        .pattern-dots {
            background-image: radial-gradient(rgba(255,255,255,0.5) 1.5px, transparent 1.5px);
            background-size: 6px 6px;
        }

        .pattern-vertical {
            background-image: repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(255,255,255,0.3) 2px, rgba(255,255,255,0.3) 4px);
        }

        .pattern-grid-dark {
             background-image: linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 6px 6px;
        }

        
body.hide-types .learning-type-container,
body.hide-types .timeline-track-pedagogy,
body.hide-types .activity-type-bar {
            display: none !important;
        }

/* Simplified view: hide target durations (keep designed durations) */
html.hide-target-durations .activity-target-wrap,
html.hide-target-durations .moment-target-wrap,
html.hide-target-durations .submoment-target-wrap,
html.hide-target-durations .module-time-compare,
html.hide-target-durations .moment-time-compare,
html.hide-target-durations .submoment-time-compare,
html.hide-target-durations .timeline-track-planned,
html.hide-target-durations #timeline-activities-planned,
html.hide-target-durations #timeline-activities-planned-labels {
  display: none !important;
}

        .activity-container {
            border-left: 3px solid #cbd5e1; 
        }

        .step-card {
            transition: transform 0.1s ease;
        }

        
        .sortable-ghost {
            opacity: 0.3;
            background-color: #f1f5f9 !important;
            border: 2px dashed #94a3b8 !important;
        }

        .sortable-drag {
            cursor: grabbing;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        
        .type-none { border-left: 5px solid #e5e7eb; }

        .type-acquisition { border-left: 5px solid #a1f5ed; } 
        .type-collaboration { border-left: 5px solid #ffd966; } 
        .type-discussion { border-left: 5px solid #7aaeea; } 
        .type-investigation { border-left: 5px solid #f8807f; } 
        .type-practice { border-left: 5px solid #bb98dc; } 
        .type-production { border-left: 5px solid #bdea75; } 

        .select-none { background-color: #e5e7eb !important; color: #000 !important; border-color: #d1d5db !important; }


        .select-acquisition { background-color: #a1f5ed !important; color: #000 !important; border-color: #7dded6 !important; }
        .select-collaboration { background-color: #ffd966 !important; color: #000 !important; border-color: #f0c953 !important; }
        .select-discussion { background-color: #7aaeea !important; color: #000 !important; border-color: #6a9bd6 !important; }
        .select-investigation { background-color: #f8807f !important; color: #000 !important; border-color: #e06e6d !important; }
        .select-practice { background-color: #bb98dc !important; color: #000 !important; border-color: #a582c6 !important; }
        .select-production { background-color: #bdea75 !important; color: #000 !important; border-color: #a6d15e !important; }

        .drag-handle {
            cursor: grab;
            touch-action: none;
            user-select: none;
        }
        .drag-handle:active {
            cursor: grabbing;
        }

        
        .material-icons-round {
            display: inline-flex;
            vertical-align: middle;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        
        /* ── Solo-moment mode ──────────────────────────────────────
           When a module has exactly 1 moment with no title/description,
           hide the moment's chrome so the user sees only activities.
           The moment DOM element remains (save/load/stats unaffected). */
        .moment-group.ld-solo-moment {
            border-color: transparent !important;
            background: transparent !important;
        }
        .moment-group.ld-solo-moment > div:first-child {
            display: none !important;                    /* header row */
        }
        .moment-group.ld-solo-moment > .moment-body {
            padding: 0 !important;
        }
        .moment-group.ld-solo-moment .submoments-controls {
            display: none !important;                    /* moment-level add buttons */
        }
        .moment-group.ld-solo-moment .moment-description-wrap {
            display: none !important;
        }

        /* Performance fix: reduced from 50000px. For modern browsers, consider:
           :root { interpolate-size: allow-keywords; }
           .panel-content.open { max-height: none; } */
        .panel-content {
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }
        .panel-content.open {
            max-height: 9999px; 
            opacity: 1;
        }
        .rotate-icon {
            transition: transform 0.2s ease;
        }
        .rotate-icon.open {
            transform: rotate(180deg);
        }

        
        .step-body {
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 9999px;
            opacity: 1;
            overflow: hidden;
        }
        .step-body.collapsed {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
            padding-bottom: 0 !important;
        }

        
        .activity-body {
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 9999px; 
            opacity: 1;
            overflow: hidden;
        }
        .activity-body.collapsed {
            max-height: 0;
            opacity: 0;
        }
        
        
        
        .moment-body {
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 9999px;
            opacity: 1;
            overflow: hidden;
        }
        .moment-body.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .submoment-body {
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 9999px;
            opacity: 1;
            overflow: hidden;
        }
        .submoment-body.collapsed {
            max-height: 0;
            opacity: 0;
        }
input, select, textarea {
            font-size: 0.9rem;
        }

        /* Uniform field sizing: inputs + textareas (exclude non-text inputs) */
        input:not([type="checkbox"]):not([type="radio"]):not([type="range"]):not([type="file"]):not([type="color"]):not([type="button"]):not([type="submit"]):not([type="reset"]):not([type="hidden"]),
        textarea {
            min-height: 32px;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
        }

        input::placeholder, textarea::placeholder {
            color: #94a3b8;
        }

        :focus-visible {
            outline: 3px solid rgba(99, 102, 241, 0.70) !important;
            outline-offset: 2px !important;
        }
        html.ui-dark :focus-visible {
            outline-color: rgba(165, 180, 252, 0.90) !important;
        }
        
        .compact-label {
            font-size: 0.72rem;
            text-transform: uppercase;
            font-weight: 700;
            color: #64748b;
            letter-spacing: 0.04em;
            margin-bottom: 12px;
        }

        .compact-label-lg {
            font-size: 0.8rem;
        }

        @media print {
            .no-print { display: none; }
            body { background: white; padding: 0; }
            .activity-group { break-inside: avoid; margin-bottom: 1rem; border: none; border-radius: 8px; padding: 0.5rem; }
            .step-card { border: none; break-inside: avoid; margin-bottom: 0.5rem; }
            select { appearance: none; border: none; padding: 0; background: none; }
            textarea { border: none; padding: 0; }
            #key-params-panel { max-height: none !important; opacity: 1 !important; display: block !important; }
            .step-body.collapsed, .activity-body.collapsed { max-height: none !important; opacity: 1 !important; display: block !important; }
        }
    

        /* Keep toolbar buttons on a single line (used in Compétences tab) */
        .toolbar-nowrap { flex-wrap: nowrap !important; overflow-x: auto; -webkit-overflow-scrolling: touch; }
        .toolbar-nowrap > * { flex: 0 0 auto; white-space: nowrap; }

        /* ========================================
           Control Toolbar Standardized Styles
           ======================================== */

        /* Bouton standard de la toolbar */
        .ld-control-btn {
          height: 28px;
          padding: 0 0.5rem;
          font-size: 0.75rem;
          font-weight: 800;
          line-height: 1;
          border-radius: 0.375rem;
          border: 1px solid var(--ld-control-border);
          background-color: var(--ld-control-bg);
          color: var(--ld-control-text);
          transition: color 0.15s, background-color 0.15s, border-color 0.15s;
          display: inline-flex;
          align-items: center;
          gap: 0.25rem;
          cursor: pointer;
        }

        .ld-control-btn:hover {
          color: var(--ld-control-text-hover);
          background-color: var(--ld-control-bg-hover);
        }

        .ld-control-btn:focus-visible {
          outline: 2px solid var(--ld-control-focus-ring);
          outline-offset: 2px;
        }

        /* Force white background for the "Affichage des états" summary button */
        #view-controls-toolbar details > summary.ld-control-btn{
          background-color: #ffffff !important;
        }
        #view-controls-toolbar details > summary.ld-control-btn:hover{
          background-color: var(--ld-control-bg-hover) !important;
        }

        /* Select standard de la toolbar */
        .ld-control-select {
          height: 28px;
          padding: 0 0.5rem;
          font-size: 0.75rem;
          font-weight: 600;
          line-height: 1;
          border-radius: 0.375rem;
          border: 1px solid var(--ld-control-border);
          background-color: var(--ld-control-bg);
          color: var(--ld-control-text);
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
          cursor: pointer;
        }

        .ld-control-select:focus {
          outline: none;
          box-shadow: 0 0 0 2px #c7d2fe; /* indigo-200 */
        }

        /* Boutons du groupe segmenté */
        .ld-segmented-btn {
          height: 28px;
          padding: 0 0.5rem;
          font-size: 0.75rem;
          font-weight: 800;
          line-height: 1;
          color: var(--ld-control-text);
          background-color: transparent;
          border: none;
          transition: color 0.15s, background-color 0.15s;
          cursor: pointer;
        }

        .ld-segmented-btn:hover {
          color: var(--ld-control-text-hover);
          background-color: var(--ld-control-bg-hover);
        }

        .ld-segmented-btn[aria-pressed="true"] {
          background-color: var(--ld-control-bg-hover);
          color: var(--ld-control-text-hover);
        }

        .ld-segmented-btn:focus-visible {
          outline: 2px solid var(--ld-control-focus-ring);
          outline-offset: -2px;
          z-index: 1;
        }

        /* Style spécial pour Panorama */
        .ld-segmented-btn[data-view-level="panorama"] {
          color: #4338ca; /* indigo-700 */
          background-color: #eef2ff; /* indigo-50 */
          border-left: 1px solid #c7d2fe; /* indigo-200 */
        }

        .ld-segmented-btn[data-view-level="panorama"]:hover {
          background-color: #e0e7ff; /* indigo-100 */
        }

        .ld-segmented-btn[data-view-level="panorama"][aria-pressed="true"] {
          background-color: #e0e7ff; /* indigo-100 */
          color: #3730a3; /* indigo-800 - meilleur contraste */
        }

        /* Groupe de contrôles */
        .ld-control-group {
          display: flex;
          align-items: center;
          gap: 0.5rem;
          padding: 0.25rem 0.5rem;
          background-color: var(--ld-control-group-bg);
          border: 1px solid rgba(226, 232, 240, 0.5); /* slate-200/50 */
          border-radius: 0.375rem;
        }

        /* Séparateur vertical */
        .ld-separator {
          height: 1.5rem;
          width: 1px;
          background-color: #cbd5e1; /* slate-300 */
        }


        .activity-group { scroll-margin-top: 80px; }
        .step-card { box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06); }
        .step-card:hover { box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08); }
        .activity-title { letter-spacing: -0.01em; }
        .activity-container { border-left-color: #cbd5e1; }

        
        header { margin-bottom: 0.75rem ; }
        .activity-group { padding: 0.5rem ; margin-bottom: 0.75rem ; }
        .moment-group { margin-bottom: 0.5rem ; }
        .step-card { margin-bottom: 0.5rem ; }
        .activity-group > .flex { margin-bottom: 0.75rem ; gap: 0.5rem ; }
        .step-card > .flex.items-center { padding: 6px 8px ; gap: 0.5rem ; }
        .step-body.panel-content { padding: 0.5rem ; padding-top: 0.35rem ; }
        .activity-description { padding: 0.35rem 0.5rem ; font-size: 0.85rem ; }
        .activity-steps-container { padding-top: 0.25rem; }
        input, select, textarea { font-size: 0.88rem; }
        .compact-label { font-size: 0.78rem; margin-bottom: 10px; }
        .compact-label-lg { font-size: 0.86rem; }

        
        .step-body label [data-i18n="label_grouping"] { font-size: 0.75rem; }
        #timeline-panel { gap: 0.75rem ; }
        #timeline-panel .timeline-track-pedagogy,
        #timeline-panel .flex.flex-col.gap-0\.5 { gap: 0.35rem ; }

        
        
        #timeline-panel [data-i18n^="label_timeline_"] { font-size: 0.82rem ; }
        #timeline-panel [data-i18n^="label_"][data-i18n$="grouping"],
        #timeline-panel [data-i18n="label_trainer"],
        #timeline-panel [data-i18n="label_place"],
        #timeline-panel [data-i18n="label_time"] { font-size: 0.95rem ; }
        #timeline-panel [data-i18n^="legend_"] { font-size: 0.82rem ; }
        #timeline-panel #timeline-activities-planned-labels,
        #timeline-panel #timeline-activities-labels,
        #timeline-panel #timeline-moments-labels,
        #timeline-panel #timeline-submoments-labels { font-size: 0.85rem ; }
        #timeline-ruler { font-size: 0.82rem ; }

        body.hc {
            background-color: #ffffff;
            color: #0f172a;
        }
        body.hc .text-slate-300 { color: #475569 !important; }
        body.hc .text-slate-400 { color: #334155 !important; }
        body.hc .text-slate-500 { color: #334155 !important; }
        body.hc .text-slate-600 { color: #1f2937 !important; }
        body.hc .text-slate-700 { color: #0f172a !important; }
        body.hc .bg-slate-50 { background-color: #f8fafc !important; }
        body.hc .bg-slate-100 { background-color: #f1f5f9 !important; }

        /* View: contrast+ (accentuer les contrastes sans passer en HC complet) */
        body.contrast-plus .text-slate-300 { color: #64748b !important; }
        body.contrast-plus .text-slate-400 { color: #475569 !important; }
        body.contrast-plus .text-slate-500 { color: #334155 !important; }
        body.contrast-plus .text-slate-600 { color: #1f2937 !important; }
        body.contrast-plus .text-slate-700 { color: #0f172a !important; }
        body.contrast-plus .border-slate-100 { border-color: #cbd5e1 !important; }
        body.contrast-plus .border-slate-200 { border-color: #94a3b8 !important; }
        body.contrast-plus .border-slate-300 { border-color: #64748b !important; }
        body.contrast-plus .activity-container { border-left-color: #94a3b8 !important; }
        body.contrast-plus :focus-visible { outline-color: rgba(37, 99, 235, 0.85) !important; }

        @media print {
          body.contrast-plus { filter: none !important; }
        }


        /* View: transparent block backgrounds (keep borders) */
        body.view-transparent :is(div, section, header, main, aside, article, details).bg-white {
          background-color: transparent !important;
        }
        body.view-transparent :is(div, section, header, main, aside, article, details).bg-slate-50 {
          background-color: transparent !important;
        }
        body.view-transparent :is(div, section, header, main, aside, article, details).bg-slate-100 {
          background-color: transparent !important;
        }
        body.hc .border-slate-100 { border-color: #cbd5e1 !important; }
        body.hc .border-slate-200 { border-color: #94a3b8 !important; }
        body.hc .border-slate-300 { border-color: #64748b !important; }
        body.hc .activity-container { border-left-color: #475569 !important; }
        body.hc .activity-type-bar { background-color: #e2e8f0 !important; border-color: #94a3b8 !important; }
        body.hc #timeline-activities-planned,
        body.hc #timeline-activities,
        body.hc #timeline-moments,
        body.hc #timeline-submoments,
        body.hc #timeline-steps,
        body.hc #timeline-grouping,
        body.hc #timeline-trainer,
        body.hc #timeline-place,
        body.hc #timeline-time {
            border-color: #94a3b8 !important;
            background-color: #e2e8f0 !important;
        }
        body.hc #timeline-ruler { color: #0f172a !important; }
        body.hc #custom-confirm-modal { background-color: rgba(15, 23, 42, 0.75) !important; }
        body.hc #global-tooltip { background-color: #ffffff !important; border-color: #0f172a !important; color: #0f172a !important; }
        body.hc :focus-visible {
            outline-color: rgba(37, 99, 235, 0.8);
        }

#timeline-panel { gap: 0.75rem; }

#timeline-details { gap: 0.35rem; }

#timeline-details .timeline-track { padding: 0.40rem; }
#timeline-details .timeline-track { background: transparent !important; border: 0 !important; }

#timeline-details [data-i18n="label_grouping"],
#timeline-details [data-i18n="label_trainer"],
#timeline-details [data-i18n="label_place"],
#timeline-details [data-i18n="label_time"]{
  font-size: 10px !important;
}
.step-card .step-left-label{
  font-size: 0.75rem !important;
}

.step-card .step-group-mode,
.step-card .trainer-select,
.step-card .place-select,
.step-card .time-select {
  font-size: 10px !important;
}

#timeline-panel .timeline-duration-label { background: transparent !important; border: 0 !important; box-shadow: none !important; }

#timeline-panel .timeline-track { transition: box-shadow 0.15s ease; }
#timeline-panel .timeline-track:hover { box-shadow: 0 8px 22px rgba(15, 23, 42, 0.06); }
#timeline-panel { padding: 0.5rem ; }
#timeline-panel #timeline-activities-planned,
#timeline-panel #timeline-activities,
#timeline-panel #timeline-steps { height: 1.25rem ; }
#timeline-panel #timeline-grouping,
#timeline-panel #timeline-trainer,
#timeline-panel #timeline-place,
#timeline-panel #timeline-time { height: 0.95rem ; }
#timeline-panel #timeline-ruler { height: 2.25rem ; }

#timeline-ruler { padding: 0.25rem 0.4rem 0.15rem 0.4rem; }
#timeline-ruler { display: none !important; }
#timeline-ruler .timeline-ruler-tick { top: 0.3rem; bottom: 1.15rem; background-color: #94a3b8; }
#timeline-ruler .timeline-ruler-label {
    bottom: 0.15rem;
    font-size: 0.78rem;
    font-weight: 400;
    color: #0f172a;
    background-color: rgba(255, 255, 255, 0.92);
    border: none;
    padding: 0 0.25rem;
    border-radius: 0.25rem;
    line-height: 1.1;
}
#timeline-ruler .timeline-ruler-label { font-size: 0.74rem; }
body.hc #timeline-ruler .timeline-ruler-tick { background-color: #475569; }
body.hc #timeline-ruler .timeline-ruler-label { border-color: #94a3b8; background-color: #ffffff; }
  

.timeline-missing-light,
  .timeline-alert-light{
    
    background:
      repeating-linear-gradient(
        135deg,
        rgba(254, 202, 202, 0.95),
        rgba(254, 202, 202, 0.95) 8px,
        rgba(239, 68, 68, 0.22) 8px,
        rgba(239, 68, 68, 0.22) 16px
      );
    box-shadow: inset 0 0 0 2px rgba(239, 68, 68, 0.95);
  }

  
  .duration-alert-light{
    background: rgba(254, 202, 202, 0.95) !important;
    border-color: rgba(239, 68, 68, 0.55) !important;
    box-shadow: inset 0 0 0 2px rgba(239, 68, 68, 0.35) !important;
  }

  
  
  /* Barre divergente (delta) sous les durées conçues : trop court vs trop long */
.ld-duration-badge{ position: relative; overflow: hidden; }
.ld-delta-bar{
  position:absolute;
  left:0;
  right:0;
  bottom:0;
  height:3px;
  pointer-events:none;
  background: rgba(148, 163, 184, 0.18); /* slate-400/18 */
}
.ld-delta-bar .ld-delta-axis{
  position:absolute;
  left:50%;
  top:0; bottom:0;
  width:1px;
  transform: translateX(-0.5px);
  background: rgba(148, 163, 184, 0.75); /* slate-400 */
}
.ld-delta-bar .ld-delta-neg{
  position:absolute;
  right:50%;
  top:0; bottom:0;
  width:0%;
  background: rgba(59, 130, 246, 0.92); /* blue (trop court) */
}
.ld-delta-bar .ld-delta-pos{
  position:absolute;
  left:50%;
  top:0; bottom:0;
  width:0%;
  background: rgba(239, 68, 68, 0.92); /* red (trop long) */
}
/* Optionnel: rendu neutre si conforme (on garde le code couleur directionnel, mais en vert) */
.ld-delta-bar.ld-delta-ok .ld-delta-neg,
.ld-delta-bar.ld-delta-ok .ld-delta-pos{
  background: rgba(34, 197, 94, 0.86); /* green */
}
.timeline-alert-icons{
    position:absolute;
    top:-18px;
    right:6px;
    display:flex;
    gap:6px;
    align-items:center;
    z-index:60;
    pointer-events:none;
    padding:2px 6px;
    border-radius:9999px;
    background: rgba(239, 68, 68, 0.92);
    box-shadow: 0 2px 10px rgba(15, 23, 42, 0.35);
     color: #ffffff;
    font-size: 12px;
    font-weight: 800;
    line-height: 1;
    letter-spacing: 0.2px;
    text-transform: uppercase;
  }
  .timeline-alert-icons svg{
    width:16px;
    height:16px;
    opacity:1;
    filter: drop-shadow(0 1px 2px rgba(15, 23, 42, 0.45));
  }

  
  @keyframes timelineAlertPulse{
    0%, 100% { filter: saturate(1) brightness(1); }
    50%      { filter: saturate(1.15) brightness(1.05); }
  }
  .timeline-missing-light,
  .timeline-alert-light{
    animation: timelineAlertPulse 1.4s ease-in-out infinite;
  }

  /* Animation pour les activités nouvellement créées */
  .newly-created-activity {
    animation: pulse-highlight 2s ease-in-out;
    border-left: 4px solid #6366f1 !important;
  }
  @keyframes pulse-highlight {
    0%, 100% { background-color: transparent; }
    50% { background-color: rgba(99, 102, 241, 0.15); }
  }

  
  .timeline-overrun-light{background:#fecaca;}

  
  #timeline-panel #timeline-activities{ overflow: visible !important; }

        .timeline-zoom-outer{
            overflow-x: auto !important;
            overflow-y: hidden !important;
        }
        .timeline-inner{
            display: flex;
            height: 100%;
            min-width: 100%;
        }

#timelines-wrapper{
  width: 100%;
  max-width: 100%;
  min-width: 0; 
  box-sizing: border-box;
}
#timelines-wrapper .panel-content,
#timelines-wrapper #timeline-panel{
  width: 100%;
  max-width: 100%;
  min-width: 0;
  box-sizing: border-box;
}
#timelines-wrapper #timeline-panel{
  overflow-x: hidden; 
}
#timelines-wrapper .timeline-track,
#timelines-wrapper .timeline-track > *{
  max-width: 100%;
  min-width: 0;
  box-sizing: border-box;
}

#timelines-wrapper .timeline-zoom-outer{
  max-width: 100%;
  overflow-x: auto !important;
  overflow-y: hidden !important;
}

#timeline-panel #timeline-activities{
  overflow-x: hidden !important;
  overflow-y: visible !important;
}

#timeline-hscroll{
  width: 100%;
  max-width: 100%;
  overflow-x: scroll;
  overflow-y: hidden;
  scrollbar-gutter: stable both-edges;
  height: 28px;
  margin-top: 10px;
  border-radius: 9999px;
  border: 1px solid rgba(148,163,184,0.70);
  background: rgba(241,245,249,0.98);
  box-sizing: border-box;
  cursor: ew-resize;
}

/* Make the scrollbar clearly visible (Chrome/Safari/Edge) */
#timeline-hscroll::-webkit-scrollbar{ height: 18px; }
#timeline-hscroll::-webkit-scrollbar-track{
  background: rgba(226,232,240,0.95);
  border-radius: 9999px;
}
#timeline-hscroll::-webkit-scrollbar-thumb{
  background: rgba(71,85,105,0.85);
  border-radius: 9999px;
  border: 4px solid rgba(226,232,240,0.95);
}
#timeline-hscroll::-webkit-scrollbar-thumb:hover{ background: rgba(51,65,85,0.95); }


/* Firefox */
#timeline-hscroll{ scrollbar-width: auto; scrollbar-color: rgba(71,85,105,0.85) rgba(226,232,240,0.95); }

#timeline-hscroll-inner{
  height: 1px;
  width: 0px;
}


/* Hide per-line horizontal scrollbars inside timeline tracks (keep only the unified scrollbar at the bottom) */
#timeline-panel .timeline-zoom-outer{
  scrollbar-width: none; /* Firefox */
}
#timeline-panel .timeline-zoom-outer::-webkit-scrollbar{
  height: 0px;
  width: 0px;
}


/* Unified scrollbar: render a persistent, easy-to-grab custom thumb (macOS overlay scrollbars can be hard to grab) */
#timeline-hscroll{ position: relative; }
#timeline-hscroll-thumb{
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  height: 18px;
  width: 72px;
  border-radius: 9999px;
  background: rgba(71,85,105,0.85);
  border: 4px solid rgba(226,232,240,0.95);
  box-sizing: border-box;
  cursor: grab;
  z-index: 5;
}
#timeline-hscroll-thumb:active{ cursor: grabbing; }

/* Hide the native scrollbar visuals; keep wheel/trackpad scrolling functional */
#timeline-hscroll{ scrollbar-width: none; }
#timeline-hscroll::-webkit-scrollbar{ height: 0px; width: 0px; }


/* --- Added: Timeline↔Editor navigation highlight + Focus mode --- */
.temp-highlight {
  outline: 3px solid rgba(245, 158, 11, 0.9);
  outline-offset: 2px;
  border-radius: 14px;
}

body.focus-mode .activity-group { display: none; }
body.focus-mode .activity-group.focus-active { display: block; }


        /* UI Theme (light/dark): applied via html.ui-dark. Minimal override layer. */
        html.ui-dark {
          color-scheme: dark;
        }
        html.ui-dark body {
          background-color: #0b1220 !important;
        }
        html.ui-dark .bg-white { background-color: #0f172a !important; }
        html.ui-dark .bg-slate-50 { background-color: rgba(15, 23, 42, 0.60) !important; }
        html.ui-dark .bg-slate-100 { background-color: rgba(30, 41, 59, 0.85) !important; }
        html.ui-dark .bg-indigo-50 { background-color: rgba(49, 46, 129, 0.22) !important; }

        html.ui-dark .text-slate-900,
        html.ui-dark .text-slate-800,
        html.ui-dark .text-slate-700 { color: #e2e8f0 !important; }
        html.ui-dark .text-slate-600,
        html.ui-dark .text-slate-500 { color: #cbd5e1 !important; }
        html.ui-dark .text-indigo-600 { color: #a5b4fc !important; }

        html.ui-dark .border-slate-200 { border-color: #334155 !important; }
        html.ui-dark .border-slate-100 { border-color: #1f2937 !important; }

        html.ui-dark input,
        html.ui-dark textarea,
        html.ui-dark select {
          background-color: #0b1220 !important;
          color: #e2e8f0 !important;
          border-color: #334155 !important;
        }

        html.ui-dark .hover\:bg-slate-50:hover { background-color: rgba(30, 41, 59, 0.80) !important; }
        html.ui-dark .hover\:bg-slate-100:hover { background-color: rgba(51, 65, 85, 0.85) !important; }
        html.ui-dark .hover\:bg-indigo-50:hover { background-color: rgba(49, 46, 129, 0.30) !important; }
        html.ui-dark .hover\:text-indigo-600:hover { color: #a5b4fc !important; }

        /* Ensure Transparent view remains authoritative even under dark theme */
        html.ui-dark body.view-transparent .bg-white,
        html.ui-dark body.view-transparent .bg-slate-50,
        html.ui-dark body.view-transparent .bg-slate-100,
        html.ui-dark body.view-transparent .bg-indigo-50 {
            background-color: transparent !important;
        }


        /* Step right-column uniform collapsible sections */
        .step-right-section > summary { list-style: none; }
        .step-right-section > summary::-webkit-details-marker { display: none; }
        .step-right-section[open] .step-right-chevron { transform: rotate(180deg); }
        .step-right-chevron { transition: transform 150ms ease; }

        .step-right-group > summary { list-style: none; }
        .step-right-group > summary::-webkit-details-marker { display: none; }
        .step-right-group[open] .step-group-chevron { transform: rotate(180deg); }


        /* Step tabs (Activity right column) */
        .step-tabs{
          display:flex;
          gap:0.25rem;
          padding:0.25rem;
          background: rgba(241,245,249,0.9); /* slate-100 */
          border: 1px solid rgba(226,232,240,1); /* slate-200 */
          border-radius: 0.75rem;
        }
        .step-tab{
          flex:1;
          font-size: 0.75rem;
          font-weight: 700;
          padding: 0.375rem 0.5rem;
          border-radius: 0.65rem;
          color: rgba(71,85,105,1); /* slate-600 */
          transition: background 150ms ease, color 150ms ease, box-shadow 150ms ease, border-color 150ms ease;
          border: 1px solid transparent;
        }
        .step-tab[aria-selected="false"]:hover{
          background: rgba(255,255,255,0.7);
        }
        .step-tab[aria-selected="true"]{
          background: #ffffff;
          border-color: rgba(226,232,240,1); /* slate-200 */
          color: rgba(67,56,202,1); /* indigo-700 */
          box-shadow: 0 1px 2px rgba(15,23,42,0.06);
        }
        html.ui-dark .step-tabs{
          background: rgba(15,23,42,0.45);
          border-color: rgba(148,163,184,0.25);
        }
        html.ui-dark .step-tab{
          color: rgba(226,232,240,0.85);
        }
        html.ui-dark .step-tab[aria-selected="true"]{
          background: rgba(15,23,42,0.85);
          border-color: rgba(148,163,184,0.35);
          color: rgba(165,180,252,1); /* indigo-200 */
        }
        /* Hide panels via [hidden] (keeps a11y) */
        .step-tabpanel[hidden]{ display:none !important; }
        
/* Module derived targets: read-only (reflects activities) */
details[data-readonly="true"] .no-print{ display:none !important; }
details[data-readonly="true"] .module-target-competences-sujet-checkboxes,
details[data-readonly="true"] .module-target-competences-transv-checkboxes,
details[data-readonly="true"] .module-aims-checkboxes,
details[data-readonly="true"] .module-outcomes-checkboxes{ opacity: 0.95; }
details[data-readonly="true"] label{ cursor: default; }

/* Analysis charts as tabs */
.analysis-tabbar{display:flex;flex-wrap:wrap;gap:6px;}
.analysis-tab-btn{font-size:11px;font-weight:700;line-height:1; padding:8px 10px; border-radius:9999px; border:1px solid rgb(226 232 240); background:rgb(248 250 252); color:rgb(51 65 85); transition:background .15s,color .15s,border-color .15s;}
.analysis-tab-btn:hover{background:rgb(241 245 249);}
.analysis-tab-btn.is-active{background:rgb(226 232 240);border-color:rgb(203 213 225);color:rgb(30 41 59);}
.analysis-tab-pane{display:none;}
.analysis-tab-pane.is-active{display:block;}
/* Analysis tabs as collapsible block (collapsed by default) */
#analysis-tabs-wrap > summary::-webkit-details-marker{display:none;}
#analysis-tabs-wrap > summary{list-style:none;}
#analysis-tabs-wrap .analysis-chevron{transition:transform .15s;}
#analysis-tabs-wrap[open] .analysis-chevron{transform:rotate(180deg);}
#analysis-tabs-wrap > summary::-webkit-details-marker{display:none;}
#analysis-tabs-wrap > summary{list-style:none;}
#analysis-tabs-wrap > summary .analysis-chevron{transition:transform .15s ease;}
#analysis-tabs-wrap[open] > summary .analysis-chevron{transform:rotate(180deg);}

/* Ensure analysis chart panels are visible even though they reuse .panel-content (which is collapsed by default elsewhere) */
#analysis-tabs-wrap .panel-content{max-height:none !important;opacity:1 !important;overflow:visible !important;transition:none !important;}
#analysis-tabs-wrap .panel-content.open{max-height:none !important;opacity:1 !important;}


        body.has-batch-bar { padding-bottom: 90px; }
        /* --- Step status (signalisation) --- */
        .step-card[data-status="done"] .step-header { box-shadow: inset 4px 0 0 rgba(34, 197, 94, 0.75); }
        .step-card[data-status="review"] .step-header { box-shadow: inset 4px 0 0 rgba(245, 158, 11, 0.85); }
        .step-card[data-status="in_progress"] .step-header { box-shadow: inset 4px 0 0 rgba(96, 165, 250, 0.7); }
        .step-status-select { display:none !important; } /* hidden, value kept for logic */
        /* --- Compact status dot widget --- */
        .step-status-dot{
            width:18px; height:18px; border-radius:50%; border:2px solid rgba(100,116,139,0.25);
            cursor:pointer; position:relative; flex-shrink:0;
            transition: border-color 0.15s, background 0.15s;
        }
        .step-status-dot:hover{ border-color:rgba(99,102,241,0.5); }
        .step-status-dot[data-val="in_progress"]{ background:rgba(96,165,250,0.7); }
        .step-status-dot[data-val="done"]{ background:rgba(34,197,94,0.75); }
        .step-status-dot[data-val="review"]{ background:rgba(245,158,11,0.85); }
        .step-status-dot-menu{
            display:none; position:fixed;
            background:#fff; border:1px solid #e2e8f0; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.12);
            padding:4px; z-index:9999; white-space:nowrap;
        }
        .step-status-dot-menu.open{ display:flex; gap:4px; }
        .step-status-dot-menu-item{
            width:22px; height:22px; border-radius:50%; border:2px solid transparent;
            cursor:pointer; transition: border-color 0.15s, transform 0.15s;
        }
        .step-status-dot-menu-item:hover{ transform:scale(1.15); border-color:rgba(99,102,241,0.5); }
        .step-status-dot-menu-item[data-val="in_progress"]{ background:rgba(96,165,250,0.7); }
        .step-status-dot-menu-item[data-val="done"]{ background:rgba(34,197,94,0.75); }
        .step-status-dot-menu-item[data-val="review"]{ background:rgba(245,158,11,0.85); }
        @media print{ .step-status-dot-menu{ display:none !important; } }
        .ld-hidden-by-status-filter{ display:none !important; }
/* --- Toggle status selectors (Activity status dropdowns) --- */
body:not(.ld-show-status-selectors) .step-status-dot{ display:none !important; }
body:not(.ld-show-status-selectors) .step-status-dot + *:has(.no-print){ margin-left: 0 !important; }
/* --- Toggle status summaries (Module / Moment / Sous-moment) --- */
body.ld-hide-status-summaries .ld-status-summary{ display:none !important; }



        /* ===== Status summaries – vertical histogram (Module / Moment / Sous-moment) ===== */
        .ld-status-summary:empty{ display:none !important; }
        .ld-status-summary{
            display:inline-flex;
            align-items:flex-end;
            gap:3px;
            padding:2px 6px;
            border:1px solid rgba(226,232,240,1);
            border-radius:6px;
            background:#ffffff;
            user-select:none;
            height:36px;
        }
        .ld-status-summary .ld-ss-empty{
            font-size:9px;
            color:#94a3b8;
            line-height:32px;
        }
        .ld-status-summary .ld-ss-bar-col{
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:flex-end;
            height:100%;
            gap:1px;
        }
        .ld-status-summary .ld-ss-count{
            font-size:8px;
            font-weight:700;
            line-height:1;
            color:#334155;
        }
        .ld-status-summary .ld-ss-bar{
            width:10px;
            min-height:2px;
            border-radius:2px 2px 1px 1px;
            transition: height 0.2s ease;
        }
        .ld-status-summary .ld-ss-bar--done{ background: rgba(34, 197, 94, 0.75); }      /* vert */
        .ld-status-summary .ld-ss-bar--review{ background: rgba(245, 158, 11, 0.85); }   /* orange */
        .ld-status-summary .ld-ss-bar--progress{ background: rgba(96, 165, 250, 0.7); }  /* bleu */

        .step-coherence-indicator { cursor: help; }

/* --- UI: make batch actions bar more visible --- */
#batch-actions-bar{
  background: rgba(15, 23, 42, 0.55); /* slate-900 @ ~55% */
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  border-top: 1px solid rgba(148, 163, 184, 0.35); /* slate-400 */
}
#batch-actions-bar .batch-actions-inner{
  box-shadow: 0 18px 45px rgba(2, 6, 23, 0.35);
}


/* --- Long text fields: compact mode + expand/collapse --- */
textarea.ld-ta-compact {
  height: 3.2em;
  min-height: 3.2em;
}
textarea.ld-ta-expanded {
  height: 110px;
  min-height: 110px;
}
@media (min-width: 640px) {
  textarea.ld-ta-expanded {
    height: 140px;
    min-height: 140px;
  }
}

/* ===== Control Toolbar Responsive ===== */
@media (max-width: 480px) {
  #jump-to-select {
    min-width: 180px !important;
    max-width: 240px !important;
    font-size: 0.7rem;
  }
}

/* ===== View level (Modules / Moments / Sous-moments / Activités) ===== */
body[data-view-level="modules"] .activity-moments-container,
body[data-view-level="modules"] .moment-group,
body[data-view-level="modules"] .submoment-card,
body[data-view-level="modules"] .step-card { display: none !important; }

body[data-view-level="modules"] [data-action="add-step"],
body[data-view-level="modules"] [data-action="add-moment"],
body[data-view-level="modules"] [data-action="add-submoment"],
body[data-view-level="modules"] [data-action="add-step-submoment"] { display: none !important; }

body[data-view-level="moments"] .submoments-controls,
body[data-view-level="moments"] .submoments-container,
body[data-view-level="moments"] .moment-direct-steps,
body[data-view-level="moments"] .step-card { display: none !important; }

body[data-view-level="moments"] [data-action="add-step"],
body[data-view-level="moments"] [data-action="add-submoment"],
body[data-view-level="moments"] [data-action="add-step-submoment"] { display: none !important; }

body[data-view-level="submoments"] .moment-direct-steps,
body[data-view-level="submoments"] .step-card { display: none !important; }

body[data-view-level="submoments"] [data-action="add-step"],
body[data-view-level="submoments"] [data-action="add-step-submoment"] { display: none !important; }


/* ===== LD_HIERARCHY_ACCENTS_V1: Hiérarchie visuelle des blocs (barres + indentation) ===== */
.activity-group,
.moment-group,
.submoment-card,
.step-card { position: relative; }

.activity-group::before,
.moment-group::before,
.submoment-card::before,
.step-card::before {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  width: 4px;
  border-top-left-radius: inherit;
  border-bottom-left-radius: inherit;
  pointer-events: none;
}

/* Niveau 1 : Module */
.activity-group::before { background: rgba(203, 213, 225, 0.95); } /* grey */

/* Niveau 2 : Moment */
.moment-group::before { background: rgba(203, 213, 225, 0.95); } /* grey */

/* Niveau 3 : Sous-moment */
.submoment-card::before { background: rgba(203, 213, 225, 0.95); } /* grey */

/* Overrides for dark/high-contrast modes (keep the rail visible) */
html.ui-dark .activity-group::before,
html.ui-dark .moment-group::before,
html.ui-dark .submoment-card::before { background: rgba(148, 163, 184, 0.55); }

body.hc .activity-group::before,
body.hc .moment-group::before,
body.hc .submoment-card::before { background: #64748b; }


/* Niveau 4 : Activité */
.step-card::before { background: rgba(148, 163, 184, 0.40); } /* slate clair */

/* Indentation progressive (structure hiérarchique) */
.activity-group .activity-moments-container { margin-left: 10px; }
.activity-group .moment-group { margin-left: 10px; }

.moment-group .submoments-controls,
.moment-group .submoments-container,
.moment-group .moment-direct-steps { margin-left: 10px; }

.moment-group .submoments-container .submoment-card { margin-left: 10px; }

.moment-group .moment-direct-steps .step-card,
.submoment-card .step-card { margin-left: 10px; }
/* ===== END_LD_HIERARCHY_ACCENTS_V1 ===== */


/* ===== LD_PANORAMA_VIEW_V1: Vue panoramique (tableau compact) ===== */
#panorama-view { display: none; }
body[data-view-level="panorama" ] #panorama-view { display: block !important; }
body[data-view-level="panorama" ] #activities-root { display: none !important; }

/* Compacité du tableau */
#panorama-table th, #panorama-table td { vertical-align: top; }
#panorama-table tbody tr { border-top: 1px solid rgba(226,232,240,0.9); }
#panorama-table tbody tr:hover { background: rgba(241,245,249,0.6); }
#panorama-table td { padding: 4px 8px; }
#panorama-table td .muted { color: rgba(100,116,139,0.9); }
#panorama-table .pano-open { color: rgba(100,116,139,0.9); }
#panorama-table .pano-open:hover { color: rgba(67,56,202,0.95); }
.ld-panorama-highlight { outline: 2px solid rgba(199,210,254,0.9); outline-offset: 2px; border-radius: 10px; }
/* ===== END_LD_PANORAMA_VIEW_V1 ===== */


/* ===== LD_PANORAMA_MARKERS_BANDING_V1: repères (couleur + forme) + banding par module ===== */
#panorama-table .pano-cell { display: inline-flex; align-items: center; gap: 6px; min-width: 0; }
#panorama-table .pano-text { display: inline-block; min-width: 0; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* Marker base */
#panorama-table .pano-mark {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  border: 1px solid rgba(226,232,240,1);
  font-size: 10px;
  font-weight: 800;
  line-height: 1;
  flex: 0 0 auto;
}

/* Module: carré (indigo) */
#panorama-table .pano-mark-module {
  border-color: rgba(199,210,254,1);
  background: rgba(224,231,255,0.95);
  color: rgba(67,56,202,0.95);
  border-radius: 4px;
}

/* Moment: cercle (indigo clair) */
#panorama-table .pano-mark-moment {
  border-color: rgba(199,210,254,1);
  background: rgba(238,242,255,0.95);
  color: rgba(67,56,202,0.9);
  border-radius: 9999px;
}

/* Sous-moment: losange (slate) */
#panorama-table .pano-mark-sub {
  border-color: rgba(226,232,240,1);
  background: rgba(241,245,249,0.95);
  color: rgba(51,65,85,0.95);
  border-radius: 3px;
  transform: rotate(45deg);
}
#panorama-table .pano-mark-sub .pano-mark-inner {
  transform: rotate(-45deg);
  display: inline-block;
}

/* Banding par module (alternance de fond par groupe) */
#panorama-table tbody tr.pano-band-a { background: rgba(248,250,252,0.55); }
#panorama-table tbody tr.pano-band-b { background: rgba(255,255,255,1); }

/* Hover doit rester plus visible que le banding */
#panorama-table tbody tr:hover { background: rgba(241,245,249,0.8); }
/* ===== END_LD_PANORAMA_MARKERS_BANDING_V1 ===== */


/* ===== LD_PANORAMA_FIXED_TABLE_V1: colonnes harmonisées ===== */
#panorama-table { table-layout: fixed; }
/* ===== END_LD_PANORAMA_FIXED_TABLE_V1 ===== */


/* ===== LD_PANORAMA_DURATION_COL_V2: colonne Durée compacte + tri + sélection ===== */
#panorama-table td.pano-col-duration, #panorama-table th.pano-col-duration { white-space: nowrap; }
#panorama-table td.pano-col-duration { font-variant-numeric: tabular-nums; }

#panorama-table td.pano-col-select, #panorama-table th.pano-col-select { white-space: nowrap; }

#panorama-table .pano-sortable { cursor: pointer; user-select: none; }
#panorama-table .pano-sortable:hover { color: rgba(67,56,202,0.95); }
#panorama-table .pano-sort-ind { margin-left: 4px; font-size: 10px; color: rgba(100,116,139,0.8); }

#panorama-table td.pano-col-status, #panorama-table th.pano-col-status { white-space: nowrap; }
/* ===== END_LD_PANORAMA_DURATION_COL_V2 ===== */

  /* ===== LD_PAGE_WIDTH_CANONICAL ===== */
  :root{
    /* Tailwind max-w-7xl = 80rem (1280px) */
    --ld-page-max-width: 80rem;
  }
  .ld-page{
    max-width: var(--ld-page-max-width);
    margin-left: auto;
    margin-right: auto;
    width: 100%;
  }
  /* ===== END_LD_PAGE_WIDTH_CANONICAL ===== */



/* --- Ignore (cocher-décocher) --- */
.ld-ignore-label{
  display:flex;
  align-items:center;
  gap:4px;
  font-size:11px;
  font-weight:700;
  color:#64748b;
  user-select:none;
  cursor:pointer;
}
.ld-ignore-label input{
  width:14px;
  height:14px;
}
.ld-ignored{ opacity:0.55; }
.ld-ignored .ld-ignore-label,
.ld-ignored .ld-ignore-label *{ opacity:1; }
.ld-ignored-inherited{ opacity:0.65; }
.ld-ignored .step-header,
.ld-ignored .moment-header,
.ld-ignored .submoment-header{
  background-image: repeating-linear-gradient(
    45deg,
    rgba(148,163,184,0.12),
    rgba(148,163,184,0.12) 6px,
    rgba(148,163,184,0.02) 6px,
    rgba(148,163,184,0.02) 12px
  );
}

</style>
<script>
/* Modèles: stubs globaux disponibles dès le chargement (évite les clics "inerte" avant l'initialisation).
   Les vraies implémentations sont branchées plus bas dans le fichier. */
(function(){
  window.__pendingTemplateModal = null;

  function callOrQueue(which){
    const fn = (which === 'export') ? window.__realOpenTemplateExport : window.__realOpenTemplateImport;
    if (typeof fn === 'function') return fn();
    window.__pendingTemplateModal = which;
  }

  window.openTemplateExportModal = function(){ return callOrQueue('export'); };
  window.openTemplateImportModal = function(){ return callOrQueue('import'); };

  // Sécurisation clic: déclenchement immédiat même si un overlay capte l'évènement.
  // On ne déclenche QUE si le point de clic tombe dans la zone exacte des boutons "Modèles".
  (function(){
    function hitTestRect(el, x, y){
      if (!el) return false;
      const r = el.getBoundingClientRect();
      return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
    }
    function handlePointer(e){
      // uniquement clic primaire / toucher
      if (e.type === 'mousedown' && e.button !== 0) return;
      const x = e.clientX, y = e.clientY;
      const expBtn = document.getElementById('btn-template-export');
      const impBtn = document.getElementById('btn-template-import');
      const hitExport = hitTestRect(expBtn, x, y);
      const hitImport = hitTestRect(impBtn, x, y);
      if (!hitExport && !hitImport) return;

      // Empêche tout routeur global de détourner / retarder l'action
      try { e.preventDefault(); } catch(_){ __ldSilentErr(_); }
      try { e.stopImmediatePropagation(); } catch(_){ __ldSilentErr(_); }
      try { e.stopPropagation(); } catch(_){ __ldSilentErr(_); }

      if (hitExport) window.openTemplateExportModal();
      else window.openTemplateImportModal();
    }

    // Capture le plus tôt possible
    window.addEventListener('pointerdown', handlePointer, true);
    window.addEventListener('mousedown', handlePointer, true);
    window.addEventListener('touchstart', handlePointer, { capture: true, passive: false });
  })();


  // flush appelé une fois que les vraies fonctions sont disponibles
  window.__flushPendingTemplateModal = function(){
    const w = window.__pendingTemplateModal;
    if (!w) return;
    window.__pendingTemplateModal = null;
    const fn = (w === 'export') ? window.__realOpenTemplateExport : window.__realOpenTemplateImport;
    if (typeof fn === 'function') fn();
  };

  // Menu "Plus…" (overflow) — fermeture auto (click extérieur / Échap)
  window.toggleMoreMenu = function(ev){
    try { if (ev) { ev.preventDefault(); ev.stopPropagation(); } } catch(_){ __ldSilentErr(_); }
    const menu = document.getElementById('more-menu');
    if (!menu) return;
    menu.classList.toggle('hidden');
  };
  window.closeMoreMenu = function(){
    const menu = document.getElementById('more-menu');
    if (menu) menu.classList.add('hidden');
  };

  // Fermeture au clic extérieur (capture pour ne pas dépendre de l'ordre des handlers)
  document.addEventListener('click', function(e){
    const menu = document.getElementById('more-menu');
    const btn = document.getElementById('btn-more');
    if (!menu || menu.classList.contains('hidden')) return;
    if (menu.contains(e.target) || (btn && btn.contains(e.target))) return;
    menu.classList.add('hidden');
  }, true);

  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape') window.closeMoreMenu();
  }, true);


  

  // Unified diagnostics, action registry, and resilient event delegation (capture phase).
  // Goals:
  // - Avoid inert buttons by only intercepting recognised actions.
  // - Provide a diagnostics panel (toggle via menu) and a unified error pipeline.
  (function initDataActionRegistryAndDiagnostics(){
    const DIAG = (function(){
      const existing = window.__uiDiag;
      if (existing && typeof existing === 'object') return existing;
      return (window.__uiDiag = { enabled: false, actions: [], errors: [], max: 200, startedAt: Date.now() });
    })();

    function nowIso(){
      try { return new Date().toISOString(); } catch(_) { return ''+Date.now(); }
    }

    function pushRing(arr, item){
      try {
        arr.push(item);
        const max = (DIAG && DIAG.max) ? DIAG.max : 200;
        if (arr.length > max) arr.splice(0, arr.length - max);
      } catch(_){ __ldSilentErr(_); }
    }

    function qs(id){
      try { return document.getElementById(id); } catch(_) { return null; }
    }

    function renderDiagnostics(){
      const panel = qs('ui-debug-panel');
      if (!panel) return;
      if (DIAG.enabled) panel.classList.remove('hidden');
      else panel.classList.add('hidden');

      const aCount = qs('ui-debug-actions-count');
      const eCount = qs('ui-debug-errors-count');
      if (aCount) aCount.textContent = String(DIAG.actions.length);
      if (eCount) eCount.textContent = String(DIAG.errors.length);

      const aList = qs('ui-debug-actions');
      const eList = qs('ui-debug-errors');
      if (aList) {
        aList.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (const entry of DIAG.actions.slice().reverse().slice(0, 60)) {
          const div = document.createElement('div');
          div.className = 'py-0.5 border-b border-slate-100 last:border-0';
          div.textContent = `[${entry.t}] ${entry.action}` + (entry.hint ? ` — ${entry.hint}` : '');
          frag.appendChild(div);
        }
        aList.appendChild(frag);
      }
      if (eList) {
        eList.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (const entry of DIAG.errors.slice().reverse().slice(0, 60)) {
          const div = document.createElement('div');
          div.className = 'py-0.5 border-b border-slate-100 last:border-0 whitespace-pre-wrap';
          const ctx = entry.context ? ` (${entry.context})` : '';
          div.textContent = `[${entry.t}] ${entry.message}${ctx}`;
          frag.appendChild(div);
        }
        eList.appendChild(frag);
      }
    }

    function setDiagnosticsEnabled(enabled){
      DIAG.enabled = !!enabled;
      try { localStorage.setItem('ui_debug', DIAG.enabled ? '1' : '0'); } catch(_){ __ldSilentErr(_); }
      renderDiagnostics();
    }

    // Expose minimal API
    window.__uiDiagSetEnabled = setDiagnosticsEnabled;
    window.__uiDiagLogAction = function(action, hint){
      pushRing(DIAG.actions, { t: nowIso(), action: String(action||''), hint: hint ? String(hint) : '' });
      if (DIAG.enabled) renderDiagnostics();
    };
    window.__uiDiagLogError = function(message, context){
      pushRing(DIAG.errors, { t: nowIso(), message: String(message||'Erreur'), context: context ? String(context) : '' });
      if (DIAG.enabled) renderDiagnostics();
    };

    // Global lightweight error logger for catch blocks (Fix 5)
    window.__ldSilentErr = function(e) {
        try { if (window.__uiDiagLogError) window.__uiDiagLogError(String(e && e.message || e || 'silent catch'), 'catch'); } catch(_){ __ldSilentErr(_); }
    };
    const __ldSilentErr = window.__ldSilentErr;


    function buildDiagReport(){
      const meta = {
        generatedAt: nowIso(),
        startedAt: (function(){ try { return new Date(DIAG.startedAt).toISOString(); } catch(_) { return String(DIAG.startedAt||''); } })(),
        url: (function(){ try { return String(location && location.href || ''); } catch(_) { return ''; } })(),
        userAgent: (function(){ try { return String(navigator && navigator.userAgent || ''); } catch(_) { return ''; } })(),
        title: (function(){ try { return String(document && document.title || ''); } catch(_) { return ''; } })(),
        versionHint: (function(){
          try {
            const t = (document && document.title) ? String(document.title) : '';
            const m = t.match(/v\.?\s*([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i);
            return m ? m[1] : '';
          } catch(_) { return ''; }
        })(),
        counts: { actions: DIAG.actions.length, errors: DIAG.errors.length }
      };
      return {
        meta,
        actions: DIAG.actions.slice(-DIAG.max),
        errors: DIAG.errors.slice(-DIAG.max)
      };
    }

    function formatDiagReportText(report){
      try {
        const m = report && report.meta ? report.meta : {};
        const lines = [];
        lines.push('=== Diagnostic UI Report ===');
        lines.push('Generated: ' + (m.generatedAt || ''));
        if (m.versionHint) lines.push('Version: ' + m.versionHint);
        if (m.title) lines.push('Title: ' + m.title);
        if (m.url) lines.push('URL: ' + m.url);
        if (m.userAgent) lines.push('User-Agent: ' + m.userAgent);
        lines.push('Counts: actions=' + ((m.counts && m.counts.actions) || 0) + ' errors=' + ((m.counts && m.counts.errors) || 0));
        lines.push('');
        lines.push('--- Last Actions (most recent first) ---');
        for (const a of (report.actions || []).slice().reverse().slice(0, 80)) {
          lines.push('[' + (a.t || '') + '] ' + (a.action || '') + (a.hint ? (' — ' + a.hint) : ''));
        }
        lines.push('');
        lines.push('--- Last Errors (most recent first) ---');
        for (const e of (report.errors || []).slice().reverse().slice(0, 80)) {
          lines.push('[' + (e.t || '') + '] ' + (e.message || '') + (e.context ? (' (' + e.context + ')') : ''));
        }
        lines.push('');
        lines.push('=== End ===');
        return lines.join('\n');
      } catch(_) {
        return 'Diagnostic UI Report (formatting failed)';
      }
    }

    function copyTextToClipboard(text){
      try {
        const s = String(text || '');
        if (navigator && navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
          return navigator.clipboard.writeText(s);
        }
      } catch(_){ __ldSilentErr(_); }
      // Fallback
      return new Promise(function(resolve, reject){
        try {
          const ta = document.createElement('textarea');
          ta.value = String(text || '');
          ta.setAttribute('readonly', '');
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          ta.style.top = '0';
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand && document.execCommand('copy');
          document.body.removeChild(ta);
          if (ok) resolve();
          else reject(new Error('Copy failed'));
        } catch (err) {
          reject(err);
        }
      });
    }

    function downloadContent(filename, content, mime){
      try {
        const blob = new Blob([content], { type: mime || 'text/plain;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function(){
          try { URL.revokeObjectURL(a.href); } catch(_){ __ldSilentErr(_); }
          try { document.body.removeChild(a); } catch(_){ __ldSilentErr(_); }
        }, 0);
      } catch (err) {
        try { window.reportError(err, { action: 'downloadContent' }); } catch(_){ __ldSilentErr(_); }
      }
    }



    // Global alert helper used across import/export flows.
    // Uses the existing modal when available, otherwise falls back to window.alert.
    window.showAlert = window.showAlert || function(title, message){
      try {
        const modal = document.getElementById('import-error-modal');
        const titleEl = document.getElementById('import-error-title');
        const bodyEl  = document.getElementById('import-error-body');

        // Best-effort: hide advanced buttons for generic alerts.
        const btnDownload = document.getElementById('import-error-download');
        const btnCopy = document.getElementById('import-error-copy');
        const btnRecover = document.getElementById('import-error-recover');
        const btnCopyRecovery = document.getElementById('import-error-copy-recovery');

        if (modal && titleEl && bodyEl) {
          titleEl.textContent = (title == null || title === '') ? 'Alerte' : String(title);
          // Use textContent to avoid injecting HTML.
          bodyEl.textContent = (message == null) ? '' : String(message);
          if (btnDownload) btnDownload.classList.add('hidden');
          if (btnCopy) btnCopy.classList.add('hidden');
          if (btnRecover) btnRecover.classList.add('hidden');
          if (btnCopyRecovery) btnCopyRecovery.classList.add('hidden');
          modal.classList.remove('hidden');
          return;
        }
      } catch(_){ __ldSilentErr(_); }
      try {
        window.alert(((title ? String(title) + ': ' : '')) + (message == null ? '' : String(message)));
      } catch(_) {
        // Final fallback
        console.log('[Alert]', title, message);
      }
    };
    function notifyDiag(message){
      try {
        if (typeof window.showAlert === 'function') {
          window.showAlert('Diagnostic UI', message);
          return;
        }
      } catch(_){ __ldSilentErr(_); }
      console.log('[Diagnostic UI]', message);
    }

    // Expose report builder for external usage
    window.__uiDiagBuildReport = buildDiagReport;
    window.__uiDiagFormatReportText = formatDiagReportText;

    // Unified error reporting.
    window.reportError = function(err, context){
      try {
        const msg = (err && (err.message || err.reason)) ? String(err.message || err.reason) : (typeof err === 'string' ? err : 'Erreur');
        const ctx = context ? (typeof context === 'string' ? context : (context.action ? `action:${context.action}` : (context.type ? String(context.type) : ''))) : '';
        console.error('[UIError]', { context, err });
        try { window.__uiDiagLogError(msg, ctx); } catch(_){ __ldSilentErr(_); }

        // Show banner (best-effort)
        const banner = qs('js-error-banner');
        if (banner) {
          try {
            banner.style.display = 'block';
            const t = banner.querySelector('[data-js-error-text]');
            if (t) t.innerText = msg;
          } catch(_){ __ldSilentErr(_); }
        } else {
          // If DOM not ready yet, stash last error.
          window.__pendingJsError = msg;
        }
      } catch(_){ __ldSilentErr(_); }
    };

    // Attach global handlers once.
    if (!window.__uiGlobalErrorHandlersInstalled) {
      window.__uiGlobalErrorHandlersInstalled = true;
      window.addEventListener('error', function(event){
        try {
          const err = event && event.error ? event.error : event;
          window.reportError(err, { type: 'error', message: event && event.message, filename: event && event.filename, lineno: event && event.lineno, colno: event && event.colno });
        } catch(_){ __ldSilentErr(_); }
      }, true);
      window.addEventListener('unhandledrejection', function(event){
        try {
          const reason = event ? event.reason : event;
          window.reportError(reason, { type: 'unhandledrejection' });
        } catch(_){ __ldSilentErr(_); }
      }, true);

      // Flush pending banner message once DOM exists.
      document.addEventListener('DOMContentLoaded', function(){
        try {
          if (window.__pendingJsError) {
            const banner = qs('js-error-banner');
            if (banner) {
              banner.style.display = 'block';
              const t = banner.querySelector('[data-js-error-text]');
              if (t) t.innerText = window.__pendingJsError;
              window.__pendingJsError = null;
            }
          }
          // restore diagnostics enabled state
          try {
            const flag = localStorage.getItem('ui_debug');
            if (flag === '1') setDiagnosticsEnabled(true);
          } catch(_){ __ldSilentErr(_); }
        } catch(_){ __ldSilentErr(_); }
      }, { once: true });
    }

    // Hover badge for elements with data-action* when diagnostics is enabled.
    (function initHoverBadge(){
      let lastLabel = '';
      const hover = function(e){
        try {
          if (!DIAG.enabled) {
            const el = qs('ui-debug-hover');
            if (el) el.classList.add('hidden');
            return;
          }
          const t = e.target && e.target.closest ? e.target.closest('[data-action],[data-action-change],[data-action-input]') : null;
          const el = qs('ui-debug-hover');
          if (!el) return;
          if (!t) { el.classList.add('hidden'); return; }
          const label = t.getAttribute('data-action') || t.getAttribute('data-action-change') || t.getAttribute('data-action-input') || '';
          if (!label) { el.classList.add('hidden'); return; }
          if (label !== lastLabel) {
            el.textContent = label;
            lastLabel = label;
          }
          el.style.left = (e.clientX + 12) + 'px';
          el.style.top = (e.clientY + 12) + 'px';
          el.classList.remove('hidden');
        } catch(_){ __ldSilentErr(_); }
      };
      document.addEventListener('mousemove', hover, true);
      document.addEventListener('scroll', function(){
        try { const el = qs('ui-debug-hover'); if (el) el.classList.add('hidden'); } catch(_){ __ldSilentErr(_); }
      }, true);
    })();

    function missing(action){
      try {
        window.__uiDiagLogAction(action, 'action inconnue');
        console.warn('[ActionRegistry] Missing handler for:', action);
      } catch(_){ __ldSilentErr(_); }
    }

    function call(name){
      const fn = window[name];
      if (typeof fn !== 'function') throw new Error('Missing handler: ' + name);
      const args = Array.prototype.slice.call(arguments, 1);
      return fn.apply(window, args);
    }

    const ACTIONS = Object.freeze({
      // Modules / steps / moments
      'duplicate-module': ({btn}) => call('cloneModule', btn),
      'delete-module': ({event, btn}) => call('trashModule', event, btn),
      'duplicate-step': ({btn, event}) => call('openDuplicateStepMenu', btn, event),
      'delete-step': ({btn}) => call('trashStep', btn),
      'add-step': ({btn}) => call('addStepToActivity', btn),
      'add-moment': ({btn}) => call('addMomentToActivity', btn),
      'add-submoment': ({btn}) => call('addSubmomentToMoment', btn),
      'delete-submoment': ({btn}) => call('deleteSubmoment', btn),
      'add-step-submoment': ({btn}) => call('addStepToSubmoment', btn),
      'toggle-submoment': ({btn}) => call('toggleSubmoment', btn),
      'toggle-submoment-notes': ({btn}) => call('toggleSubmomentNotes', btn),
      'toggle-module-description': ({btn}) => call('toggleDescription', btn),
      'toggle-module': ({btn}) => call('toggleActivity', btn),
      'toggle-step': ({btn}) => call('toggleStep', btn),
      'toggle-moment-description': ({btn}) => call('toggleMomentDescription', btn),
      'toggle-moment': ({btn}) => call('toggleMoment', btn),
      'delete-moment': ({btn}) => call('trashMoment', btn),
      'select-all-moment': ({btn}) => { try { if (typeof window.selectAllStepsInMoment === 'function') window.selectAllStepsInMoment(btn); } catch(_){ __ldSilentErr(_); } },
      'focus-module': ({btn}) => call('toggleFocusModule', btn),

      // Key params helpers
      'add-outcome': () => call('safeAddOutcome'),
      'add-aim-item': () => call('safeAddAimItem'),
      'add-outcomes-text-item': () => call('safeAddOutcomesTextItem'),

    'add-tools-materials-item': () => call('safeAddToolsMaterialsItem'),
    'remove-tools-materials-item': ({btn}) => {
        const li = btn.closest('li');
        if (li) li.remove();
        try { syncToolsMaterialsTextareaFromList(); } catch(_){ __ldSilentErr(_); }
    },
      'add-competence': () => call('safeAddCompetence'),
      'add-competence-transversal': () => call('safeAddCompetenceTransversal'),
      'open-aims-from-step': ({btn}) => call('openAimsFromStep', btn),
      'open-outcomes-from-step': ({btn}) => call('openOutcomesFromStep', btn),
      'back-to-aims-origin': () => call('backToAimsOrigin'),
      'remove-aim-item': ({btn}) => {
        const li = btn.closest('li');
        if (li) li.remove();
        if (typeof window.syncAimsTextareaFromList === 'function') window.syncAimsTextareaFromList();
      },
      'remove-outcomes-text-item': ({btn}) => {
        const li = btn.closest('li');
        if (li) li.remove();
        if (typeof window.syncOutcomesTextTextareaFromList === 'function') window.syncOutcomesTextTextareaFromList();
      },

      // Module subblocks / competences selectors
      'toggle-module-subblocks': ({btn}) => {
        const mod = btn.closest('.activity-group');
        if (!mod) return;
        const body = mod.querySelector('.activity-body');
        if (body && body.classList.contains('collapsed')) {
          body.classList.remove('collapsed');
          const toggleBtn = mod.querySelector('button[data-action="toggle-module"]');
          const icon = toggleBtn ? toggleBtn.querySelector('.rotate-icon') : null;
          if (icon) icon.style.transform = 'rotate(180deg)';
        }
        const box = mod.querySelector('.module-subblocks');
        if (box) {
          const willOpen = box.classList.contains('hidden');
          box.classList.toggle('hidden');
          btn.setAttribute('aria-pressed', willOpen ? 'true' : 'false');
        }
      },
      'toggle-module-competences': ({btn}) => {
        const mod = btn.closest('.activity-group');
        if (!mod) return;
        const body = mod.querySelector('.activity-body');
        if (body && body.classList.contains('collapsed')) {
          body.classList.remove('collapsed');
          const toggleBtn = mod.querySelector('button[data-action="toggle-module"]');
          const icon = toggleBtn ? toggleBtn.querySelector('.rotate-icon') : null;
          if (icon) icon.style.transform = 'rotate(180deg)';
        }
        const det = mod.querySelector('details.module-competence-summary');
        if (det) {
          det.open = !det.open;
          btn.setAttribute('aria-pressed', det.open ? 'true' : 'false');
        }
      },
      'select-module-aims': ({btn}) => {
        const mod = btn.closest('.activity-group');
        if (mod && typeof window.openModuleSelectionFor === 'function') window.openModuleSelectionFor(mod, 'aims');
      },
      'select-module-outcomes': ({btn}) => {
        const mod = btn.closest('.activity-group');
        if (mod && typeof window.openModuleSelectionFor === 'function') window.openModuleSelectionFor(mod, 'outcomes');
      },
      'add-module-competence-manual': ({btn}) => call('addModuleCompetenceManual', btn),
      'add-module-aim-manual': ({btn}) => call('addModuleAimManual', btn),
      'add-module-outcome-manual': ({btn}) => call('addModuleOutcomeManual', btn),

      // Header / menus / global controls
      'save-project': () => call('saveProject'),
      'load-project': () => call('triggerFileLoad'),
      'toggle-more-menu': ({event}) => call('toggleMoreMenu', event),
      'open-template-export-modal': () => { call('openTemplateExportModal'); call('closeMoreMenu'); },
      'open-template-import-modal': () => { call('openTemplateImportModal'); call('closeMoreMenu'); },
      'trigger-language-pack-load': () => { call('triggerLanguagePackLoad'); call('closeMoreMenu'); },
      'export-language-pack-template': () => { call('exportLanguagePackTemplate'); call('closeMoreMenu'); },
      'open-i18n-audit': () => { call('openI18nAudit'); call('closeMoreMenu'); },
      'toggle-all-activities': () => call('toggleAllActivities'),
      'toggle-learning-types': () => call('toggleLearningTypes'),
      'toggle-target-durations': () => call('toggleTargetDurations'),
      'toggle-panel': ({btn}) => {
        const pid = btn && btn.dataset ? btn.dataset.panel : null;
        if (pid) call('togglePanel', pid);
      },
      'toggle-timeline-details': () => call('toggleTimelineDetails'),
      'add-activity': () => call('addActivity'),
      'hide-js-error-banner': () => {
        const b = qs('js-error-banner');
        if (b) b.style.display = 'none';
      },
      'close-i18n-audit': () => call('closeI18nAudit'),
      'run-i18n-audit': () => call('runI18nAudit'),
      'download-i18n-audit-report': () => call('downloadI18nAuditReport'),

      // Diagnostics
      'toggle-debug-ui': () => {
        setDiagnosticsEnabled(!DIAG.enabled);
        try { call('closeMoreMenu'); } catch(_){ __ldSilentErr(_); }
      },
      'clear-debug-log': () => {
        try { DIAG.actions.length = 0; DIAG.errors.length = 0; renderDiagnostics(); } catch(_){ __ldSilentErr(_); }
      },
      'copy-debug-report': () => {
        try {
          const report = (typeof window.__uiDiagBuildReport === 'function') ? window.__uiDiagBuildReport() : null;
          const text = (report && typeof window.__uiDiagFormatReportText === 'function') ? window.__uiDiagFormatReportText(report) : 'Diagnostic UI Report';
          const p = copyTextToClipboard(text);
          if (p && typeof p.then === 'function') {
            p.then(function(){
              try { notifyDiag('Rapport copié dans le presse-papiers.'); } catch(_){ __ldSilentErr(_); }
            }).catch(function(err){
              try { window.reportError(err, { action: 'copy-debug-report' }); } catch(_){ __ldSilentErr(_); }
              try { notifyDiag('Copie impossible.'); } catch(_){ __ldSilentErr(_); }
            });
          } else {
            notifyDiag('Rapport copié dans le presse-papiers.');
          }
        } catch (err) {
          try { window.reportError(err, { action: 'copy-debug-report' }); } catch(_){ __ldSilentErr(_); }
        }
      },
      'download-debug-report': () => {
        try {
          const report = (typeof window.__uiDiagBuildReport === 'function') ? window.__uiDiagBuildReport() : null;
          const ts = (function(){
            try { return nowIso().replace(/[:.]/g,'-'); } catch(_) { return ''+Date.now(); }
          })();
          const fname = 'diagnostic_report_' + ts + '.json';
          const json = (function(){
            try { return JSON.stringify(report || {}, null, 2); } catch(_) { return '{}'; }
          })();
          downloadContent(fname, json, 'application/json;charset=utf-8');
          try { notifyDiag('Rapport téléchargé.'); } catch(_){ __ldSilentErr(_); }
        } catch (err) {
          try { window.reportError(err, { action: 'download-debug-report' }); } catch(_){ __ldSilentErr(_); }
        }
      }
    });

    const CHANGE_ACTIONS = Object.freeze({
      'handle-export': ({el}) => call('handleExport', el),
      'load-project-file': ({event}) => call('loadProject', event),
      'handle-ui-language-change': ({el}) => call('handleUiLanguageChange', el),
      'load-language-pack': ({event}) => call('loadLanguagePack', event),
      'handle-view-style-change': ({el}) => call('handleViewStyleChange', el),
      'handle-ui-theme-change': ({el}) => call('handleUiThemeChange', el),
      'update-stats': () => call('updateStats'),
      'update-step-type': ({el}) => call('updateStepType', el),
      'update-step-status': ({el}) => call('updateStepStatus', el),
      'toggle-group-mode': ({el}) => call('toggleGroupMode', el)
    });

    const INPUT_ACTIONS = Object.freeze({
      'update-stats-debounced': () => call('updateStatsDebounced'),
      'update-group-math': ({el}) => {
        const mode = (el && el.dataset) ? (el.dataset.groupMath || el.dataset.arg || '') : '';
        call('updateGroupMath', el, mode);
      }
    });

    // Internal dispatch helper (also used for keyboard shortcuts)
    function dispatchAction(action, ctx){
      try {
        const fn = ACTIONS[action];
        if (typeof fn !== 'function') { try { missing(action); } catch(_){ __ldSilentErr(_); } return; }
        try { window.__uiDiagLogAction(action); } catch(_){ __ldSilentErr(_); }
        try {
          const res = fn(Object.assign({ action: action }, ctx || {}));
          if (res && typeof res.then === 'function') {
            res.catch(function(err){ try { window.reportError(err, { action }); } catch(_){ __ldSilentErr(_); } });
          }
        } catch (err) {
          try { window.reportError(err, { action }); } catch(_){ __ldSilentErr(_); }
        }
      } catch(_){ __ldSilentErr(_); }
    }

    // Log unknown data-action without intercepting behaviour (helps diagnose inert buttons).
    document.addEventListener('click', function(e){
      try {
        if (!DIAG.enabled) return;
        const btn = e.target && e.target.closest ? e.target.closest('[data-action]') : null;
        if (!btn) return;
        const action = btn.dataset ? btn.dataset.action : null;
        if (!action) return;
        if (typeof ACTIONS[action] === 'function') return;
        try { window.__uiDiagLogAction(action, 'action inconnue'); } catch(_){ __ldSilentErr(_); }
      } catch(_){ __ldSilentErr(_); }
    }, true);

    // Keyboard shortcuts (Ctrl/Cmd + Alt):
    // - D: toggle Diagnostic UI
    // - C: copy report
    // - S: download report
    document.addEventListener('keydown', function(e){
      try {
        const isCmdCtrl = !!(e.ctrlKey || e.metaKey);
        if (!isCmdCtrl || !e.altKey) return;
        const k = String(e.key || '').toLowerCase();
        if (k === 'd') { e.preventDefault(); dispatchAction('toggle-debug-ui', { event: e }); }
        else if (k === 'c') { e.preventDefault(); dispatchAction('copy-debug-report', { event: e }); }
        else if (k === 's') { e.preventDefault(); dispatchAction('download-debug-report', { event: e }); }
      } catch(_){ __ldSilentErr(_); }
    }, true);


    document.addEventListener('click', function(e){
      const btn = e.target && e.target.closest ? e.target.closest('button[data-action]') : null;
      if (!btn) return;
      const action = btn.dataset ? btn.dataset.action : null;
      if (!action) return;
      const fn = ACTIONS[action];
      if (typeof fn !== 'function') return; // do not block unknown actions

      try {
        e.preventDefault();
        e.stopPropagation();
      } catch(_){ __ldSilentErr(_); }

      try {
        window.__uiDiagLogAction(action);
        fn({ event: e, btn, action });
      } catch (err) {
        try { window.reportError(err, { action }); } catch(_){ __ldSilentErr(_); }
      }
    }, true);

    document.addEventListener('change', function(e){
      const el = e.target && e.target.closest ? e.target.closest('[data-action-change]') : null;
      if (!el) return;
      const action = el.dataset ? el.dataset.actionChange : null;
      if (!action) return;
      const fn = CHANGE_ACTIONS[action];
      if (typeof fn !== 'function') return;

      try {
        e.stopPropagation();
      } catch(_){ __ldSilentErr(_); }

      try {
        window.__uiDiagLogAction('change:' + action);
        fn({ event: e, el, action });
      } catch (err) {
        try { window.reportError(err, { action: 'change:' + action }); } catch(_){ __ldSilentErr(_); }
      }
    }, true);

            // Capture notes for per-activity tools/materials
            document.addEventListener('input', function(e){
                const t = e.target;
                if (!t) return;
                if (t.matches && t.matches('textarea.step-toolmat-note')) {
                    const stepEl = t.closest('.step-card');
                    if (!stepEl) return;
                    const tool = String(t.dataset ? (t.dataset.tool || '') : '').trim();
                    if (!tool) return;
                    const map = __getStepToolMatNotesMap(stepEl);
                    map[tool] = (t.value == null) ? '' : String(t.value);
                    __setStepToolMatNotesMap(stepEl, map);
                    try { updateStepHeaderChips(stepEl); } catch(_){ __ldSilentErr(_); }
                }
            }, true);


    document.addEventListener('input', function(e){
      const el = e.target && e.target.closest ? e.target.closest('[data-action-input]') : null;
      if (!el) return;
      const action = el.dataset ? el.dataset.actionInput : null;
      if (!action) return;
      const fn = INPUT_ACTIONS[action];
      if (typeof fn !== 'function') return;

      try {
        e.stopPropagation();
      } catch(_){ __ldSilentErr(_); }

      try {
        window.__uiDiagLogAction('input:' + action);
        fn({ event: e, el, action });
      } catch (err) {
        try { window.reportError(err, { action: 'input:' + action }); } catch(_){ __ldSilentErr(_); }
      }
    }, true);


    // Internal shortcuts routed through the same action registry (Ctrl+Alt+D/C/S).
    document.addEventListener('keydown', function(e){
      try {
        const isCmdCtrl = !!(e.ctrlKey || e.metaKey);
        if (!isCmdCtrl || !e.altKey) return;
        const key = (e.key || '').toLowerCase();
        if (key === 'd') { e.preventDefault(); try { const fn = ACTIONS['toggle-debug-ui']; if (typeof fn === 'function') fn({ event: e, action: 'toggle-debug-ui' }); } catch(err) { try { window.reportError(err, { action: 'toggle-debug-ui' }); } catch(_){ __ldSilentErr(_); } } }
        if (key === 'c') { e.preventDefault(); try { const fn = ACTIONS['copy-debug-report']; if (typeof fn === 'function') fn({ event: e, action: 'copy-debug-report' }); } catch(err) { try { window.reportError(err, { action: 'copy-debug-report' }); } catch(_){ __ldSilentErr(_); } } }
        if (key === 's') { e.preventDefault(); try { const fn = ACTIONS['download-debug-report']; if (typeof fn === 'function') fn({ event: e, action: 'download-debug-report' }); } catch(err) { try { window.reportError(err, { action: 'download-debug-report' }); } catch(_){ __ldSilentErr(_); } } }
      } catch(_){ __ldSilentErr(_); }
    }, true);

    // Restore diagnostics state early
    try {
      const flag = localStorage.getItem('ui_debug');
      if (flag === '1') setDiagnosticsEnabled(true);
    } catch(_){ __ldSilentErr(_); }

  })();


})();


// ---- Plain-text paste for text fields (keep Markdown visible, no rich formatting) ----
function __ldEnablePlainTextPaste(){
  const isTextField = (el)=>{
    if(!el) return false;
    if(el.isContentEditable) return true;
    if(!el.matches) return false;
    return el.matches('textarea, input[type="text"], input[type="search"]');
  };
  document.addEventListener('paste', (e)=>{
    const t = e.target;
    if(!isTextField(t)) return;

    const cd = e.clipboardData || window.clipboardData;
    if(!cd) return;

    // Prefer plain text so Markdown syntax is pasted as-is
    const plain = cd.getData('text/plain');
    if(plain === null || plain === undefined) return;

    e.preventDefault();

    if(t.isContentEditable){
      // Insert plain text at caret (keeps Markdown characters visible)
      try{
        document.execCommand('insertText', false, plain);
      }catch(_){
        const sel = window.getSelection && window.getSelection();
        if(sel && sel.rangeCount){
          sel.deleteFromDocument();
          sel.getRangeAt(0).insertNode(document.createTextNode(plain));
        }
      }
      return;
    }

    // Inputs / textareas
    const start = (typeof t.selectionStart === 'number') ? t.selectionStart : (t.value || '').length;
    const end   = (typeof t.selectionEnd === 'number') ? t.selectionEnd : (t.value || '').length;
    const val   = (t.value || '');
    t.value = val.slice(0, start) + plain + val.slice(end);
    const pos = start + plain.length;
    if(t.setSelectionRange) t.setSelectionRange(pos, pos);
    // Trigger downstream computations / autosize / exports
    t.dispatchEvent(new Event('input', { bubbles: true }));
  }, true);
}
document.addEventListener('DOMContentLoaded', __ldEnablePlainTextPaste);

</script>

<style id="top-level-tabs-style">
  body.top-tabs-enabled .top-tab-btn{
    flex: 1 1 0%;
    min-width: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 6px 10px;
    border-radius: 10px;
    border: 1px solid transparent;
    user-select: none;
    cursor: pointer;
    font-size: 10px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    line-height: 1.15;
    text-align: center;
    background: transparent;
  }
  body.top-tabs-enabled .top-tab-label{
    display: block;
    white-space: normal;
  }
  body.top-tabs-enabled .top-tab-btn[aria-selected="true"]{
    background-color: #f1f5f9;
    color: #0f172a;
    border-color: #cbd5e1;
  }
  body.top-tabs-enabled .top-tab-btn[aria-selected="false"]{
    color: #334155;
    background: transparent;
    border-color: transparent;
  }
  body.top-tabs-enabled .top-tab-btn:focus-visible{
    outline: 2px solid #6366f1;
    outline-offset: 2px;
  }

  body.top-tabs-enabled .top-tab-btn[aria-selected="false"]:hover{
    border-color: #cbd5e1;
  }
  body.hc.top-tabs-enabled .top-tab-btn[aria-selected="false"]:hover{
    border-color: #0f172a;
  }

  body.hc.top-tabs-enabled .top-tab-btn[aria-selected="true"]{
    background-color: #ffffff;
    color: #0f172a;
    border-color: #0f172a;
  }
  body.hc.top-tabs-enabled .top-tab-btn[aria-selected="false"]{
    color: #0f172a;
    background: transparent;
    border-color: transparent;
  }

  /* Replace accordion headers with level-1 tabs */
  body.top-tabs-enabled button[data-panel="key-params-panel"],
  body.top-tabs-enabled button[data-panel="timeline-panel"],
  body.top-tabs-enabled #analysis-tabs-wrap > summary{
    display: none !important;
  }

  /* Force the corresponding content blocks open only when their tab is active */
  body.top-tabs-enabled[data-top-tab="info"] #key-params-panel{
    display: block !important;
  }
  body.top-tabs-enabled[data-top-tab="visual"] #timeline-panel{
    display: block !important;
    margin-top: 0 !important;
  }
  body.top-tabs-enabled[data-top-tab="info"] #key-params-panel #kpwiz-bar{
    border-top: 0 !important;
  }

  /* Ensure collapsible panel contents are visible only for the active tab */
  body.top-tabs-enabled[data-top-tab="info"] #key-params-panel,
  body.top-tabs-enabled[data-top-tab="visual"] #timeline-panel{
    max-height: none !important;
    opacity: 1 !important;
    overflow: visible !important;
    transition: none !important;
  }
  body.top-tabs-enabled[data-top-tab="info"] #key-params-panel.open,
  body.top-tabs-enabled[data-top-tab="visual"] #timeline-panel.open{
    max-height: none !important;
    opacity: 1 !important;
  }
</style>

<!-- LD PATCH: Ensure all dropdowns (select) are opaque (no transparent background) -->
<style id="ld-opaque-selects">
  /* Global: all selects must have a non-transparent background (overrides utility classes like bg-transparent) */
  select{
    background-color:#ffffff !important;
    /* Keep native arrow unless explicitly removed elsewhere; ensure the control itself is opaque */
  }
  select option, select optgroup{
    background-color:#ffffff !important;
    color: inherit;
  }

  /* In dark UI mode, keep selects consistent with the existing dark form-control palette */
  html.ui-dark select{
    background-color:#0b1220 !important;
    color:#e2e8f0 !important;
    border-color:#334155 !important;
  }
  html.ui-dark select option, html.ui-dark select optgroup{
    background-color:#0b1220 !important;
    color:#e2e8f0 !important;
  }

  /* Print: keep dropdowns opaque even when print styles strip backgrounds */
  @media print{
    select{ background-color:#ffffff !important; }
    select option, select optgroup{ background-color:#ffffff !important; }
  }
</style>


<script>
  // Masquer les durées cibles dès le tout début du rendu (évite tout flash)
  document.documentElement.classList.add('hide-target-durations');
</script>


<script>
// CDN load failure detection (Fix 6)
document.addEventListener('DOMContentLoaded', function() {
    var missing = [];
    if (typeof Sortable === 'undefined') missing.push('Sortable.js');
    if (typeof XLSX === 'undefined')     missing.push('SheetJS (XLSX)');
    if (typeof docx === 'undefined')     missing.push('docx.js');
    if (missing.length > 0) {
        var banner = document.createElement('div');
        banner.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:99999;background:#dc2626;color:white;padding:12px 16px;font:14px/1.4 system-ui,sans-serif;text-align:center;';
        banner.innerHTML = '<strong>⚠ Erreur de chargement CDN :</strong> ' +
            missing.join(', ') +
            ' — Les fonctions d\u0027export et de tri pourraient ne pas fonctionner.' +
            ' <button onclick="this.parentElement.remove()" style="margin-left:12px;background:rgba(255,255,255,.2);border:1px solid rgba(255,255,255,.4);color:white;padding:2px 10px;border-radius:4px;cursor:pointer;">Fermer</button>';
        document.body.insertBefore(banner, document.body.firstChild);
    }
});
</script>
</head>
<body class="p-2 md:p-4 hide-types text-slate-900 hide-target-durations" data-view-level="activities">
<div class="ld-page">
<header class="mb-3">
<h1 class="text-2xl font-bold text-slate-900 leading-tight">
    Concepteur Pédagogique - Learning Designer
  </h1>
<div class="mt-2 flex flex-wrap gap-x-2 gap-y-2 no-print items-start content-start">
<div class="flex flex-col relative gap-0.5 bg-slate-50 border border-slate-200 rounded-lg p-0.5">
<span class="text-[9px] font-bold text-slate-500 uppercase tracking-wider pl-1" data-i18n="grp_project">
       Projet
      </span>
<div class="flex items-center bg-white border border-slate-200 rounded-md p-0.5 gap-0.5 shadow-sm h-[30px]">
<button class="text-slate-600 hover:text-indigo-600 hover:bg-indigo-50 px-1.5 py-0.5 rounded transition-colors flex items-center gap-1.5" data-i18n-title="title_save_project" data-action="save-project">
<span class="material-icons-round text-lg">
         save
        </span>
<span class="text-xs font-medium hidden md:inline" data-i18n="btn_save">
         Enregistrer
        </span>
</button>
<button class="text-slate-600 hover:text-indigo-600 hover:bg-indigo-50 px-1.5 py-0.5 rounded transition-colors flex items-center gap-1.5" data-i18n-title="title_load_project" data-action="load-project">
<span class="material-icons-round text-lg">
         file_upload
        </span>
<span class="text-xs font-medium hidden md:inline" data-i18n="btn_load">
         Charger
        </span>
</button>
<div class="w-px bg-slate-200 my-1 mx-0.5">
</div>
<div class="relative group">
<div class="flex items-center">
<span class="material-icons-round text-slate-600 absolute left-1.5 pointer-events-none text-lg z-10 group-hover:text-indigo-600 transition-colors">
          download
         </span>
<select class="appearance-none bg-transparent hover:bg-indigo-50 text-slate-600 hover:text-indigo-600 pl-7 pr-6 py-1 rounded transition-colors outline-none cursor-pointer text-xs font-medium h-[26px]" data-i18n-title="title_export_dropdown" data-action-change="handle-export" style="width: 10rem; min-width: 0;">
<option data-i18n="btn_export_dropdown" disabled="" selected="" value="">
           Exporter...
          </option>
<option data-i18n="opt_md" value="markdown">
           Markdown (conseillé pour l'IA)
          </option>
<option data-i18n="opt_csv" value="csv">
           CSV (modules/moments/activités)
          </option>
<option data-i18n="opt_real_rtf" value="rtf">
           Texte (.rtf)
          </option>
<option value="docx">
           Word (.docx)
          </option>
<option data-i18n="opt_pdf" value="pdf">
           PDF (pour imprimer)
          </option>
<option data-i18n="opt_rtf" value="richtext">
           Page Web HTML (contient les graphiques)
          </option>
</select>
<span class="material-icons-round text-slate-400 pointer-events-none absolute right-1 text-sm">
          expand_more
         </span>
</div>
</div>
<button id="open-global-search-btn"
        class="text-slate-600 hover:text-indigo-700 hover:bg-indigo-50 rounded px-2 py-1 flex items-center gap-1"
        title="Recherche globale (Ctrl+K)"
        type="button">
  <span class="material-icons-round text-[16px]">search</span>
  <span class="text-xs font-medium hidden md:inline">Recherche</span>
</button>
<input accept=".json" class="hidden" id="load-file-input" data-action-change="load-project-file" type="file"/>
</div>
</div>
<div class="flex flex-col relative gap-0.5 bg-slate-50 border border-slate-200 rounded-lg p-0.5">
<span class="text-[9px] font-bold text-slate-500 uppercase tracking-wider pl-1" data-i18n="label_more">Plus</span>
<div class="flex items-center bg-white border border-slate-200 rounded-md p-0.5 gap-0.5 shadow-sm h-[30px] min-w-max relative">
<button class="text-slate-600 hover:text-indigo-600 hover:bg-indigo-50 px-1.5 py-0.5 rounded transition-colors flex items-center gap-1.5" id="btn-more" data-action="toggle-more-menu" title="Plus d'actions" type="button">
<span class="material-icons-round text-lg">more_horiz</span>
<span class="text-xs font-medium hidden md:inline">Plus…</span>
</button>
<div class="hidden absolute right-0 top-[34px] w-72 bg-white border border-slate-200 rounded-md shadow-lg z-50 p-1" id="more-menu">
<div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider px-2 py-1" data-i18n="label_templates">Modèles</div>
<button class="w-full text-left px-2 py-1.5 rounded hover:bg-slate-50 text-slate-700 flex items-center gap-2" data-action="open-template-export-modal" type="button">
<span class="material-icons-round text-base text-slate-500">upload_file</span>
<span class="text-sm">Exporter un modèle</span>
</button>
<button class="w-full text-left px-2 py-1.5 rounded hover:bg-slate-50 text-slate-700 flex items-center gap-2" data-action="open-template-import-modal" type="button">
<span class="material-icons-round text-base text-slate-500">download_for_offline</span>
<span class="text-sm">Importer un modèle</span>
</button>
<div class="my-1 border-t border-slate-200"></div>
<div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider px-2 py-1" data-i18n="grp_interface">Interface</div>
<button class="w-full text-left px-2 py-1.5 rounded hover:bg-slate-50 text-slate-700 flex items-center gap-2" data-action="trigger-language-pack-load" type="button">
<span class="material-icons-round text-base text-slate-500">translate</span>
<span class="text-sm" data-i18n="btn_load_language_pack">Charger langue</span>
</button>
<button class="w-full text-left px-2 py-1.5 rounded hover:bg-slate-50 text-slate-700 flex items-center gap-2" data-i18n-title="title_export_language_template" data-action="export-language-pack-template" type="button">
<span class="material-icons-round text-base text-slate-500">download</span>
<span class="text-sm" data-i18n="btn_export_language_template">Exporter modèle</span>
</button>
<button class="w-full text-left px-2 py-1.5 rounded hover:bg-slate-50 text-slate-700 flex items-center gap-2" data-i18n-title="title_i18n_audit" data-action="open-i18n-audit" type="button">
<span class="material-icons-round text-base text-slate-500">fact_check</span>
<span class="text-sm" data-i18n="btn_i18n_audit">Vérifier traductions</span>
</button>
<div class="px-2 pt-2 pb-1">
<div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-1" data-i18n="title_ui_language_select">Choisir la langue de l’interface</div>
<select class="w-full appearance-none bg-white border border-slate-200 text-slate-700 px-2 pr-8 py-1 rounded-md outline-none cursor-pointer text-sm" id="ui-lang-select" data-action-change="handle-ui-language-change">
<option data-i18n="opt_lang_fr" value="fr">Français</option>
<option data-i18n="opt_lang_loaded" data-role="loaded-lang" disabled="" value="">Langue chargée</option>
</select>
</div>
<div class="my-1 border-t border-slate-200"></div>
<div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider px-2 py-1">Diagnostic</div>
<button class="w-full text-left px-2 py-1.5 rounded hover:bg-slate-50 text-slate-700 flex items-center gap-2" data-action="toggle-debug-ui" type="button">
<span class="material-icons-round text-base text-slate-500">bug_report</span>
<span class="text-sm">Diagnostic UI</span>
</button>


</div>
<input accept=".json" class="hidden" id="template-file-input" type="file"/>
<input accept=".json,application/json" class="hidden" id="lang-pack-input" data-action-change="load-language-pack" type="file"/>
</div>
</div>
<div class="flex flex-col relative gap-0.5 bg-slate-50 border border-slate-200 rounded-lg p-0.5">
<span class="text-[9px] font-bold text-slate-500 uppercase tracking-wider pl-1" data-i18n="grp_view">
       Vue
      </span>
<div class="flex items-center bg-white border border-slate-200 rounded-md p-0.5 gap-1 shadow-sm h-[30px]">
<button class="text-slate-600 hover:text-indigo-600 hover:bg-indigo-50 px-2 py-1 rounded transition-colors flex items-center justify-center ml-0.5" data-i18n-title="title_fold_all" id="btn-toggle-all-header" data-action="toggle-all-activities">
<span class="material-icons-round text-xl" id="icon-toggle-all">
         unfold_less
        </span>
</button>
<div class="w-px h-5 bg-slate-200">
</div>
<div class="relative">
<select class="appearance-none bg-white border border-slate-200 text-slate-700 pl-2 pr-7 h-[26px] rounded-md outline-none cursor-pointer text-[11px] font-extrabold tracking-wide" id="view-style-select" data-action-change="handle-view-style-change" title="Style d'affichage">
<option value="std" data-i18n="opt_chart_style_std">STD</option>
<option value="hc" data-i18n="opt_chart_style_hc">HC</option>
<option value="contrast" data-i18n="opt_chart_style_contrast">Contraste+</option>
<option value="transparent" data-i18n="opt_chart_style_transparent">Transparent</option>
</select>
<span class="material-icons-round pointer-events-none text-slate-500 text-base absolute right-1 top-1/2 -translate-y-1/2">expand_more</span>
</div>
<div class="relative">
<select class="appearance-none bg-white border border-slate-200 text-slate-700 pl-2 pr-7 h-[26px] rounded-md outline-none cursor-pointer text-[11px] font-extrabold tracking-wide" id="ui-theme-select" data-action-change="handle-ui-theme-change" title="Thème interface">
<option value="light" data-i18n="opt_chart_style_light">Clair</option>
<option value="dark" data-i18n="opt_chart_style_dark">Sombre</option>
</select>
<span class="material-icons-round pointer-events-none text-slate-500 text-base absolute right-1 top-1/2 -translate-y-1/2">expand_more</span>
</div>
<div class="w-px h-5 bg-slate-200"></div>
<button class="text-slate-600 hover:text-indigo-600 hover:bg-indigo-50 px-1 py-0.5 rounded transition-colors flex items-center gap-0.5 justify-center" data-i18n-title="title_toggle_types" data-action="toggle-learning-types" type="button">
<span class="material-icons-round text-sm" id="icon-toggle-types">visibility_off</span>
<span class="text-[10px] font-bold" data-i18n="btn_toggle_types">Types</span>
</button>
</div>
</div>
<div class="flex flex-col relative gap-0.5 bg-slate-50 border border-slate-200 rounded-lg p-0.5">
<span class="text-[9px] font-bold text-slate-500 uppercase tracking-wider pl-1" data-i18n="label_designed_time">
       Temps Conçu (Planifié)
      </span>
<div class="flex items-center bg-white border border-slate-200 rounded-md px-2 gap-1 shadow-sm h-[30px]">
<span class="material-icons-round text-slate-600 text-lg">
         schedule
        </span>
<span class="text-xs font-extrabold text-slate-800 tabular-nums" id="header-designed-val">
         0
        </span>
<span class="text-xs font-bold text-slate-600" id="header-designed-unit">
         min
        </span>
</div>
</div>
</div>
</header>
<div class="mb-3 no-print w-full" id="top-tabs-bar-wrap">
  <div class="bg-white rounded-lg shadow-sm border border-slate-200 p-1 flex gap-1" role="tablist" aria-label="Sections">
    <button type="button" id="top-tab-btn-info" role="tab" aria-selected="false" aria-controls="key-params-wrapper" class="top-tab-btn">
      <span class="material-icons-round text-sm">tune</span>
      <span class="top-tab-label" data-i18n="tab_info">INFORMATIONS ET PARAMÈTRES DE LA FORMATION</span>
    </button>
    <button type="button" id="top-tab-btn-visual" role="tab" aria-selected="false" aria-controls="visualisations-wrapper" class="top-tab-btn">
      <span class="material-icons-round text-sm">insights</span>
      <span class="top-tab-label" data-i18n="tab_visual">VISUALISATIONS DES SÉQUENCES</span>
    </button>
    <button type="button" id="top-tab-btn-analysis" role="tab" aria-selected="false" aria-controls="analysis-tabs-wrap" class="top-tab-btn">
      <span class="material-icons-round text-sm">bar_chart</span>
      <span class="top-tab-label" data-i18n="tab_analysis">GRAPHIQUES D'ANALYSE</span>
    </button>
  </div>
</div>

<div id="key-params-wrapper" role="tabpanel" aria-labelledby="top-tab-btn-info" class="mb-3 bg-white rounded-lg shadow-sm border border-slate-200 overflow-hidden">
<button class="w-full px-3 py-2 flex items-center justify-between bg-slate-50 hover:bg-slate-100 transition-colors no-print h-[32px] rounded-lg border border-slate-200 rounded-lg border border-slate-200" data-i18n-title="title_toggle_panel" data-action="toggle-panel" data-panel="key-params-panel">
<div class="flex items-center gap-1.5">
<span class="material-icons-round text-slate-500 text-sm">
       tune
      </span>
<span class="font-bold text-slate-700 uppercase text-xs tracking-wide" data-i18n="panel_key_parameters">
       Informations et paramètres de la formation
      </span>
</div>
<span class="material-icons-round text-slate-400 rotate-icon text-sm" id="key-params-panel-icon">
      expand_more
     </span>
</button><div class="panel-content" id="key-params-panel" style="display: none;">
<!-- Key parameters wizard (Option 6) -->
<div class="px-3 py-2 border-t border-slate-100 bg-white flex items-center justify-between gap-2 flex-wrap" id="kpwiz-bar">
<div class="flex items-center gap-2">
<span class="text-[10px] font-extrabold text-slate-500 uppercase tracking-wider" data-i18n="label_path">Parcours</span>
<div class="flex items-center gap-1 flex-wrap" id="kpwiz-steps">
<button class="kpwiz-step-btn px-2 h-[26px] rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 text-[10px] font-bold" data-kpwiz-step="1" type="button" data-i18n="btn_wizard_identity">1. Identité</button>
<button class="kpwiz-step-btn px-2 h-[26px] rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 text-[10px] font-bold" data-kpwiz-step="2" type="button" data-i18n="btn_wizard_audience">2. Public</button>
<button class="kpwiz-step-btn px-2 h-[26px] rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 text-[10px] font-bold" data-kpwiz-step="3" type="button" data-i18n="btn_wizard_objectives">3. Objectifs et résultats</button>
<button class="kpwiz-step-btn px-2 h-[26px] rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 text-[10px] font-bold" data-kpwiz-step="4" type="button" data-i18n="btn_wizard_competences">4. Compétences</button>
<button class="kpwiz-step-btn px-2 h-[26px] rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 text-[10px] font-bold" data-kpwiz-step="5" type="button" data-i18n="btn_wizard_tools">5. Outils et matériel</button>
</div>
</div>
<div class="flex items-center gap-1">
<button class="px-2 h-[26px] rounded-md border border-slate-200 bg-white hover:bg-slate-50 text-[10px] font-extrabold" data-kpwiz-action="prev" type="button" data-i18n="btn_wizard_prev">Précédent</button>
<button class="px-2 h-[26px] rounded-md border border-slate-200 bg-white hover:bg-slate-50 text-[10px] font-extrabold" data-kpwiz-action="next" type="button" data-i18n="btn_wizard_next">Suivant</button>
<button class="px-2 h-[26px] rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 text-[10px] font-extrabold" data-kpwiz-action="showall" type="button" data-i18n="btn_wizard_showall">Tout afficher</button>
</div>
</div>
<div id="kpwiz-steps-wrapper">
<section class="kpwiz-step" id="kpwiz-step-1">
<div class="p-3 border-t border-slate-100 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
<div>
<label class="compact-label block" data-i18n="label_course_name">
        Nom de la formation
       </label>
<input class="w-full px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none" data-i18n-placeholder="ph_course_name" id="param-name" placeholder="Entrez le nom de la formation..." type="text"/>
</div><div class="flex-1">
<label class="compact-label block" data-i18n="label_learning_time">
         Temps d'Apprentissage (Cible)
        </label>
<div class="flex gap-1">
<input class="w-2/3 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none" id="param-learning-val" min="0" data-action-input="update-stats-debounced" placeholder="0" type="number"/>
<select class="w-1/3 px-1 py-1 text-xs border border-slate-200 rounded bg-slate-50 focus:ring-1 focus:ring-indigo-500 outline-none" id="param-learning-unit" data-action-change="update-stats">
<option data-i18n="unit_mins" value="mins">
           min
          </option>
<option data-i18n="unit_hours" value="hours">
           Heures
          </option>
<option data-i18n="unit_days" value="days">
           Jours
          </option>
<option data-i18n="unit_weeks" value="weeks">
           Semaines
          </option>
<option data-i18n="unit_months" value="months">
           Mois
          </option>
</select>
</div>
</div>

<div class="flex-1">
  <label class="compact-label block">Unité préférée (Modules / Moments / Activités)</label>
  <select class="w-full px-2 py-1 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none" id="param-preferred-unit">
    <option value="60" data-i18n="unit_mins">min</option>
    <option value="3600" data-i18n="unit_hours">Heures</option>
    <option value="86400" data-i18n="unit_days">Jours</option>
    <option value="604800" data-i18n="unit_weeks">Semaines</option>
    <option value="2592000" data-i18n="unit_months">Mois</option>
  </select>
  <p class="text-[11px] text-slate-400 mt-1">Défaut pour l’unité affichée et saisie dans les blocs. Vous pouvez modifier une unité localement si nécessaire.</p>
</div>


<div class="flex-1">
<label class="compact-label block" data-i18n="label_designed_time">
         Temps Conçu (Planifié)
        </label>
<div class="flex gap-1 items-center">
<input class="w-2/3 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none bg-slate-100 text-slate-500" id="param-designed-val" min="0" placeholder="0" readonly="" type="number"/>
<span class="w-1/3 text-xs text-slate-600 font-bold px-1" id="param-designed-unit-display">
          min
         </span>
<input id="param-designed-time" type="number" class="hidden" aria-hidden="true" tabindex="-1"/>
<select id="param-designed-unit" class="hidden" aria-hidden="true" tabindex="-1">
  <option data-i18n="unit_mins" value="mins">min</option>
  <option data-i18n="unit_hours" value="hours">heures</option>
  <option data-i18n="unit_days" value="days">jours</option>
  <option data-i18n="unit_weeks" value="weeks">semaines</option>
  <option data-i18n="unit_months" value="months">mois</option>
</select>
</div>
</div>
</div>
<div class="p-3 border-t border-slate-100 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3"><div>
<label class="compact-label block" data-i18n="label_topic">
       Thème
      </label>
<input class="w-full px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none" data-i18n-placeholder="ph_topic" id="param-topic" placeholder="Entrez le thème..." type="text"/>
</div><div>
<label class="compact-label block" data-i18n="label_mode">
       Modalité
      </label>
<select class="w-full px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none bg-white" id="param-mode">
<option data-i18n="opt_mode_placeholder" disabled="" selected="" value="">
        Sélectionnez une modalité...
       </option>
<option data-i18n="opt_mode_classroom" value="classroom">
        Présentiel (sur site)
       </option>
<option data-i18n="opt_mode_online" value="online">
        Distanciel (en ligne)
       </option>
<option data-i18n="opt_mode_blended" value="blended">
        Hybride (sur site et en ligne)
       </option>
</select>
</div><div>
<label class="compact-label block" data-i18n="label_authors">
        Concepteurs(s)
       </label>
<input class="w-full px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none" data-i18n-placeholder="ph_authors" id="param-authors" placeholder="Entrez le nom du/des concepteurs..." type="text"/>
</div>
<div>
<label class="compact-label block" data-i18n="label_trainers">
        Formateur(s)
       </label>
<input class="w-full px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none" data-i18n-placeholder="ph_trainers" id="param-trainers" placeholder="Entrez le nom du/des formateur(s)..." type="text"/>
</div>
<div class="md:col-span-2 lg:col-span-3">
<label class="compact-label block" data-i18n="label_description">
        Description générale
       </label>
<textarea class="w-full px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y" data-i18n-placeholder="ph_description" id="param-description" placeholder="Description détaillée..." rows="1"></textarea>
</div>
</div>
</section>
<section class="kpwiz-step hidden" id="kpwiz-step-2">
<div class="p-3 border-t border-slate-100 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
<div class="md:col-span-2 lg:col-span-3">
<label class="compact-label block" data-i18n="label_target_audience">Public cible</label>
<textarea class="w-full px-2 py-1 border border-slate-200 rounded text-sm focus:ring-1 focus:ring-indigo-500 outline-none resize-y" id="param-target-audience" placeholder="" rows="1"></textarea>
</div>
<div>
<label class="compact-label block" data-i18n="label_level">Niveau</label>
<select class="w-full px-2 py-1 border border-slate-200 rounded text-sm focus:ring-1 focus:ring-indigo-500 outline-none bg-white" id="param-level">
<option data-i18n="opt_level_unspecified" selected="" value="unspecified">Non spécifié</option>
<option data-i18n="opt_level_mixed" value="mixed">Mixte</option>
<option data-i18n="opt_level_beginner" value="beginner">Débutant</option>
<option data-i18n="opt_level_intermediate" value="intermediate">Intermédiaire</option>
<option data-i18n="opt_level_advanced" value="advanced">Avancé</option>
<option data-i18n="opt_level_expert" value="expert">Expert</option>
</select>
</div>
<div>
<label class="compact-label block" data-i18n="label_class_size">
       Taille de la cohorte
      </label>
<input class="w-full px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none font-bold text-slate-800" id="global-class-size" min="1" data-action-input="update-stats-debounced" type="number" value="30"/>
</div>
<div class="md:col-span-2 lg:col-span-3">
<label class="compact-label block" data-i18n="label_prerequisites">Prérequis</label>
<textarea class="w-full px-2 py-1 border border-slate-200 rounded text-sm focus:ring-1 focus:ring-indigo-500 outline-none resize-y" id="param-prerequisites" placeholder="" rows="1"></textarea>
</div>
</div>
</section>
<section class="kpwiz-step hidden" id="kpwiz-step-3">
<div class="p-3 border-t border-slate-100 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
<div class="md:col-span-2 lg:col-span-3">
<details open class="group border border-slate-200 rounded-lg bg-white/0">
<summary class="px-3 py-2 cursor-pointer select-none flex items-center justify-between">
<span class="compact-label" data-i18n="label_aims">Objectifs d'apprentissage (ce qu'on va enseigner)</span>
<span class="material-icons-round text-slate-400 text-sm transition-transform group-open:rotate-180">expand_more</span>
</summary>
<div class="px-3 pb-3">
<!-- Objectifs (saisie unitaire) -->
<textarea class="hidden" data-i18n-placeholder="ph_aims" id="param-aims" placeholder="Entrez les objectifs..." rows="2"></textarea>
<div class="bg-slate-50 border border-slate-200 rounded-lg p-2">
<div class="hidden mb-2 p-2 rounded-md bg-indigo-50 border border-indigo-200 text-[11px] flex items-center justify-between gap-2" id="aims-origin-bar">
<div class="text-slate-700 min-w-0">
<span class="font-bold">Ajout depuis :</span>
<span class="text-slate-600" id="aims-origin-label"></span>
</div>
<button class="text-[10px] font-bold text-indigo-700 bg-white border border-indigo-200 px-2 py-1 rounded hover:bg-indigo-100 transition-colors" data-action="back-to-aims-origin" data-i18n="btn_back_to_activity">Retour à l'activité</button>
</div>
<div class="flex items-center gap-2 mb-2 flex-wrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-aims-csv" title="Charger une liste d'objectifs (CSV/TSV/TXT)" type="button">
<span class="material-icons-round text-sm">upload_file</span>
            Charger fichier (CSV/TSV/TXT)
          </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-aims-template" title="Télécharger un modèle CSV" type="button">
<span class="material-icons-round text-sm">download</span>
            Modèle CSV
          </button>
<span class="text-[10px] text-slate-400 italic" id="aims-csv-status"></span>
</div>
<input accept=".csv,.tsv,.txt" class="hidden" id="aims-csv-file-input" type="file"/>
<!-- Taxonomie des objectifs (catégories / sous-catégories) -->
<div class="flex items-center gap-2 mb-2 flex-wrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-aims-taxonomy" title="Charger une taxonomie d'objectifs (CSV)" type="button">
<span class="material-icons-round text-sm">schema</span>
            Charger taxonomie (CSV)
          </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-aims-taxonomy-template" title="Télécharger le modèle CSV de taxonomie" type="button">
<span class="material-icons-round text-sm">download</span>
            Modèle taxonomie
          </button>
<button class="text-[10px] bg-red-50 text-red-600 px-2 py-1 rounded hover:bg-red-100 transition-colors flex items-center gap-1" id="btn-reset-aims-taxonomy" title="Réinitialiser la taxonomie d'objectifs" type="button">
<span class="material-icons-round text-sm">restart_alt</span>
            Réinitialiser
          </button>
<span class="text-[10px] text-slate-400 italic" id="aims-taxonomy-status"></span>
</div>
<input accept=".csv" class="hidden" id="aims-taxonomy-file-input" type="file"/>
<div class="grid grid-cols-1 sm:grid-cols-12 gap-1">
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-2" id="new-aim-cat-input" list="aims-cat-datalist" placeholder="Catégorie (optionnel)..." type="text"/>
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-2" id="new-aim-subcat-input" list="aims-subcat-datalist" placeholder="Sous-catégorie (optionnel)..." type="text"/>
<datalist id="aims-cat-datalist"></datalist>
<datalist id="aims-subcat-datalist"></datalist>
<div class="flex gap-1 flex-col sm:flex-row sm:items-center sm:col-span-8">
<input class="flex-1 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs" id="new-aim-item-input" placeholder="Ajouter un objectif..." type="text"/>
<button class="bg-indigo-100 text-indigo-700 px-2 py-1 rounded font-bold hover:bg-indigo-200 transition-colors flex items-center justify-center h-[26px]" data-action="add-aim-item" title="Ajouter un objectif" type="button">
<span class="material-icons-round text-sm">add</span>
</button>
</div>
</div>
<ul class="space-y-0.5 mt-2" id="aims-list"></ul>
<p class="text-xs text-slate-400 italic mt-1" id="no-aims-text">Aucun objectif défini</p>
</div>
</div>
</details>
</div>
<div class="md:col-span-2 lg:col-span-3">
<details open class="group border border-slate-200 rounded-lg bg-white/0">
<summary class="px-3 py-2 cursor-pointer select-none flex items-center justify-between">
<span class="compact-label" data-i18n="label_outcomes_text">Résultats d'apprentissage (ce que les apprenants sauront faire)</span>
<span class="material-icons-round text-slate-400 text-sm transition-transform group-open:rotate-180">expand_more</span>
</summary>
<div class="px-3 pb-3">
<!-- Résultats d'apprentissage (texte) -->
<textarea class="hidden" id="param-outcomes-text" placeholder="Entrez les résultats d'apprentissage..." rows="2"></textarea>
<div class="bg-slate-50 border border-slate-200 rounded-lg p-2">
<div class="flex items-center gap-2 mb-2 flex-wrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-outcomes-text-csv" title="Charger une liste de résultats (CSV/TSV/TXT)" type="button">
<span class="material-icons-round text-sm">upload_file</span>
            Charger fichier (CSV/TSV/TXT)
          </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-outcomes-text-template" title="Télécharger un modèle CSV" type="button">
<span class="material-icons-round text-sm">download</span>
            Modèle CSV
          </button>
<span class="text-[10px] text-slate-400 italic" id="outcomes-text-csv-status"></span>
</div>
<input accept=".csv,.tsv,.txt" class="hidden" id="outcomes-text-csv-file-input" type="file"/>
<!-- Taxonomie des résultats (catégories / sous-catégories) -->
<div class="flex items-center gap-2 mb-2 flex-wrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-outcomes-text-taxonomy" title="Charger une taxonomie de résultats (CSV)" type="button">
<span class="material-icons-round text-sm">schema</span>
            Charger taxonomie (CSV)
          </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-outcomes-text-taxonomy-template" title="Télécharger le modèle CSV de taxonomie" type="button">
<span class="material-icons-round text-sm">download</span>
            Modèle taxonomie
          </button>
<button class="text-[10px] bg-red-50 text-red-600 px-2 py-1 rounded hover:bg-red-100 transition-colors flex items-center gap-1" id="btn-reset-outcomes-text-taxonomy" title="Réinitialiser la taxonomie de résultats" type="button">
<span class="material-icons-round text-sm">restart_alt</span>
            Réinitialiser
          </button>
<span class="text-[10px] text-slate-400 italic" id="outcomes-text-taxonomy-status"></span>
</div>
<input accept=".csv" class="hidden" id="outcomes-text-taxonomy-file-input" type="file"/>
<div class="grid grid-cols-1 sm:grid-cols-12 gap-1">
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-2" id="new-outcomes-text-cat-input" list="outcomes-text-cat-datalist" placeholder="Catégorie (optionnel)..." type="text"/>
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-2" id="new-outcomes-text-subcat-input" list="outcomes-text-subcat-datalist" placeholder="Sous-catégorie (optionnel)..." type="text"/>
<datalist id="outcomes-text-cat-datalist"></datalist>
<datalist id="outcomes-text-subcat-datalist"></datalist>
<div class="flex gap-1 flex-col sm:flex-row sm:items-center sm:col-span-8">
<input class="flex-1 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs" id="new-outcomes-text-item-input" placeholder="Ajouter un résultat (texte)..." type="text"/>
<button class="bg-indigo-100 text-indigo-700 px-2 py-1 rounded font-bold hover:bg-indigo-200 transition-colors flex items-center justify-center h-[26px]" data-action="add-outcomes-text-item" title="Ajouter un résultat (texte)" type="button">
<span class="material-icons-round text-sm">add</span>
</button>
</div>
</div>
<ul class="space-y-0.5 mt-2" id="outcomes-text-list"></ul>
<p class="text-xs text-slate-400 italic mt-1" id="no-outcomes-text-text">Aucun résultat (texte) défini</p>
</div>
</div>
</details>
</div>
</div></section>
<section class="kpwiz-step hidden" id="kpwiz-step-4">
<div class="p-3 border-t border-slate-100 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
<div class="md:col-span-2 lg:col-span-3">
<details open class="group border border-slate-200 rounded-lg bg-white/0">
<summary class="px-3 py-2 cursor-pointer select-none flex items-center justify-between">
<span>Compétences du sujet</span>
<span class="material-icons-round text-slate-400 text-sm transition-transform group-open:rotate-180">expand_more</span>
</summary>
<div class="mt-1">
<div class="bg-slate-50 border border-slate-200 rounded-lg p-2">
<div class="flex items-center gap-2 mb-2 toolbar-nowrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-competences-csv" title="Charger une liste de compétences du sujet (CSV/TSV/TXT)" type="button">
<span class="material-icons-round text-sm">upload_file</span>
      Charger fichier (CSV/TSV/TXT)
    </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-competences-template" title="Télécharger un modèle CSV" type="button">
<span class="material-icons-round text-sm">download</span>
      Modèle CSV
    </button>
<span class="text-[10px] text-slate-400 italic" id="competences-csv-status"></span>
</div>
<input accept=".csv,.tsv,.txt" class="hidden" id="competences-csv-file-input" type="file"/>
<div class="flex items-center gap-2 mb-2 toolbar-nowrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-competences-taxonomy" title="Charger une taxonomie de compétences du sujet (CSV)" type="button">
<span class="material-icons-round text-sm">schema</span>
      Charger taxonomie (CSV)
    </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-competences-taxonomy-template" title="Télécharger le modèle CSV de taxonomie" type="button">
<span class="material-icons-round text-sm">download</span>
      Modèle taxonomie
    </button>
<button class="text-[10px] bg-red-50 text-red-600 px-2 py-1 rounded hover:bg-red-100 transition-colors flex items-center gap-1" id="btn-reset-competences-taxonomy" title="Réinitialiser la taxonomie de compétences du sujet" type="button">
<span class="material-icons-round text-sm">restart_alt</span>
      Réinitialiser
    </button>
<span class="text-[10px] text-slate-400 italic" id="competences-taxonomy-status"></span>
</div>
<input accept=".csv" class="hidden" id="competences-taxonomy-file-input" type="file"/>
<div class="grid grid-cols-1 sm:grid-cols-12 gap-1">
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-2" id="new-competence-cat-input" list="competences-cat-datalist" placeholder="Catégorie (optionnel)..." type="text"/>
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-2" id="new-competence-subcat-input" list="competences-subcat-datalist" placeholder="Sous-catégorie (optionnel)..." type="text"/>
<datalist id="competences-cat-datalist"></datalist>
<datalist id="competences-subcat-datalist"></datalist>
<div class="flex gap-1 flex-col sm:flex-row sm:items-center sm:col-span-8">
<input class="flex-1 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs" id="new-competence-input" placeholder="Ajouter une compétence du sujet..." type="text"/>
<button class="bg-indigo-100 text-indigo-700 px-2 py-1 rounded font-bold hover:bg-indigo-200 transition-colors flex items-center justify-center h-[26px]" data-action="add-competence" title="Ajouter une compétence du sujet" type="button">
<span class="material-icons-round text-sm">add</span>
</button>
</div>
</div>
<ul class="space-y-0.5 mt-2" id="competences-list"></ul>
<p class="text-xs text-slate-400 italic mt-1" id="no-competences-text">Aucune compétence définie</p>
</div>
</div>
</details>
<details open class="group border border-slate-200 rounded-lg bg-white/0 mt-3">
<summary class="px-3 py-2 cursor-pointer select-none flex items-center justify-between">
<span>Compétences transversales</span>
<span class="material-icons-round text-slate-400 text-sm transition-transform group-open:rotate-180">expand_more</span>
</summary>
<div class="mt-1">
<div class="bg-slate-50 border border-slate-200 rounded-lg p-2">
<div class="flex items-center gap-2 mb-2 toolbar-nowrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-competences-trans-csv" title="Charger une liste de compétences transversales (CSV/TSV/TXT)" type="button">
<span class="material-icons-round text-sm">upload_file</span>
      Charger fichier (CSV/TSV/TXT)
    </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-competences-trans-template" title="Télécharger un modèle CSV" type="button">
<span class="material-icons-round text-sm">download</span>
      Modèle CSV
    </button>
<span class="text-[10px] text-slate-400 italic" id="competences-trans-csv-status"></span>
</div>
<input accept=".csv,.tsv,.txt" class="hidden" id="competences-trans-csv-file-input" type="file"/>
<div class="flex items-center gap-2 mb-2 toolbar-nowrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-competences-trans-taxonomy" title="Charger une taxonomie de compétences transversales (CSV)" type="button">
<span class="material-icons-round text-sm">schema</span>
      Charger taxonomie (CSV)
    </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-competences-trans-taxonomy-template" title="Télécharger le modèle CSV de taxonomie" type="button">
<span class="material-icons-round text-sm">download</span>
      Modèle taxonomie
    </button>
<button class="text-[10px] bg-red-50 text-red-600 px-2 py-1 rounded hover:bg-red-100 transition-colors flex items-center gap-1" id="btn-reset-competences-trans-taxonomy" title="Réinitialiser la taxonomie de compétences transversales" type="button">
<span class="material-icons-round text-sm">restart_alt</span>
      Réinitialiser
    </button>
<span class="text-[10px] text-slate-400 italic" id="competences-trans-taxonomy-status"></span>
</div>
<input accept=".csv" class="hidden" id="competences-trans-taxonomy-file-input" type="file"/>
<div class="grid grid-cols-1 sm:grid-cols-12 gap-1">
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-2" id="new-competence-trans-cat-input" list="competences-trans-cat-datalist" placeholder="Catégorie (optionnel)..." type="text"/>
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-2" id="new-competence-trans-subcat-input" list="competences-trans-subcat-datalist" placeholder="Sous-catégorie (optionnel)..." type="text"/>
<datalist id="competences-trans-cat-datalist"></datalist>
<datalist id="competences-trans-subcat-datalist"></datalist>
<div class="flex gap-1 flex-col sm:flex-row sm:items-center sm:col-span-8">
<input class="flex-1 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs" id="new-competence-transversal-input" placeholder="Ajouter une compétence transversale..." type="text"/>
<button class="bg-indigo-100 text-indigo-700 px-2 py-1 rounded font-bold hover:bg-indigo-200 transition-colors flex items-center justify-center h-[26px]" data-action="add-competence-transversal" title="Ajouter une compétence transversale" type="button">
<span class="material-icons-round text-sm">add</span>
</button>
</div>
</div>
<ul class="space-y-0.5 mt-2" id="competences-transversales-list"></ul>
<p class="text-xs text-slate-400 italic mt-1" id="no-competences-transversales-text">Aucune compétence définie</p>
</div>
</div>
</details>
</div>
</div>
</section>
<section class="kpwiz-step hidden" id="kpwiz-step-5">
<div class="p-3 border-t border-slate-100 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
<div class="md:col-span-2 lg:col-span-3">
<details open class="group border border-slate-200 rounded-lg bg-white/0">
<summary class="px-3 py-2 cursor-pointer select-none flex items-center justify-between">
<span class="compact-label" data-i18n="label_tools_materials">Outils et matériel</span>
<span class="material-icons-round text-slate-400 text-sm transition-transform group-open:rotate-180">expand_more</span>
</summary>
<div class="px-3 pb-3">
<textarea class="hidden" id="param-tools-materials" placeholder="Entrez les outils et matériels..." rows="2"></textarea>
<div class="bg-slate-50 border border-slate-200 rounded-lg p-2">
<div class="flex items-center gap-2 mb-2 flex-wrap no-print">
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-load-tools-materials-csv" title="Charger une liste d'outils et matériel (CSV/TSV/TXT)" type="button">
<span class="material-icons-round text-sm">upload_file</span>
            Charger fichier (CSV/TSV/TXT)
          </button>
<button class="text-[10px] bg-slate-100 text-slate-600 px-2 py-1 rounded hover:bg-slate-200 transition-colors flex items-center gap-1" id="btn-download-tools-materials-template" title="Télécharger un modèle CSV" type="button">
<span class="material-icons-round text-sm">download</span>
            Modèle CSV
          </button>
<span class="text-[10px] text-slate-400 italic" id="tools-materials-csv-status"></span>
</div>
<input accept=".csv,.tsv,.txt" class="hidden" id="tools-materials-csv-file-input" type="file"/>

<div class="grid grid-cols-1 sm:grid-cols-12 gap-1">
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-1" id="new-tools-materials-cat-input" list="tools-materials-cat-datalist" placeholder="Catégorie (optionnel)..." type="text"/>
<input class="px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs sm:col-span-1" id="new-tools-materials-subcat-input" list="tools-materials-subcat-datalist" placeholder="Sous-catégorie (optionnel)..." type="text"/>
<datalist id="tools-materials-cat-datalist"></datalist>
<datalist id="tools-materials-subcat-datalist"></datalist>
<div class="flex gap-1 flex-col sm:flex-row sm:items-center sm:col-span-10">
<input class="flex-1 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs" id="new-tools-materials-item-input" placeholder="Ajouter un outil ou matériel..." type="text"/>
<button class="bg-indigo-100 text-indigo-700 px-2 py-1 rounded font-bold hover:bg-indigo-200 transition-colors flex items-center justify-center h-[26px]" data-action="add-tools-materials-item" title="Ajouter un outil ou matériel" type="button">
<span class="material-icons-round text-sm">add</span>
</button>
</div>
</div>

<div class="mt-2 p-2 bg-slate-50 border border-slate-200 rounded-lg">
  <div class="flex flex-col sm:flex-row gap-2 items-end">
    <div class="flex-1 min-w-0">
      <label class="compact-label">Rechercher</label>
      <input id="tools-materials-search" class="w-full px-2 py-1 border border-slate-200 rounded focus:ring-2 focus:ring-indigo-500 outline-none text-sm" type="text" placeholder="Rechercher un outil, une catégorie ou une sous-catégorie..." />
    </div>
    <div class="sm:w-48">
      <label class="compact-label">Catégorie</label>
      <select id="tools-materials-filter-cat" class="w-full px-2 py-1 border border-slate-200 rounded bg-white focus:ring-2 focus:ring-indigo-500 outline-none text-sm">
        <option value="" data-i18n="opt_all_categories">Toutes</option>
      </select>
    </div>
    <div class="sm:w-56">
      <label class="compact-label">Sous-catégorie</label>
      <select id="tools-materials-filter-subcat" class="w-full px-2 py-1 border border-slate-200 rounded bg-white focus:ring-2 focus:ring-indigo-500 outline-none text-sm">
        <option value="" data-i18n="opt_all_categories">Toutes</option>
      </select>
    </div>
    <button id="tools-materials-filter-reset" type="button" class="px-2 py-1 rounded bg-white border border-slate-200 text-slate-600 hover:text-slate-800 hover:border-slate-300">
      Réinitialiser
    </button>
  </div>
  <div class="mt-1 flex items-center justify-between text-[11px] text-slate-400">
    <span id="tools-materials-filter-count">0/0 affichés</span>
    <span id="tools-materials-filter-empty" class="hidden italic">Aucun résultat</span>
  </div>
</div>

<ul class="space-y-0.5 mt-2" id="tools-materials-list"></ul>
<p class="text-xs text-slate-400 italic mt-1" id="no-tools-materials-text">Aucun outil / matériel défini</p>
</div>
<p class="text-[11px] text-slate-500 mt-2">
Vous pouvez importer une liste (CSV/TSV/TXT) ou ajouter des éléments manuellement. Exemple : <span class="font-semibold">Moodle — Forum</span>. Vous pouvez aussi réorganiser les éléments par glisser-déposer.
</p>
</div>
</details>
<details class="group border border-slate-200 rounded-lg bg-white/0 mt-2">
<summary class="px-3 py-2 cursor-pointer select-none flex items-center justify-between">
<span class="compact-label" data-i18n="label_notes">Notes</span>
<span class="material-icons-round text-slate-400 text-sm transition-transform group-open:rotate-180">expand_more</span>
</summary>
<div class="px-3 pb-3">
<textarea id="param-tools-materials-notes" class="w-full px-2 py-1.5 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y bg-slate-50 text-slate-700" data-i18n-placeholder="ph_notes" placeholder="Notes formateur, ressources ou liens..." rows="3"></textarea>
</div>
</details>
</div>
</div>

</section>
</div><!-- /kpwiz-steps-wrapper -->
</div>
</div>
<div id="visualisations-wrapper" role="tabpanel" aria-labelledby="top-tab-btn-visual" class="mb-3 no-print flex flex-col gap-3 ld-page">
<div class="bg-white rounded-lg shadow-sm border border-slate-200 overflow-hidden flex-1 flex flex-col justify-center ld-page" id="timelines-wrapper">
<button class="w-full px-3 py-2 flex items-center justify-between bg-slate-50 hover:bg-slate-100 transition-colors no-print h-[32px] rounded-lg border border-slate-200" data-i18n-title="title_toggle_panel" data-action="toggle-panel" data-panel="timeline-panel">
<div class="flex items-center gap-1.5">
<span class="material-icons-round text-slate-500 text-sm">
        insights
       </span>
<span class="font-bold text-slate-700 uppercase text-xs tracking-wide" data-i18n="panel_timelines_title">
        Visualisations des séquences
       </span>
</div>
<span class="material-icons-round text-slate-400 rotate-icon text-sm" id="timeline-panel-icon">
       expand_more
      </span>
</button>
<div class="panel-content w-full flex flex-col gap-2 mt-2 p-2 rounded-xl border border-slate-200 bg-slate-50" id="timeline-panel" style="display: none;">
<div class="flex justify-end">
<span class="text-slate-400 text-[10px] italic" data-i18n="status_calculating" id="stats-update-info"></span>
</div>
<div class="bg-transparent rounded-xl border border-transparent p-1 flex items-center justify-start gap-2 flex-wrap" id="timeline-scale-controls">
<div class="flex items-center gap-1">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-sm">zoom_in</span>
<span class="text-[11px] font-bold text-slate-500 uppercase tracking-wider">Échelle temporelle</span>
</div>
<div class="flex items-center gap-1">
<button class="px-1.5 py-0.5 rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 transition-colors flex items-center justify-center" id="timeline-zoom-out" title="Zoom arrière" type="button">
<span class="material-icons-round text-slate-600 text-sm">remove</span>
</button>
<input class="w-32 md:w-44" id="timeline-zoom-range" max="3" min="0.5" step="0.1" type="range" value="1"/>
<span class="text-[11px] font-bold text-slate-600 w-10 text-right tabular-nums" id="timeline-zoom-value">100%</span>
<button class="px-1.5 py-0.5 rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 transition-colors flex items-center justify-center" id="timeline-zoom-in" title="Zoom avant" type="button">
<span class="material-icons-round text-slate-600 text-sm">add</span>
</button>
<button class="px-1.5 py-0.5 rounded-md border border-slate-200 bg-slate-50 hover:bg-slate-100 transition-colors flex items-center justify-center" id="timeline-zoom-reset" title="Réinitialiser" type="button">
<span class="material-icons-round text-slate-600 text-sm">restart_alt</span>
</button>
</div>
<div class="flex items-center gap-2 ml-auto">
  <span class="text-[11px] font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_duration_tolerance">Tolérance (écart acceptable)</span>
  <div class="flex items-center gap-1">
    <input class="w-12 px-2 py-0.5 text-[11px] border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-right" id="param-duration-tol-rel" min="0" step="0.5" data-action-input="update-stats-debounced" placeholder="%" type="number" value="5" aria-label="Tolérance relative en pourcentage"/>
    <span class="text-[10px] text-slate-400" data-i18n="hint_duration_tolerance_pct">%</span>
  </div>
</div>
</div>
<div class="timeline-track timeline-track-planned bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1">
<div class="flex items-center justify-between gap-2 flex-wrap">
<div class="flex items-center gap-1.5">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-base">
          view_agenda
         </span>
<span class="text-xs font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_timeline_structure_planned">
          Modules prévus
         </span>
</div>
</div>
<div class="w-full h-6 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-activities-planned">
<div class="timeline-inner" id="timeline-activities-planned-inner"></div>
</div>
<div class="w-full flex text-xs text-slate-600 font-medium leading-none mt-1 timeline-zoom-outer" id="timeline-activities-planned-labels">
<div class="timeline-inner" id="timeline-activities-planned-labels-inner"></div>
</div>
</div>
<div class="timeline-track bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1">
<div class="flex items-center justify-between gap-2 flex-wrap">
<div class="flex items-center gap-1.5">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-base">
          account_tree
         </span>
<span class="text-xs font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_timeline_structure">
          Modules conçus
         </span>
</div>
</div>
<div class="w-full h-6 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-activities">
<div class="timeline-inner" id="timeline-activities-inner"></div>
</div>
<div class="w-full flex text-xs text-slate-600 font-medium leading-none mt-1 timeline-zoom-outer" id="timeline-activities-labels">
<div class="timeline-inner" id="timeline-activities-labels-inner"></div>
</div>
</div>

<div class="timeline-track bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1">
  <div class="flex items-center justify-between px-1">
    <div class="flex items-center gap-1.5">
      <span class="material-icons-round text-base text-slate-400">view_week</span>
      <span class="text-xs font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_timeline_moments">Moments</span>
    </div>
  </div>
  <div class="w-full h-6 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-moments">
    <div class="timeline-inner" id="timeline-moments-inner"></div>
  </div>
  <div class="w-full flex text-xs text-slate-600 font-medium leading-none mt-1 timeline-zoom-outer" id="timeline-moments-labels">
    <div class="timeline-inner" id="timeline-moments-labels-inner"></div>
  </div>
</div>

<div class="timeline-track bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1">
  <div class="flex items-center justify-between px-1">
    <div class="flex items-center gap-1.5">
      <span class="material-icons-round text-base text-slate-400">view_list</span>
      <span class="text-xs font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_timeline_submoments">Sous-moments</span>
    </div>
  </div>
  <div class="w-full h-6 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-submoments">
    <div class="timeline-inner" id="timeline-submoments-inner"></div>
  </div>
  <div class="w-full flex text-xs text-slate-600 font-medium leading-none mt-1 timeline-zoom-outer" id="timeline-submoments-labels">
    <div class="timeline-inner" id="timeline-submoments-labels-inner"></div>
  </div>
</div>
<div class="timeline-track bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1 timeline-track-pedagogy">
<div class="flex items-center justify-between gap-2 flex-wrap">
<div class="flex items-center gap-1.5">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-base">
          psychology
         </span>
<span class="text-xs font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_timeline_pedagogy">
          Types d'apprentissage
         </span>
</div>
</div>
<div class="w-full h-6 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-steps">
<div class="timeline-inner" id="timeline-steps-inner"></div>
</div>
</div>
<button class="w-full px-2 py-1.5 flex items-center justify-between bg-white border border-slate-200 rounded-xl hover:bg-slate-50 transition-colors" data-action="toggle-timeline-details" type="button">
<div class="flex items-center gap-1.5">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-base">
         tune
        </span>
<span class="text-xs font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_timeline_details">
         Détails
        </span>
</div>
<span class="material-icons-round text-slate-400 rotate-icon text-sm" id="timeline-details-icon">
        expand_more
       </span>
</button>
<div class="panel-content w-full flex flex-col gap-2" data-display="flex" id="timeline-details" style="display: none;">
<div class="timeline-track bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1">
<div class="flex items-center justify-between gap-2 flex-wrap">
<div class="flex items-center gap-1.5">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-base">
          groups
         </span>
<span class="text-sm font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_grouping">
          Regroupement
         </span>
</div>
<span class="text-xs text-slate-600 font-medium bg-slate-100 border border-slate-200 rounded-full px-2 py-0.5" data-i18n="legend_grouping">
         Plein : Classe • Rayé : Groupes
        </span>
</div>
<div class="w-full h-4 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-grouping">
<div class="timeline-inner" id="timeline-grouping-inner"></div>
</div>
</div>
<div class="timeline-track bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1">
<div class="flex items-center justify-between gap-2 flex-wrap">
<div class="flex items-center gap-1.5">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-base">
          face
         </span>
<span class="text-sm font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_trainer">
          Formateur
         </span>
</div>
<span class="text-xs text-slate-600 font-medium bg-slate-100 border border-slate-200 rounded-full px-2 py-0.5" data-i18n="legend_trainer">
         Plein : Présent • Rayé : Absent
        </span>
</div>
<div class="w-full h-4 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-trainer">
<div class="timeline-inner" id="timeline-trainer-inner"></div>
</div>
</div>
<div class="timeline-track bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1">
<div class="flex items-center justify-between gap-2 flex-wrap">
<div class="flex items-center gap-1.5">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-base">
          place
         </span>
<span class="text-sm font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_place">
          Lieu
         </span>
</div>
<span class="text-xs text-slate-600 font-medium bg-slate-100 border border-slate-200 rounded-full px-2 py-0.5" data-i18n="legend_place">
         Plein : Présentiel • Rayé : En ligne
        </span>
</div>
<div class="w-full h-4 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-place">
<div class="timeline-inner" id="timeline-place-inner"></div>
</div>
</div>
<div class="timeline-track bg-white rounded-xl border border-slate-200 p-1.5 flex flex-col gap-1">
<div class="flex items-center justify-between gap-2 flex-wrap">
<div class="flex items-center gap-1.5">
<span aria-hidden="true" class="material-icons-round text-slate-500 text-base">
          event
         </span>
<span class="text-sm font-bold text-slate-500 uppercase tracking-wider" data-i18n="label_time">
          Temps
         </span>
</div>
<span class="text-xs text-slate-600 font-medium bg-slate-100 border border-slate-200 rounded-full px-2 py-0.5" data-i18n="legend_time">
         Plein : Synchrone • Rayé : Asynchrone
        </span>
</div>
<div class="w-full h-4 flex rounded-lg overflow-hidden bg-slate-100 border border-slate-200 cursor-help timeline-zoom-outer" id="timeline-time">
<div class="timeline-inner" id="timeline-time-inner"></div>
</div>
</div>
</div>
<div class="w-full h-9 relative mt-1 select-none pointer-events-none rounded-lg bg-transparent timeline-zoom-outer" id="timeline-ruler">
<div class="timeline-inner" id="timeline-ruler-inner"></div>
</div>
<div aria-label="Défilement horizontal des visualisations" class="timeline-hscroll no-print" id="timeline-hscroll" role="scrollbar"><div id="timeline-hscroll-inner"></div><div aria-hidden="true" id="timeline-hscroll-thumb"></div></div></div>
</div>
</div>
<details class="bg-white rounded-lg shadow-sm border border-slate-200 overflow-hidden w-full flex flex-col justify-center ld-page mt-2" id="analysis-tabs-wrap" role="tabpanel" aria-labelledby="top-tab-btn-analysis"><summary class="w-full px-3 py-2 flex items-center justify-between bg-slate-50 border-b border-slate-200 cursor-pointer select-none"><div class="flex items-center gap-1.5">
<span class="material-icons-round text-slate-500 text-sm">insights</span>
<span class="font-bold text-slate-700 uppercase text-xs tracking-wide">Graphiques d'analyse</span>
</div><span class="material-icons-round text-slate-500 text-sm analysis-chevron">expand_more</span></summary><div class="w-full"><div class="px-3 pt-2">
<div aria-label="Graphiques d'analyse" class="analysis-tabbar" role="tablist">
<button aria-selected="true" class="analysis-tab-btn is-active" data-analysis-tab="modalites" data-i18n="tab_modalities">Modalités</button>
<button aria-selected="false" class="analysis-tab-btn" data-analysis-tab="competences" data-i18n="tab_competences">Compétences</button>
<button aria-selected="false" class="analysis-tab-btn" data-analysis-tab="aims" data-i18n="tab_aims">Objectifs</button>
<button aria-selected="false" class="analysis-tab-btn" data-analysis-tab="outcomes" data-i18n="tab_outcomes">Résultats</button>
</div>
</div><div class="p-2 pt-1" id="analysis-tabs-content">
<div class="analysis-tab-pane" data-analysis-pane="competences" id="analysis-pane-competences">
<div class="panel-content w-full flex flex-col gap-1 mt-1 p-1 rounded-lg border border-slate-200 bg-slate-50" id="competences-charts-panel">
<!-- Statistiques de competences (Pack 2) -->
<div class="mt-2 grid grid-cols-1 lg:grid-cols-2 gap-2" id="competences-analysis-grid">
<!-- Couverture + non couvertes -->
<div class="bg-white rounded-xl border border-slate-200 p-2">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Compétences</div>
<div class="text-[11px] text-slate-500">Couverture</div>
</div>
<div class="mt-2 space-y-1 text-[11px] text-slate-700">
<div class="flex items-center justify-between gap-2"><span class="font-semibold">Du sujet</span><span class="font-mono" id="comp-coverage-sujet">0/0 (0%)</span></div>
<div class="flex items-center justify-between gap-2"><span class="font-semibold">Transversales</span><span class="font-mono" id="comp-coverage-trans">0/0 (0%)</span></div>
</div>
<details class="mt-2 border border-slate-200 rounded-lg bg-slate-50" id="comp-unused-details">
<summary class="text-[11px] cursor-pointer select-none px-2 py-1.5 flex items-center gap-1">
<span class="material-icons-round text-[14px] text-slate-400">rule</span>
<span class="font-semibold text-slate-600">Compétences non mobilisées</span>
<span class="ml-auto text-slate-400" id="comp-unused-count">0</span>
</summary>
<div class="px-2 pb-2 pt-1">
<div class="grid grid-cols-1 md:grid-cols-2 gap-2">
<div>
<div class="text-[10px] text-slate-500 font-bold uppercase mb-1">Du sujet</div>
<ul class="text-[11px] text-slate-700 list-disc ml-4 space-y-0.5" id="comp-unused-sujet"></ul>
</div>
<div>
<div class="text-[10px] text-slate-500 font-bold uppercase mb-1">Transversales</div>
<ul class="text-[11px] text-slate-700 list-disc ml-4 space-y-0.5" id="comp-unused-trans"></ul>
</div>
</div>
</div>
</details>
</div>
<!-- Top competences (barres) -->
<div class="bg-white rounded-xl border border-slate-200 p-2">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Top compétences</div>
<div class="text-[11px] text-slate-500">(nb d’activités)</div>
</div>
<div class="mt-2 grid grid-cols-1 md:grid-cols-2 gap-2">
<div class="border border-slate-200 rounded-lg overflow-hidden">
<div class="px-2 py-1 bg-slate-50 text-[10px] text-slate-500 font-bold uppercase">Du sujet</div>
<div class="p-1.5">
<canvas class="w-full hidden" height="220" id="chart-comp-top-sujet"></canvas>
<div class="w-full" id="chart-comp-top-sujet-html"></div>
<details class="mt-2">
<summary class="text-[11px] cursor-pointer select-none text-slate-500">Détails (table)</summary>
<div class="mt-1 border border-slate-200 rounded-lg overflow-hidden">
<table class="w-full text-[11px]"><tbody id="comp-top-sujet"></tbody></table>
</div>
</details>
</div>
</div>
<div class="border border-slate-200 rounded-lg overflow-hidden">
<div class="px-2 py-1 bg-slate-50 text-[10px] text-slate-500 font-bold uppercase">Transversales</div>
<div class="p-1.5">
<canvas class="w-full hidden" height="220" id="chart-comp-top-trans"></canvas>
<div class="w-full" id="chart-comp-top-trans-html"></div>
<details class="mt-2">
<summary class="text-[11px] cursor-pointer select-none text-slate-500">Détails (table)</summary>
<div class="mt-1 border border-slate-200 rounded-lg overflow-hidden">
<table class="w-full text-[11px]"><tbody id="comp-top-trans"></tbody></table>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<!-- Répartition par module (barres empilées) -->
<div class="mt-2 bg-white rounded-xl border border-slate-200 p-2" id="competences-by-module-card">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Répartition par module</div>
<div class="text-[11px] text-slate-500">Sélections (Sujet/Transv.)</div>
</div>
<div class="mt-2">
<canvas class="w-full hidden" height="220" id="chart-comp-by-module"></canvas>
<div class="w-full" id="chart-comp-by-module-html"></div>
</div>
<details class="mt-2">
<summary class="text-[11px] cursor-pointer select-none text-slate-500">Détails (table)</summary>
<div class="mt-1 border border-slate-200 rounded-lg overflow-hidden">
<table class="w-full text-[11px]">
<thead class="bg-slate-50">
<tr>
<th class="text-left px-2 py-1 text-[10px] text-slate-500 font-bold uppercase">Module</th>
<th class="text-right px-2 py-1 text-[10px] text-slate-500 font-bold uppercase">Sujet</th>
<th class="text-right px-2 py-1 text-[10px] text-slate-500 font-bold uppercase">Transv.</th>
<th class="text-right px-2 py-1 text-[10px] text-slate-500 font-bold uppercase">% Sujet</th>
</tr>
</thead>
<tbody id="comp-by-module"></tbody>
</table>
</div>
</details>
</div>
<!-- Réseau activités ↔ compétences (bipartite) -->
<div class="mt-2 bg-white rounded-xl border border-slate-200 p-2" id="competences-bipartite-card">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Réseau activités ↔ compétences</div>
<div class="text-[11px] text-slate-500">Compétences mobilisées uniquement</div>
</div>
<div class="mt-2 border border-slate-200 rounded-lg bg-slate-50 overflow-auto h-[340px]" id="competences-bipartite-wrap">
<svg class="w-full" id="chart-comp-bipartite" preserveaspectratio="xMinYMin meet" xmlns="http://www.w3.org/2000/svg"></svg>
</div>
<div class="mt-1 text-[11px] text-slate-500">Lignes pleines : sujet. Lignes en pointillés : transversales.</div>
</div>
</div>
</div>
<div class="analysis-tab-pane" data-analysis-pane="aims" id="analysis-pane-aims">
<div class="panel-content w-full flex flex-col gap-1 mt-1 p-1 rounded-lg border border-slate-200 bg-slate-50" id="aims-charts-panel">
<div class="mt-2 grid grid-cols-1 lg:grid-cols-2 gap-2" id="aims-analysis-grid">
<!-- Couverture + non mobilisés -->
<div class="bg-white rounded-xl border border-slate-200 p-2">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Objectifs d'apprentissage</div>
<div class="text-[11px] text-slate-500">Couverture</div>
</div>
<div class="mt-2 space-y-1 text-[11px] text-slate-700">
<div class="flex items-center justify-between gap-2"><span class="font-semibold">Sélectionnés dans les activités</span><span class="font-mono" id="aim-coverage">0/0 (0%)</span></div>
</div>
<details class="mt-2 border border-slate-200 rounded-lg bg-slate-50" id="aim-unused-details">
<summary class="text-[11px] cursor-pointer select-none px-2 py-1.5 flex items-center gap-1">
<span class="material-icons-round text-[14px] text-slate-400">rule</span>
<span class="font-semibold text-slate-600">Objectifs non mobilisés</span>
<span class="ml-auto text-slate-400" id="aim-unused-count">0</span>
</summary>
<div class="px-2 pb-2 pt-1">
<ul class="text-[11px] text-slate-700 list-disc ml-4 space-y-0.5" id="aim-unused"></ul>
</div>
</details>
</div>
<!-- Top objectifs -->
<div class="bg-white rounded-xl border border-slate-200 p-2">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Top objectifs</div>
<div class="text-[11px] text-slate-500">(nb d’activités)</div>
</div>
<div class="mt-2">
<div class="w-full" id="chart-aim-top-html"></div>
<details class="mt-2">
<summary class="text-[11px] cursor-pointer select-none text-slate-500">Détails (table)</summary>
<div class="mt-1 border border-slate-200 rounded-lg overflow-hidden">
<table class="w-full text-[11px]"><tbody id="aim-top-table"></tbody></table>
</div>
</details>
</div>
</div>
</div>
<div class="mt-2 grid grid-cols-1 lg:grid-cols-2 gap-2">
<!-- Répartition par catégorie -->
<div class="bg-white rounded-xl border border-slate-200 p-2" id="aims-by-category-card">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Répartition par catégorie</div>
<div class="text-[11px] text-slate-500">(nb d’objectifs sélectionnés)</div>
</div>
<div class="mt-2">
<div class="w-full" id="chart-aim-by-category-html"></div>
</div>
</div>
<!-- Répartition par module -->
<div class="bg-white rounded-xl border border-slate-200 p-2" id="aims-by-module-card">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Répartition par module</div>
<div class="text-[11px] text-slate-500">(nb d’objectifs sélectionnés)</div>
</div>
<div class="mt-2">
<div class="w-full" id="chart-aim-by-module-html"></div>
</div>
</div>
</div>
<div class="mt-1 text-[11px] text-slate-500">Ces graphiques analysent les objectifs sélectionnés dans les activités. La liste de référence provient de « Informations et paramètres → 3. Objectifs et résultats ».</div>
</div>
</div>
<div class="analysis-tab-pane" data-analysis-pane="outcomes" id="analysis-pane-outcomes">
<div class="panel-content w-full flex flex-col gap-1 mt-1 p-1 rounded-lg border border-slate-200 bg-slate-50" id="outcomes-charts-panel">
<div class="mt-2 grid grid-cols-1 lg:grid-cols-2 gap-2" id="outcomes-analysis-grid">
<!-- Couverture + non mobilisés -->
<div class="bg-white rounded-xl border border-slate-200 p-2">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Résultats d'apprentissage</div>
<div class="text-[11px] text-slate-500">Couverture</div>
</div>
<div class="mt-2 space-y-1 text-[11px] text-slate-700">
<div class="flex items-center justify-between gap-2"><span class="font-semibold">Sélectionnés dans les activités</span><span class="font-mono" id="out-coverage">0/0 (0%)</span></div>
</div>
<details class="mt-2 border border-slate-200 rounded-lg bg-slate-50" id="out-unused-details">
<summary class="text-[11px] cursor-pointer select-none px-2 py-1.5 flex items-center gap-1">
<span class="material-icons-round text-[14px] text-slate-400">rule</span>
<span class="font-semibold text-slate-600">Résultats non mobilisés</span>
<span class="ml-auto text-slate-400" id="out-unused-count">0</span>
</summary>
<div class="px-2 pb-2 pt-1">
<ul class="text-[11px] text-slate-700 list-disc ml-4 space-y-0.5" id="out-unused"></ul>
</div>
</details>
</div>
<!-- Top résultats -->
<div class="bg-white rounded-xl border border-slate-200 p-2">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Top résultats</div>
<div class="text-[11px] text-slate-500">(nb d’activités)</div>
</div>
<div class="mt-2">
<div class="w-full" id="chart-out-top-html"></div>
<details class="mt-2">
<summary class="text-[11px] cursor-pointer select-none text-slate-500">Détails (table)</summary>
<div class="mt-1 border border-slate-200 rounded-lg overflow-hidden">
<table class="w-full text-[11px]"><tbody id="out-top-table"></tbody></table>
</div>
</details>
</div>
</div>
</div>
<div class="mt-2 grid grid-cols-1 lg:grid-cols-2 gap-2">
<!-- Répartition par catégorie -->
<div class="bg-white rounded-xl border border-slate-200 p-2" id="outcomes-by-category-card">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Répartition par catégorie</div>
<div class="text-[11px] text-slate-500">(nb de résultats sélectionnés)</div>
</div>
<div class="mt-2">
<div class="w-full" id="chart-out-by-category-html"></div>
</div>
</div>
<!-- Répartition par module -->
<div class="bg-white rounded-xl border border-slate-200 p-2" id="outcomes-by-module-card">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600">Répartition par module</div>
<div class="text-[11px] text-slate-500">(nb de résultats sélectionnés)</div>
</div>
<div class="mt-2">
<div class="w-full" id="chart-out-by-module-html"></div>
</div>
</div>
</div>
<div class="mt-1 text-[11px] text-slate-500">Ces graphiques analysent les résultats sélectionnés dans les activités. La liste de référence provient de « Informations et paramètres → 3. Objectifs et résultats ».</div>
</div>
</div>
<div class="analysis-tab-pane is-active" data-analysis-pane="modalites" id="analysis-pane-modalites">
<div class="panel-content w-full flex flex-col gap-1 mt-1 p-1 rounded-lg border border-slate-200 bg-slate-50" id="modalites-charts-panel">
<div class="grid grid-cols-1 md:grid-cols-2 gap-2">
<div class="bg-white rounded-xl border border-slate-200 p-2">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600" data-i18n="chart_learning_types">Types d'apprentissage</div>
<div class="text-[11px] text-slate-500" data-i18n="chart_percent_duration">(% de durée)</div>
</div>
<div class="mt-2 flex gap-2 items-stretch">
<div class="w-1/2">
<canvas class="w-full" height="300" id="chart-learning-types"></canvas>
</div>
<div class="w-1/2 h-[300px] flex flex-col justify-center gap-1 text-[11px] leading-tight text-slate-700" id="chart-learning-types-legend"></div>
</div>
</div>
<div class="grid grid-cols-1 gap-2">
<div class="bg-white rounded-xl border border-slate-200 p-1.5">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600" data-i18n="chart_group_modes">Modes de groupes</div>
<div class="text-[11px] text-slate-500" data-i18n="chart_percent_duration">(% de durée)</div>
</div>
<canvas height="80" id="chart-group-modes"></canvas>
</div>
<div class="bg-white rounded-xl border border-slate-200 p-1.5">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600" data-i18n="chart_place_modes">Modes de lieu</div>
<div class="text-[11px] text-slate-500">(% de durée)</div>
</div>
<canvas height="80" id="chart-place-modes"></canvas>
</div>
<div class="bg-white rounded-xl border border-slate-200 p-1.5">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600" data-i18n="chart_time_modes">Modes de temps</div>
<div class="text-[11px] text-slate-500">(% de durée)</div>
</div>
<canvas height="80" id="chart-time-modes"></canvas>
</div>
<div class="bg-white rounded-xl border border-slate-200 p-1.5">
<div class="flex items-center justify-between">
<div class="text-xs font-bold text-slate-600" data-i18n="chart_trainer_presence">Présence du formateur</div>
<div class="text-[11px] text-slate-500">(% de durée)</div>
</div>
<canvas height="80" id="chart-trainer-presence"></canvas>
</div>
</div>
</div>
<div class="mt-1 text-[11px] text-slate-500">Ces graphiques analysent les modalités des activités (types d’apprentissage, regroupement, lieu, temps, présence du formateur) en pondérant par la durée.</div>
</div>
</div>
</div>
</div></div></details>
<div class="ld-page" id="view-designer">
<div class="flex flex-wrap items-center justify-between mb-2 no-print gap-2" id="view-controls-toolbar">

  <!-- SECTION 1: NAVIGATION -->
  <div class="flex items-center gap-2 flex-shrink-0">
    <span class="hidden lg:inline text-[10px] font-bold text-slate-500 uppercase tracking-wider" aria-hidden="true">Navigation</span>
    <select id="jump-to-select" class="ld-control-select min-w-[140px] max-w-[220px] sm:min-w-[200px] sm:max-w-[300px]" aria-label="Navigation rapide vers un élément">
      <option value="" data-i18n="opt_goto">Aller à…</option>
    </select>
    <button id="jump-to-refresh" class="ld-control-btn border-slate-300 hover:border-indigo-400" type="button" title="Actualiser la liste de navigation" aria-label="Actualiser la navigation">
      <span class="material-icons-round text-[16px]">refresh</span>
    </button>
  </div>

  <!-- SÉPARATEUR -->
  <div class="ld-separator hidden xl:block" role="separator" aria-hidden="true"></div>

  <!-- SECTION 2: CONTRÔLES D'AFFICHAGE -->
  <div class="flex flex-wrap items-center justify-end gap-2 flex-grow">

    <!-- GROUPE: Tout replier -->
    <div class="ld-control-group">
      <button class="ld-control-btn" id="btn-toggle-all-main" data-action="toggle-all-activities" aria-label="Replier ou déplier tous les modules" title="Replier ou déplier tous les modules">
        <span class="material-icons-round text-base" id="icon-toggle-all-main">unfold_less</span>
        <span class="hidden xl:inline" data-i18n="btn_collapse_all" id="text-toggle-all-main">Tout replier</span>
      </button>
    </div>

    <!-- GROUPE: Affichage -->
    <div class="ld-control-group">
      <span class="hidden md:inline text-xs text-slate-500 font-extrabold" aria-hidden="true">Affichage</span>

      <select id="ld-view-level-select" class="ld-control-select" aria-label="Sélection du affichage">
        <option value="activities" data-i18n="btn_view_activities" selected>Activités</option>
        <option value="submoments" data-i18n="btn_view_submoments">Sous-moments</option>
        <option value="moments" data-i18n="btn_view_moments">Moments</option>
        <option value="modules" data-i18n="btn_view_modules">Modules</option>
        <option value="panorama" data-i18n="btn_view_panorama">Panorama</option>
      </select>
    </div>

    <!-- SÉPARATEUR -->
    <div class="ld-separator hidden xl:block" role="separator" aria-hidden="true"></div>

    <!-- GROUPE: Filtres et états -->
    <div class="ld-control-group">
      <span class="hidden md:inline text-xs text-slate-500 font-extrabold" aria-hidden="true">Filtre</span>

      <select id="status-filter" class="ld-control-select" title="Filtrer l'affichage par état" aria-label="Filtrer par état de réalisation">
        <option value="all" selected data-i18n="opt_all_statuses">Tous</option>
        <option value="review" data-i18n="opt_status_review">À revoir</option>
        <option value="in_progress" data-i18n="opt_status_inprogress">En cours</option>
        <option value="done" data-i18n="opt_status_completed">Finalisé</option>
      </select>

      <button id="status-filter-clear" class="ld-control-btn px-1.5" title="RÃ©initialiser le filtre" aria-label="RÃ©initialiser le filtre">
        <span class="material-icons-round text-[16px]">restart_alt</span>
      </button>

      <button id="btn-toggle-target-durations"
              class="ld-control-btn"
              data-action="toggle-target-durations"
              aria-pressed="false"
              title="Afficher les durées cibles"
              aria-label="Afficher les durées cibles">
        <span class="material-icons-round text-[16px]" id="icon-toggle-target-durations">visibility_off</span>
        <span class="hidden xl:inline" id="text-toggle-target-durations">Cibles</span>
      </button>

      <details class="relative">
        <summary class="ld-control-btn list-none select-none bg-white">
          <span class="material-icons-round text-[16px]">tune</span>
          <span class="hidden lg:inline">Affichage des états</span>
        </summary>
        <div class="absolute right-0 mt-1 w-56 bg-white border border-slate-200 rounded-md shadow-lg z-50 p-1">
          <button id="btn-toggle-status-summaries" type="button" aria-pressed="true"
            class="w-full text-left px-2 py-1.5 rounded hover:bg-slate-50 text-slate-700 flex items-center gap-2"
            title="Afficher ou masquer les synthÃ¨ses d'Ã©tat">
            <span class="material-icons-round text-[16px]" id="icon-toggle-status-summaries">visibility_off</span>
            <span id="text-toggle-status-summaries">Masquer synthÃ¨ses</span>
          </button>

          <button id="btn-toggle-status-selectors" type="button" aria-pressed="false"
            class="w-full text-left px-2 py-1.5 rounded bg-white hover:bg-slate-50 text-slate-700 flex items-center gap-2"
            data-i18n-title="title_toggle_status_selectors"
            title="Afficher ou masquer les sÃ©lecteurs d'Ã©tat dans les activitÃ©s">
            <span class="material-icons-round text-[16px]" id="icon-toggle-status-selectors">visibility</span>
            <span id="text-toggle-status-selectors" data-i18n="btn_show_status_selectors">Afficher Ã©tats</span>
          </button>
        </div>
      </details>
    </div>

  </div>
</div>
</div>
<div class="ld-page" id="designer-flow">

<div id="panorama-view" class="hidden mt-2">
  <div class="flex flex-wrap items-center justify-between gap-2 mb-2">
    <div class="flex flex-wrap items-center gap-2">
      <div class="text-xs font-extrabold text-slate-500">Vue panoramique</div>

      <span class="text-xs text-slate-500 font-extrabold">État :</span>
      <select id="panorama-status-filter" class="h-[26px] px-2 text-xs border border-slate-200 rounded-md bg-white text-slate-700 font-semibold focus:outline-none focus:ring-2 focus:ring-indigo-200" title="Filtrer par état">
        <option value="all" data-i18n="opt_all_statuses">Tous</option>
        <option value="review" data-i18n="opt_status_review">À revoir</option>
        <option value="in_progress" data-i18n="opt_status_inprogress">En cours</option>
        <option value="done" data-i18n="opt_status_completed">Finalisé</option>
      </select>

      <span class="text-slate-300 px-1 select-none">|</span>

      <input id="panorama-filter" class="h-[26px] w-64 px-2 rounded-md border border-slate-200 bg-white text-slate-600 text-xs font-semibold focus:outline-none focus:ring-2 focus:ring-indigo-200" placeholder="Filtrer (module, moment, activité…)" data-i18n-placeholder="ph_panorama_filter"/>
    </div>

    <div class="flex flex-wrap items-center gap-2">
      <span class="text-xs text-slate-500 font-extrabold">Sélection : <span id="panorama-selected-count">0</span></span>

      <span class="text-xs text-slate-500 font-extrabold">→ État :</span>
      <select id="panorama-batch-status" class="h-[26px] px-2 text-xs border border-slate-200 rounded-md bg-white text-slate-700 font-semibold focus:outline-none focus:ring-2 focus:ring-indigo-200" title="Définir l’état des lignes sélectionnées">
        <option value="review" data-i18n="opt_status_review">À revoir</option>
        <option value="in_progress" data-i18n="opt_status_inprogress">En cours</option>
        <option value="done" data-i18n="opt_status_completed">Finalisé</option>
      </select>

      <button id="panorama-batch-apply" type="button" class="h-[26px] px-2 rounded-md border border-slate-200 bg-white text-slate-600 text-xs font-extrabold hover:text-indigo-700 hover:bg-slate-50 transition-colors" title="Appliquer l’état aux lignes sélectionnées">
        Appliquer
      </button>

      <button id="panorama-batch-clear" type="button" class="h-[26px] px-2 rounded-md border border-slate-200 bg-white text-slate-600 text-xs font-extrabold hover:text-indigo-700 hover:bg-slate-50 transition-colors" title="Vider la sélection">
        Vider
      </button>

      <button id="panorama-refresh" type="button" class="h-[26px] px-2 rounded-md border border-slate-200 bg-white text-slate-600 text-xs font-extrabold hover:text-indigo-700 hover:bg-slate-50 transition-colors" title="Rafraîchir la vue panoramique">
        Rafraîchir
      </button>
    </div>
  </div>

  <div class="border border-slate-200 rounded-lg bg-white overflow-auto">
    <table class="w-full text-[11px] leading-tight" id="panorama-table">
      <colgroup>
        <col style="width:30px">
        <col style="width:44px">
        <col style="width:240px">
        <col style="width:240px">
        <col style="width:240px">
        <col style="width:240px">
        <col style="width:132px">
        <col style="width:96px">
        <col style="width:84px">
      </colgroup>

      <thead class="sticky top-0 bg-slate-50 border-b border-slate-200">
        <tr class="text-slate-600">
          <th class="text-left font-extrabold px-2 py-1 pano-col-select">
            <input id="panorama-select-all" type="checkbox" class="align-middle" title="Tout sélectionner (lignes visibles)"/>
          </th>
          <th class="text-left font-extrabold px-2 py-1 w-12 pano-sortable" data-sort-key="n"><span>#</span><span class="pano-sort-ind"></span></th>
          <th class="text-left font-extrabold px-2 py-1 min-w-[180px] pano-sortable" data-sort-key="module"><span>Module</span><span class="pano-sort-ind"></span></th>
          <th class="text-left font-extrabold px-2 py-1 min-w-[160px] pano-sortable" data-sort-key="moment"><span>Moment</span><span class="pano-sort-ind"></span></th>
          <th class="text-left font-extrabold px-2 py-1 min-w-[160px] pano-sortable" data-sort-key="bloc"><span>Sous-moment</span><span class="pano-sort-ind"></span></th>
          <th class="text-left font-extrabold px-2 py-1 min-w-[220px] pano-sortable" data-sort-key="activite"><span>Activité</span><span class="pano-sort-ind"></span></th>
          <th class="text-left font-extrabold px-2 py-1 pano-sortable pano-col-status" data-sort-key="status"><span>État</span><span class="pano-sort-ind"></span></th>
          <th class="text-left font-extrabold px-2 py-1 w-20 pano-sortable pano-col-duration" data-sort-key="duree"><span>Durée</span><span class="pano-sort-ind"></span></th>
          <th class="text-left font-extrabold px-2 py-1 w-16">Ouvrir</th>
        </tr>
      </thead>
      <tbody id="panorama-tbody" class="text-slate-700"></tbody>
    </table>
  </div>
</div>

<div id="status-filter-empty" class="hidden text-center py-10 bg-white rounded-xl border-2 border-dashed border-slate-300 mt-3">
  <h3 class="mt-1 text-base font-medium text-slate-900" data-i18n="msg_no_filter_match">Aucun élément ne correspond au filtre.</h3>
  <p class="mt-0.5 text-xs text-slate-500">Modifiez le filtre ou réinitialisez-le pour tout afficher.</p>
</div>

<div class="space-y-4" id="activities-root">
</div>
<div class="hidden text-center py-12 bg-white rounded-xl border-2 border-dashed border-slate-300" id="empty-state">
<h3 class="mt-1 text-base font-medium text-slate-900" data-i18n="empty_title">
      Aucun module conçu
     </h3>
<p class="mt-0.5 text-xs text-slate-500" data-i18n="empty_subtitle">
      Commencez par créer votre premier module.
     </p>
<button class="mt-4 inline-flex items-center px-3 py-1.5 border border-transparent shadow-sm text-xs font-medium rounded text-white bg-indigo-600 hover:bg-indigo-700" data-i18n-title="title_create_activity" data-action="add-activity">
<span class="material-icons-round mr-1 text-sm">
       add
      </span>
<span data-i18n="btn_create_activity">
       Créer un Module
      </span>
</button>
</div>
</div>

</div>
<div class="mt-6 mb-4 no-print flex justify-start ld-page">
<button class="bg-white border border-slate-300 hover:border-indigo-500 text-slate-600 hover:text-indigo-600 hover:bg-indigo-50 px-3 py-1.5 rounded font-bold shadow-sm flex items-center gap-1.5 transition-all text-xs" data-i18n-title="title_new_activity" data-action="add-activity">
<span class="material-icons-round text-lg">
      add_circle
     </span>
<span data-i18n="btn_new_activity">
      Nouveau Module
     </span>
</button>
</div>
<footer class="mt-8 mb-4 text-center text-[11px] text-slate-400 no-print ld-page">
<p>
     version 1.0 - François Jourde (2026) - CC BY SA, inspiré par le
     <a class="underline hover:text-slate-500" href="https://www.ucl.ac.uk/learning-designer/" target="_blank">
      Learning Designer
     </a>
     (UCL Knowledge Lab).
    </p>
<details class="mt-1 inline-block text-left max-w-3xl mx-auto px-3">
<summary class="cursor-pointer no-underline hover:text-slate-500 select-none bg-transparent hover:bg-transparent focus:bg-transparent active:bg-transparent" style="background: transparent;">Mentions légales / Confidentialité</summary>
<div class="mt-2 text-slate-500 leading-relaxed">
<div class="font-semibold text-slate-400">Mentions Légales et Politique de Confidentialité</div>
<ol class="mt-2 space-y-2">
<li>
<div class="font-semibold text-slate-400">1. Éditeur et Hébergement</div>
<div><span class="font-semibold">Éditeur :</span> L'application Concepteur pédagogique est éditée par François Jourde.</div>
<div><span class="font-semibold">Hébergement :</span> Ce site est hébergé par GitHub Inc. Adresse : 88 Colin P. Kelly Jr. Street, San Francisco, CA 94107, United States.</div>
</li>
<li>
<div class="font-semibold text-slate-400">2. Fonctionnement de l'application et Données personnelles</div>
<div>Cette application a été conçue selon une approche « Privacy by design » (respect de la vie privée par défaut).</div>
<div class="mt-1"><span class="font-semibold">Absence de collecte de données :</span> L'application fonctionne entièrement en mode « côté client » (client-side) sur votre navigateur web.</div>
<ul class="list-disc ml-5 mt-1 space-y-1">
<li>Aucune donnée saisie ou manipulée dans l'application n'est transmise à l'éditeur.</li>
<li>Aucune donnée n'est stockée sur un serveur distant (base de données cloud).</li>
</ul>
<div class="mt-1">Toutes les informations restent strictement confinées à votre appareil (ordinateur ou smartphone).</div>
</li>
<li>
<div class="font-semibold text-slate-400">3. Utilisation du Stockage Local (Local Storage)</div>
<div>Pour permettre le fonctionnement de l'application (ex : sauvegarder vos préférences ou votre avancement), nous utilisons la technologie du <span class="font-semibold">localStorage</span> ou <span class="font-semibold">sessionStorage</span> de votre navigateur.</div>
<ul class="list-disc ml-5 mt-1 space-y-1">
<li>Ces données sont stockées uniquement sur votre appareil.</li>
<li>Elles ne sont accessibles par personne d'autre que vous.</li>
<li>Ces mécanismes sont purement techniques et fonctionnels, ils sont donc exemptés de consentement préalable (pas de bandeau cookies nécessaire).</li>
</ul>
<div class="mt-1">Vous pouvez à tout moment supprimer ces données en vidant le cache de votre navigateur.</div>
</li>
<li>
<div class="font-semibold text-slate-400">4. Données techniques (Logs serveur)</div>
<div>Bien que l'éditeur ne collecte aucune donnée, l'infrastructure d'hébergement (GitHub Pages) peut collecter des données techniques standards lors de votre connexion (telles que votre adresse IP et le type de navigateur) dans des journaux de connexion (logs) à des fins de sécurité et de fiabilité du service.</div>
<div class="mt-1">L'éditeur de ce site n'a pas accès à ces données brutes. Pour plus d'informations, vous pouvez consulter la Déclaration de confidentialité de GitHub.</div>
</li>
<li>
<div class="font-semibold text-slate-400">5. Services Tiers</div>
<div>Ce site peut charger des ressources techniques (polices d'écriture, librairies JavaScript) depuis des serveurs tiers (ex : Google Fonts, CDNJ). Ces services peuvent techniquement avoir accès à votre adresse IP lors du chargement de ces ressources.</div>
</li>
<li>
<div class="font-semibold text-slate-400">6. Contact</div>
<div>Pour toute question relative à l'application, vous pouvez contacter l'éditeur via <a class="underline hover:text-slate-600" href="https://github.com/jourde" rel="noopener" target="_blank">https://github.com/jourde</a>.</div>
</li>
</ol>
</div>
</details>
</footer>
</div>
<div class="hidden fixed inset-0 bg-slate-900 bg-opacity-50 z-50 flex items-center justify-center p-4" id="custom-confirm-modal">
<div class="bg-white rounded-lg shadow-lg p-4 max-w-sm w-full">
<h3 class="text-sm font-bold text-slate-800 mb-2" data-i18n="modal_confirm_title">
     Confirmer l'action
    </h3>
<p class="text-slate-600 mb-4 text-xs" id="custom-confirm-msg">
     Êtes-vous sûr ?
    </p>
<div class="flex justify-end gap-2">
<button class="px-3 py-1.5 text-slate-600 hover:bg-slate-100 rounded text-xs font-medium transition-colors" data-i18n="btn_cancel" id="custom-confirm-no">
      Annuler
     </button>
<button class="px-3 py-1.5 bg-red-500 text-white hover:bg-red-600 rounded text-xs font-medium transition-colors" data-i18n="btn_delete" id="custom-confirm-yes">
      Supprimer
     </button>
</div>
</div>
</div>
<div aria-labelledby="import-error-title" aria-modal="true" class="hidden fixed inset-0 bg-slate-900 bg-opacity-50 z-50 flex items-center justify-center p-4" id="import-error-modal" role="dialog">
<div class="bg-white rounded-lg shadow-lg p-4 max-w-lg w-full">
<h3 class="text-sm font-bold text-slate-800 mb-2" data-i18n="import_error_title" id="import-error-title">Erreur d’import</h3>
<div class="text-slate-700 text-xs space-y-3" id="import-error-body">
<!-- filled dynamically -->
</div>
<div class="flex justify-end gap-2 mt-4">
<button class="px-3 py-1.5 bg-slate-100 text-slate-600 hover:bg-slate-200 rounded text-xs font-medium transition-colors" data-i18n="btn_close" id="import-error-close" type="button">Fermer</button>
<button class="px-3 py-1.5 bg-slate-700 text-white hover:bg-slate-800 rounded text-xs font-medium transition-colors hidden" data-i18n="btn_copy_diagnostic" id="import-error-copy" type="button">Copier le diagnostic</button>
<button class="px-3 py-1.5 bg-slate-700 text-white hover:bg-slate-800 transition-colors" data-i18n="btn_recover_text" id="import-error-recover">Récupérer version texte</button>
<button class="px-3 py-1.5 bg-slate-700 text-white hover:bg-slate-800 rounded text-xs font-medium transition-colors hidden" data-i18n="btn_copy_recovery_text" id="import-error-copy-recovery" type="button">Copier le texte récupéré</button>
<button class="px-3 py-1.5 bg-slate-800 text-white hover:bg-slate-900 rounded text-xs font-medium transition-colors hidden" data-i18n="btn_download_report" id="import-error-download" type="button">Télécharger rapport</button>
</div>
</div>
</div>
<div class="fixed z-[100] hidden bg-white text-slate-900 text-[11px] px-2 py-1 rounded-lg border border-slate-200 shadow-lg max-w-[220px] whitespace-normal leading-tight" id="global-tooltip">
</div>
<div aria-labelledby="module-selection-modal-title" aria-modal="true" class="hidden fixed inset-0 bg-slate-900 bg-opacity-50 z-[120] flex items-center justify-center p-4" id="module-selection-modal" role="dialog">
<div class="bg-white rounded-lg shadow-lg p-4 max-w-lg w-full">
<h3 class="text-sm font-bold text-slate-800 mb-2" id="module-selection-modal-title" data-i18n="heading_selection">Sélection</h3>
<div class="text-xs text-slate-700" id="module-selection-modal-body"></div>
<div class="flex justify-end gap-2 mt-4">
<button class="px-3 py-1.5 bg-slate-100 text-slate-600 hover:bg-slate-200 rounded text-xs font-medium transition-colors" id="module-selection-modal-cancel" data-i18n="btn_cancel">Annuler</button>
<button class="px-3 py-1.5 bg-slate-700 text-white hover:bg-slate-800 rounded text-xs font-medium transition-colors" id="module-selection-modal-apply" data-i18n="btn_apply">Appliquer</button>
</div>
</div>
</div>
<!-- Global Search Modal -->
<div aria-labelledby="global-search-modal-title"
     aria-modal="true"
     class="fixed inset-0 hidden items-start justify-center p-3 md:p-8 z-[110]"
     id="global-search-modal"
     role="dialog">
  <div class="absolute inset-0 bg-black/30" data-role="global-search-backdrop"></div>
  <div class="relative w-full max-w-4xl bg-white rounded-xl border border-slate-200 shadow-xl overflow-hidden">
    <div class="flex items-center justify-between px-4 py-3 border-b border-slate-200 bg-white">
      <div class="flex items-center gap-2">
        <span class="material-icons-round text-slate-500">search</span>
        <div class="font-semibold text-sm" id="global-search-modal-title">Recherche globale</div>
        <div class="text-xs text-slate-500 hidden md:block">Ctrl+K</div>
      </div>
      <button class="p-1.5 rounded hover:bg-slate-200 text-slate-600"
              id="global-search-close-btn"
              type="button"
              title="Fermer">
        <span class="material-icons-round text-[18px]">close</span>
      </button>
    </div>

    <div class="px-4 py-3 border-b border-slate-200">
      <div class="flex flex-col md:flex-row md:items-center gap-2">
        <input class="flex-1 w-full px-3 py-2 text-sm border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none"
               id="global-search-input"
               placeholder="Rechercher dans les modules, activités, contenus…" data-i18n-placeholder="ph_global_search"
               type="text" />
        <button class="px-3 py-2 text-sm rounded-lg border border-slate-200 bg-white hover:bg-slate-50"
                id="global-search-refresh-btn"
                type="button">Actualiser</button>
      </div>
      <div class="mt-2 flex flex-wrap items-center gap-3 text-xs text-slate-600">
        <label class="inline-flex items-center gap-1">
          <input class="accent-indigo-600" id="global-search-in-tools" type="checkbox" checked />
          Inclure outils &amp; remarques
        </label>
        <label class="inline-flex items-center gap-1">
          <input class="accent-indigo-600" id="global-search-in-align" type="checkbox" checked />
          Inclure alignement
        </label>
      </div>
      <div class="mt-2 text-xs text-slate-500" id="global-search-count"></div>
    </div>

    <div class="max-h-[65vh] overflow-auto">
      <div class="divide-y divide-slate-100" id="global-search-results"></div>
      <div class="hidden p-4 text-sm text-slate-500" id="global-search-empty">Aucun résultat.</div>
    </div>
  </div>
</div>

<template id="activity-template">
<div class="activity-group relative bg-white rounded-xl shadow-sm border border-slate-200 p-3">
<div class="flex flex-col sm:flex-row sm:items-start justify-between mb-2 gap-2">
<div class="flex-1 flex items-center gap-2">
<div class="drag-handle-activity drag-handle text-slate-300 hover:text-slate-500 no-print flex items-center justify-center w-6 h-6 cursor-grab">
<span class="material-icons-round text-lg">
        drag_indicator
       </span>
</div>
<div class="h-6 w-6 rounded-full bg-slate-200 flex items-center justify-center font-bold text-slate-600 activity-index shrink-0 text-xs">
       1
      </div>
<div class="flex-1 w-full">
<input class="activity-title text-base font-bold text-slate-800 bg-transparent border-b border-transparent hover:border-slate-300 focus:border-indigo-500 outline-none w-full py-0.5 transition-colors" data-i18n-placeholder="ph_activity_title" data-action-input="update-stats-debounced" placeholder="Titre du module (ex: Module 1 : Introduction)" type="text"/>
<div class="flex items-center gap-2 mt-0.5 pr-1">
<div class="activity-type-bar flex-1 h-1.5 bg-slate-100 border border-slate-200 rounded-full overflow-hidden flex">
</div>
</div>
</div>
</div>
<div class="flex items-center gap-1 no-print">
<div class="flex items-center gap-3 mr-2">
<div class="activity-target-wrap flex flex-col items-end">
<span class="text-[9px] text-slate-400 uppercase font-bold tracking-wider leading-none mb-0.5" data-i18n="label_target">
         Cible
        </span>
<div class="flex items-center gap-1">
<input class="activity-target-time w-16 px-1 py-0.5 text-xs text-right border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none h-[22px]" min="0" data-action-input="update-stats-debounced" placeholder="0" type="number"/>
<select class="activity-target-unit w-20 px-0 py-0.5 text-[10px] border border-slate-200 rounded bg-slate-50 focus:ring-1 focus:ring-indigo-500 outline-none h-[22px]" data-action-change="update-stats">
<option data-i18n="unit_mins" value="60">
           min
          </option>
<option data-i18n="unit_hours" value="3600">
           Heures
          </option>
<option data-i18n="unit_days" value="86400">
           Jours
          </option>
<option data-i18n="unit_weeks" value="604800">
           Semaines
          </option>
<option data-i18n="unit_months" value="2592000">
           Mois
          </option>
</select>
</div>
</div>
<span aria-hidden="true" class="module-time-compare text-xs font-bold bg-transparent mx-1 select-none self-center">=</span>
<div class="flex flex-col items-end">
<span class="text-[9px] text-slate-400 uppercase font-bold tracking-wider leading-none mb-0.5" data-i18n="label_designed">
         Conçu
        </span>
<div class="bg-indigo-50 border border-indigo-100 rounded px-2 py-0.5 h-[22px] flex items-center min-w-[3rem] justify-end activity-designed-badge ld-duration-badge">
<span class="activity-total-time text-xs font-bold text-indigo-700 font-mono">
          0m
         </span>
<div class="ld-delta-bar" aria-hidden="true"><div class="ld-delta-axis"></div><div class="ld-delta-neg"></div><div class="ld-delta-pos"></div></div></div>
</div>
</div>
<div class="activity-status-summary ld-status-summary ld-status-summary--module" title="Synthèse des états des activités du module"></div>

<button aria-pressed="false" class="text-slate-400 hover:text-indigo-500 p-1 transition-colors" data-action="toggle-module-subblocks" title="Paramètres du module" type="button">
<span class="material-icons-round text-lg">description</span>
</button>
<div class="h-8 w-px bg-slate-100 mx-1">
</div>
<button class="text-slate-400 hover:text-indigo-500 p-1 transition-colors" data-action="toggle-module" data-i18n-title="title_toggle_panel" title="Afficher/Masquer le détail du module">
<span class="material-icons-round text-lg rotate-icon">
        expand_more
       </span>
</button>
<button class="text-slate-400 hover:text-indigo-500 p-1 transition-colors" data-action="duplicate-module" data-i18n-title="title_duplicate_activity" title="Dupliquer ce module" type="button">
<span class="material-icons-round text-lg">
        content_copy
       </span>
</button>
<button aria-pressed="false" class="text-slate-400 hover:text-indigo-500 p-1 transition-colors" data-action="focus-module" data-i18n-title="title_focus_module" title="Mode focus" type="button">
<span class="material-icons-round text-lg focus-toggle-icon">center_focus_strong</span>
</button>
<button class="text-slate-400 hover:text-red-500 p-1 transition-colors" data-action="delete-module" data-i18n-title="title_delete_activity" title="Supprimer ce module" type="button">
<span class="material-icons-round text-lg">
        delete_outline
       </span>
</button>
</div>
</div>
<div class="activity-body panel-content open">
<div class="module-subblocks hidden ml-8 pr-1 mb-2">
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-2">

    <!-- Carte A — SAISIE -->
    <section class="rounded-xl border border-indigo-100 bg-white shadow-sm">
      <div class="flex items-center justify-between px-3 py-2 border-b border-slate-100">
        <div class="flex items-center gap-2">
          <span class="material-icons-round text-[16px] text-indigo-600">edit</span>
          <span class="text-[11px] font-extrabold uppercase tracking-wider text-slate-600">Saisie du module</span>
        </div>
</div>

      <div class="p-3">
        <div class="compact-label" data-i18n="label_module_objectives">Objectif(s) du module</div>
        <textarea class="activity-description w-full px-3 py-2 text-sm text-slate-700 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y bg-slate-50 leading-relaxed" data-i18n-placeholder="ph_activity_desc" placeholder="Objectif(s) du module..." rows="4"></textarea>
        <p class="text-[11px] text-slate-400 mt-1">Saisie manuelle : ce texte est exporté tel quel.</p>

        <div class="mt-3">
          <div class="compact-label" data-i18n="label_module_notes">Notes</div>
          <textarea class="module-notes w-full px-3 py-2 text-sm text-slate-700 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y bg-white leading-relaxed" data-i18n-placeholder="ph_module_notes" placeholder="Notes..." rows="3"></textarea>
          <p class="text-[11px] text-slate-400 mt-1" data-i18n="help_module_notes">Remarques diverses du formateur (exportées telles quelles).</p>
        </div>
      </div>
    </section>

    <!-- Carte B — SYNTHÈSE AUTO -->
    <section class="rounded-xl border border-slate-200 bg-slate-50 shadow-sm">
      <div class="flex items-center justify-between px-3 py-2 border-b border-slate-200">
        <div class="flex items-center gap-2">
          <span class="material-icons-round text-[16px] text-slate-500">autorenew</span>
          <span class="text-[11px] font-extrabold uppercase tracking-wider text-slate-600">Synthèse automatique</span>
        </div>
        <span class="text-[10px] text-slate-600 bg-white border border-slate-200 px-2 py-0.5 rounded-full">D’après les activités</span>
      </div>

      <div class="p-2 space-y-2">
        <details class="module-competence-summary border border-slate-200 rounded-lg bg-white" data-readonly="true">
<summary class="flex items-center gap-2 cursor-pointer select-none px-2 py-1.5 text-[11px] text-slate-600">
<span class="material-icons-round text-[14px] text-slate-400">checklist</span>
<span class="font-semibold">Compétences du module (d'après les activités)</span>
<span class="ml-auto flex items-center gap-2 text-[10px] text-slate-400 font-normal">
<span><span class="module-competences-count-sujet">0</span> sujet</span>
<span>•</span>
<span><span class="module-competences-count-transv">0</span> transv.</span>
<span class="material-icons-round text-[16px]">expand_more</span>
</span>
</summary>
<div class="px-2 pb-2 pt-1">
<div class="grid grid-cols-1 md:grid-cols-2 gap-2">
<div>
<div class="text-[10px] text-slate-500 font-bold uppercase mb-1">Compétences du sujet</div>
<div class="module-target-competences-sujet-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[180px] overflow-auto text-[11px] space-y-1"></div>
<select class="module-target-competences-sujet-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
</div>
<div>
<div class="text-[10px] text-slate-500 font-bold uppercase mb-1">Compétences transversales</div>
<div class="module-target-competences-transv-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[180px] overflow-auto text-[11px] space-y-1"></div>
<select class="module-target-competences-transv-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
</div>
</div>
<p class="text-[11px] text-slate-400 mt-1">Lecture seule : reflète les compétences sélectionnées dans les activités du module.</p>
<div class="mt-2 flex items-center justify-between gap-2 no-print">
<div class="text-[10px] text-slate-400 italic">Si une compétence manque, ajoutez-la manuellement.</div>
<button class="text-[10px] font-bold text-indigo-700 bg-indigo-50 border border-indigo-200 px-2 py-1 rounded hover:bg-indigo-100 transition-colors flex items-center gap-1" data-action="add-module-competence-manual" title="Ajouter une compétence dans les paramètres" type="button">
<span class="material-icons-round text-[14px]">add</span>
    Ajouter une compétence
  </button>
</div>
</div>
</details>

        <details class="module-aims-summary border border-slate-200 rounded-lg bg-white" data-readonly="true">
<summary class="flex items-center gap-2 cursor-pointer select-none px-2 py-1.5 text-[11px] text-slate-600">
<span class="material-icons-round text-[14px] text-slate-400">flag</span>
<span class="font-semibold">Objectifs d'apprentissage du module (d'après les activités)</span>
<span class="ml-auto flex items-center gap-2 text-[10px] text-slate-400 font-normal">
<span><span class="module-aims-count">0</span> sélectionné(s)</span>
<span class="material-icons-round text-[16px]">expand_more</span>
</span>
</summary>
<div class="px-2 pb-2 pt-1">
<div class="module-aims-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[180px] overflow-auto text-[11px] space-y-1"></div>
<select class="module-aims-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
<p class="text-[11px] text-slate-400 mt-1">Lecture seule : reflète les objectifs sélectionnés dans les activités du module.</p>
<div class="mt-2 flex items-center justify-between gap-2 no-print">
<div class="text-[10px] text-slate-400 italic">Si un objectif manque, ajoutez-le manuellement.</div>
<button class="text-[10px] font-bold text-indigo-700 bg-indigo-50 border border-indigo-200 px-2 py-1 rounded hover:bg-indigo-100 transition-colors flex items-center gap-1" data-action="add-module-aim-manual" title="Ajouter un objectif dans les paramètres" type="button">
<span class="material-icons-round text-[14px]">add</span>
    Ajouter un objectif
  </button>
</div>
<div class="mt-2 module-aims-chips flex flex-wrap gap-1"></div>
</div>
</details>

        <details class="module-outcomes-summary border border-slate-200 rounded-lg bg-white" data-readonly="true">
<summary class="flex items-center gap-2 cursor-pointer select-none px-2 py-1.5 text-[11px] text-slate-600">
<span class="material-icons-round text-[14px] text-slate-400">assignment_turned_in</span>
<span class="font-semibold">Résultats d'apprentissage du module (d'après les activités)</span>
<span class="ml-auto flex items-center gap-2 text-[10px] text-slate-400 font-normal">
<span><span class="module-outcomes-count">0</span> sélectionné(s)</span>
<span class="material-icons-round text-[16px]">expand_more</span>
</span>
</summary>
<div class="px-2 pb-2 pt-1">
<div class="module-outcomes-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[180px] overflow-auto text-[11px] space-y-1"></div>
<select class="module-outcomes-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
<p class="text-[11px] text-slate-400 mt-1">Lecture seule : reflète les résultats sélectionnés dans les activités du module.</p>
<div class="mt-2 flex items-center justify-between gap-2 no-print">
<div class="text-[10px] text-slate-400 italic">Si un résultat manque, ajoutez-le manuellement.</div>
<button class="text-[10px] font-bold text-indigo-700 bg-indigo-50 border border-indigo-200 px-2 py-1 rounded hover:bg-indigo-100 transition-colors flex items-center gap-1" data-action="add-module-outcome-manual" title="Ajouter un résultat dans les paramètres" type="button">
<span class="material-icons-round text-[14px]">add</span>
    Ajouter un résultat
  </button>
</div>
<div class="mt-2 module-outcomes-chips flex flex-wrap gap-1"></div>
</div>
</details>

        <p class="text-[11px] text-slate-400 px-1">
          Pour modifier cette synthèse, ajustez les activités du module.
        </p>
      </div>
    </section>

  </div>
</div>
<div class="activity-moments-container ml-4 pl-4 space-y-3 min-h-[20px]"></div>
<div class="mt-2 pt-1 flex justify-center gap-2 no-print border-t border-slate-100">
<button class="text-sm font-semibold text-slate-500 hover:text-indigo-700 px-3 py-1 rounded transition-colors flex items-center gap-1 hover:bg-slate-50" data-action="add-step" data-i18n-title="title_add_step" type="button">
<span class="material-icons-round text-sm">
        add
       </span>
<span data-i18n="btn_add_step">
        Ajouter Activité
       </span>
</button>
<button class="text-sm font-semibold text-slate-500 hover:text-indigo-700 px-3 py-1 rounded transition-colors flex items-center gap-1 hover:bg-slate-50" data-action="add-moment" title="Ajouter un moment" type="button">
<span class="material-icons-round text-sm">add</span>
<span>Ajouter un moment</span>
</button>
</div>
</div>
</div>
</template>
<template id="moment-template">
<div class="moment-group bg-transparent rounded-lg border border-slate-200/60">
<div class="flex items-center justify-between px-3 py-2">
<div class="flex items-center gap-2 flex-1 min-w-0">
<div class="drag-handle-moment drag-handle text-slate-300 hover:text-slate-500 no-print flex items-center justify-center w-6 h-6 cursor-grab">
<span class="material-icons-round text-lg">drag_indicator</span>
</div>
<div class="h-6 w-6 rounded-full bg-slate-200 flex items-center justify-center font-bold text-slate-600 moment-index shrink-0 text-xs">1</div>
<input class="moment-title flex-1 text-sm font-semibold text-slate-800 bg-transparent focus:outline-none focus:ring-0 border-0 p-0 m-0 min-w-0" placeholder="Nom du moment (ex : Accueil)" type="text"/>
</div>
<div class="flex items-center gap-3">
<div class="flex items-center gap-2">
<div class="moment-target-wrap flex flex-col items-end">
<span class="text-[9px] text-slate-400 uppercase font-bold tracking-wider leading-none mb-0.5" data-i18n="label_target">Cible</span>
<div class="flex gap-1 items-center">
<input class="moment-target-time w-12 px-1 py-0.5 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none h-[22px]" min="0" data-action-input="update-stats-debounced" placeholder="0" type="number"/>
<select class="moment-target-unit w-20 px-1 py-0.5 text-xs border border-slate-200 rounded bg-slate-50 focus:ring-1 focus:ring-indigo-500 outline-none h-[22px]" data-action-change="update-stats">
<option data-i18n="unit_mins" value="60">min</option>
<option data-i18n="unit_hours" value="3600">Heures</option>
<option data-i18n="unit_days" value="86400">Jours</option>
<option data-i18n="unit_weeks" value="604800">Semaines</option>

<option data-i18n="unit_months" value="2592000">
           Mois
          </option>
</select>
</div>
</div>
<span aria-hidden="true" class="moment-time-compare text-xs font-bold bg-transparent mx-1 select-none self-center">=</span><div class="flex flex-col items-end">
<span class="text-[9px] text-slate-400 uppercase font-bold tracking-wider leading-none mb-0.5" data-i18n="label_designed">Conçu</span>
<div class="bg-indigo-50 border border-indigo-100 rounded px-2 py-0.5 h-[22px] flex items-center min-w-[3rem] justify-end moment-designed-badge ld-duration-badge">
<span class="moment-total-time text-xs font-bold text-indigo-700 font-mono">0m</span>
<div class="ld-delta-bar" aria-hidden="true"><div class="ld-delta-axis"></div><div class="ld-delta-neg"></div><div class="ld-delta-pos"></div></div></div>
</div>
</div>
<div class="moment-status-summary ld-status-summary ld-status-summary--moment" title="Synthèse des états des activités du moment"></div>

<button class="no-print text-slate-400 hover:text-indigo-500 p-1 transition-colors" data-action="select-all-moment" title="Tout sélectionner / désélectionner les activités de ce moment" type="button" aria-label="Tout sélectionner dans le moment">
  <span class="material-icons-round text-lg">done_all</span>
</button>
<button aria-expanded="false" class="no-print text-slate-400 hover:text-indigo-500 p-1 transition-colors" data-action="toggle-moment-description" data-i18n-title="title_toggle_description" title="Afficher/Masquer la description" type="button"><span class="material-icons-round text-lg">description</span></button>
<label class="ld-ignore-label" title="Ignorer ce moment (exclu des durées, graphiques et séquence)"><input type="checkbox" class="ld-ignore-toggle" data-ignore-scope="moment"/><span>Ign.</span></label>

<button aria-expanded="true" class="no-print text-slate-400 hover:text-indigo-500 p-1 transition-colors" data-action="toggle-moment" title="Replier / déplier ce moment" type="button">
<span class="material-icons-round text-lg rotate-icon" style="transform: rotate(180deg);">expand_more</span>
</button>
<button class="no-print text-slate-400 hover:text-rose-600 transition-colors" data-action="delete-moment" title="Supprimer ce moment" type="button">
<span class="material-icons-round text-lg">delete_outline</span>
</button>
</div>
</div>
<div class="moment-body px-3 pb-3">
<div class="moment-description-wrap hidden mt-2">
<div class="compact-label" data-i18n="label_description_compact">Description</div>
<textarea class="moment-description w-full min-h-[64px] resize-y px-3 py-2 text-sm border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Description du moment..." data-i18n-placeholder="ph_moment_description"></textarea>
</div>

<div class="submoments-container space-y-2 mt-2"></div>

<div class="moment-direct-steps mt-2">
  <div class="activity-steps-container activity-container space-y-2 min-h-[20px]"></div>
</div>

<div class="mt-3 pt-2 submoments-controls flex justify-center gap-2 no-print border-t border-slate-100">
  <button class="no-print text-xs font-semibold text-slate-500 hover:text-indigo-700 px-2 py-1 rounded transition-colors flex items-center gap-1 hover:bg-slate-50" data-action="add-step" data-i18n-title="title_add_step" title="Ajouter une activité" type="button">
    <span class="material-icons-round text-sm">add</span>
    <span data-i18n="btn_add_step">Ajouter Activité</span>
  </button>
  <button class="no-print text-xs font-semibold text-slate-500 hover:text-indigo-700 px-2 py-1 rounded transition-colors flex items-center gap-1 hover:bg-slate-50" data-action="add-submoment" title="Ajouter un sous-moment" type="button">
    <span class="material-icons-round text-sm">add</span>
    <span>Ajouter un sous-moment</span>
  </button>
</div>

</div>
</div>
</template>

<template id="submoment-template">
  <div class="submoment-card border border-slate-200 rounded-lg bg-white">
    <div class="flex items-center justify-between px-3 py-2 bg-white border-b border-slate-100 rounded-t-lg">
      <div class="flex items-center gap-2 flex-1 min-w-0">
        <div class="drag-handle-submoment drag-handle text-slate-300 hover:text-slate-500 no-print flex items-center justify-center w-6 h-6 cursor-grab">
          <span class="material-icons-round text-lg">drag_indicator</span>
        </div>
        <input class="submoment-title flex-1 min-w-0 text-sm font-semibold bg-transparent border border-transparent focus:border-indigo-300 rounded px-2 py-1 outline-none" placeholder="Titre du sous-moment" />
      </div>
      <div class="flex items-center gap-2">
          <div class="flex items-center gap-1">
          <div class="submoment-target-wrap flex flex-col items-end">
            <span class="text-[8px] text-slate-400 uppercase font-bold tracking-wider leading-none mb-0.5" data-i18n="label_target">Cible</span>
            <div class="flex items-center gap-1">
              <input class="submoment-target-time w-12 px-1 py-0.5 text-[11px] text-right border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none h-[20px]" min="0" data-action-input="update-stats-debounced" placeholder="0" type="number"/>
              <select class="submoment-target-unit w-16 px-0 py-0.5 text-[10px] border border-slate-200 rounded bg-slate-50 focus:ring-1 focus:ring-indigo-500 outline-none h-[20px]" data-action-change="update-stats">
                <option data-i18n="unit_mins" value="60">min</option>
                <option data-i18n="unit_hours" value="3600">Heures</option>
                <option data-i18n="unit_days" value="86400">Jours</option>
                <option data-i18n="unit_weeks" value="604800">Semaines</option>
                <option data-i18n="unit_months" value="2592000">Mois</option>
              </select>
            </div>
          </div>
          <span aria-hidden="true" class="submoment-time-compare text-[11px] font-bold bg-transparent mx-1 select-none self-center">=</span>
          <div class="flex flex-col items-end">
            <span class="text-[8px] text-slate-400 uppercase font-bold tracking-wider leading-none mb-0.5" data-i18n="label_designed">Conçu</span>
            <div class="bg-indigo-50 border border-indigo-100 rounded px-2 py-0.5 h-[20px] flex items-center min-w-[3rem] justify-end submoment-designed-badge ld-duration-badge">
              <span class="submoment-total-time text-[11px] font-bold text-indigo-700 font-mono">0m</span>
            <div class="ld-delta-bar" aria-hidden="true"><div class="ld-delta-axis"></div><div class="ld-delta-neg"></div><div class="ld-delta-pos"></div></div></div>
          </div>
        </div>
        <div class="submoment-status-summary ld-status-summary" title="Synthèse des états des activités du sous-moment"></div>
      </div>
      <div class="flex items-center gap-1 ml-2">
        <button aria-expanded="false" class="no-print text-slate-400 hover:text-indigo-700 transition-colors" data-action="toggle-submoment-notes" title="Notes du sous-moment" type="button">
          <span class="material-icons-round text-sm">description</span>
        </button>
        <button class="no-print text-slate-400 hover:text-indigo-700 transition-colors" data-action="add-step-submoment" title="Ajouter une activité au sous-moment" type="button">
          <span class="material-icons-round text-sm">add</span>
        </button>
<label class="ld-ignore-label" title="Ignorer ce sous-moment (exclu des durées, graphiques et séquence)"><input type="checkbox" class="ld-ignore-toggle" data-ignore-scope="submoment"/><span>Ign.</span></label>

        <button aria-expanded="true" class="no-print text-slate-400 hover:text-indigo-700 transition-colors" data-action="toggle-submoment" title="Replier / déplier ce sous-moment" type="button">
          <span class="material-icons-round text-sm rotate-icon" style="transform: rotate(180deg);">expand_more</span>
        </button>
        <button class="no-print text-slate-400 hover:text-rose-600 transition-colors" data-action="delete-submoment" title="Supprimer ce sous-moment" type="button">
          <span class="material-icons-round text-sm">delete_outline</span>
        </button>
      </div>
    </div>
    <div class="submoment-body px-3 py-2">
      <div class="submoment-notes-wrap hidden mb-2">
        <label class="text-[10px] font-bold text-slate-500 uppercase tracking-wider">Notes</label>
        <textarea class="submoment-notes w-full mt-1 px-2 py-1 text-xs text-slate-700 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y bg-white" placeholder="Notes du sous-moment..."></textarea>
      </div>
      <div class="submoment-steps steps-container space-y-2 min-h-[20px]"></div>
    </div>
  </div>
</template>

<template id="step-template">
<div class="step-card bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden relative group flex flex-col">
<div class="step-header flex items-center gap-2 p-2 bg-slate-50 border-b border-slate-100 transition-colors">
<div class="drag-handle-step drag-handle flex items-center justify-center text-slate-300 hover:text-slate-500 cursor-grab">
<span class="material-icons-round text-base">
       drag_indicator
      </span>
</div>
<label class="no-print flex items-center justify-center mr-1" title="Sélectionner l’activité (actions groupées)">
  <input type="checkbox" class="step-batch-select w-4 h-4 accent-indigo-600" aria-label="Sélectionner l’activité"/>
</label>
<span class="material-icons-round text-amber-500 text-[18px] step-coherence-indicator hidden no-print" title="">warning_amber</span>
<div class="flex-1">
<input class="step-input-title w-full px-1 py-0.5 text-sm font-semibold text-slate-800 border-none bg-transparent focus:ring-0 outline-none" data-i18n-placeholder="ph_step_title" placeholder="Titre de l'activité..." type="text"/>

</div>
<div class="w-24 learning-type-container">
<select class="learning-type-select w-full px-2 py-0.5 text-xs font-semibold border rounded focus:ring-1 focus:ring-indigo-500 outline-none transition-all select-acquisition h-[22px]" data-action-change="update-step-type">
<option data-i18n="type_none" value="none" class="ld-opt-none" style="background-color:#f1f5f9;color:#64748b;">
        Aucun
       </option>
<option data-i18n="type_acquisition" value="acquisition">
        Acquisition
       </option>
<option data-i18n="type_collaboration" value="collaboration">
        Collaboration
       </option>
<option data-i18n="type_discussion" value="discussion">
        Discussion
       </option>
<option data-i18n="type_investigation" value="investigation">
        Enquête
       </option>
<option data-i18n="type_practice" value="practice">
        Entraînement
       </option>
<option data-i18n="type_production" value="production">
        Production
       </option>
</select>
</div>
<div class="flex items-center gap-1">
<input class="duration-input w-16 px-2 py-0.5 text-xs font-semibold border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none h-[22px] text-right text-slate-600" min="0" data-action-input="update-stats-debounced" placeholder="0" type="number"/>
<select class="duration-unit w-24 px-2 py-0.5 text-xs border border-slate-200 rounded bg-slate-50 focus:ring-1 focus:ring-indigo-500 outline-none h-[22px]" data-action-change="update-stats">
<option data-i18n="unit_mins" value="60">
        min
       </option>
<option data-i18n="unit_hours" value="3600">
        Heures
       </option>
<option data-i18n="unit_days" value="86400">
        Jours
       </option>
<option data-i18n="unit_weeks" value="604800">
        Semaines
       </option>

<option data-i18n="unit_months" value="2592000">
           Mois
          </option>
</select>
</div>
<div class="flex items-center" style="position:relative;">
<select class="step-status-select" data-action-change="update-step-status" aria-label="État">
<option value="in_progress">En cours</option>
<option value="done">Finalisé</option>
<option value="review">À revoir</option>
</select>
<button type="button" class="step-status-dot" data-val="in_progress" title="État : En cours" aria-label="Changer l'état"></button>
</div>
<div class="flex items-center gap-0.5 no-print">

<label class="ld-ignore-label" title="Ignorer cette activité (exclue des durées, graphiques et séquence)"><input type="checkbox" class="ld-ignore-toggle" data-ignore-scope="step"/><span>Ign.</span></label>
<button class="text-slate-400 hover:text-indigo-500 p-0.5" data-action="toggle-step" data-i18n-title="title_toggle_panel" title="Afficher/Masquer les paramètres">
<span class="material-icons-round text-base">
        description
       </span>
</button>
<button class="text-slate-300 hover:text-indigo-500 p-0.5" data-action="duplicate-step" data-i18n-title="title_duplicate_step" title="Dupliquer cette activité" type="button">
<span class="material-icons-round text-base">
        content_copy
       </span>
</button>
<button class="text-slate-300 hover:text-red-400 p-0.5" data-action="delete-step" data-i18n-title="title_delete_step" title="Supprimer cette activité" type="button">
<span class="material-icons-round text-base">
        delete_outline
       </span>
</button>
</div>
</div>
<div class="step-body panel-content collapsed p-3 pt-2">
<div class="flex flex-col lg:flex-row gap-3 mt-1">
<div class="lg:w-[240px] shrink-0 space-y-2">
<div>
<label class="compact-label compact-label-lg flex items-center gap-1">
<span class="material-icons-round text-[10px] text-slate-400">
          groups
         </span>
<span class="step-left-label" data-i18n="label_grouping">
          Regroupement
         </span>
</label>
<div class="space-y-1">
<select class="step-group-mode w-full px-2 py-0.5 text-xs rounded border border-slate-200 bg-white outline-none h-[24px]" data-action-change="toggle-group-mode">
<option data-i18n="opt_whole_class" value="class">
           Groupe entier
          </option>
<option data-i18n="opt_groups" value="groups">
           Sous-groupe
          </option>
<option data-i18n="opt_individual" value="individual">
           Individuel
          </option>
</select>
<div class="step-group-details hidden">
<div class="flex gap-1 mb-1">
<div class="relative flex-1">
<input class="step-group-count w-full px-2 py-0.5 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none h-[24px]" data-i18n-placeholder="ph_nb_groups" min="1" data-action-input="update-group-math" data-group-math="count" placeholder="Nb groupes" type="number"/>
<span class="absolute right-1 top-1/2 -translate-y-1/2 text-[8px] text-slate-400 pointer-events-none pr-1" data-i18n="label_short_groups">
            Grps
           </span>
</div>
<div class="relative flex-1">
<input class="step-group-size w-full px-2 py-0.5 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none h-[24px]" data-i18n-placeholder="ph_per_group" min="1" data-action-input="update-group-math" data-group-math="size" placeholder="Par groupe" type="number"/>
<span class="absolute right-1 top-1/2 -translate-y-1/2 text-[8px] text-slate-400 pointer-events-none pr-1" data-i18n="label_short_pers">
            Pers
           </span>
</div>
</div>
<textarea class="step-group-details-notes w-full px-2 py-1 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y" placeholder="Détails du regroupement (composition, critères, etc.)" data-i18n-placeholder="ph_grouping_details" rows="2"></textarea>
</div>
</div>
</div>
<div class="space-y-1 pt-1 border-t border-slate-100">

<div class="space-y-0.5">
<span class="step-left-label text-[10px] w-12 text-slate-400 font-bold uppercase flex items-center gap-0.5 relative z-10">
<span class="material-icons-round text-[10px]">
           face
          </span>
<span data-i18n="label_trainer">
           Formateur
          </span>
</span>
<select class="trainer-select w-full px-1 py-0.5 text-[10px] rounded border border-slate-200 bg-white outline-none h-[22px]" data-action-change="update-stats">
<option data-i18n="opt_present" value="present">
           Présent
          </option>
<option data-i18n="opt_absent" value="absent">
           Absent
          </option>
</select>
</div>
<div class="space-y-0.5">
<span class="step-left-label text-[10px] w-12 text-slate-400 font-bold uppercase flex items-center gap-0.5 relative z-10">
<span class="material-icons-round text-[10px]">
           place
          </span>
<span data-i18n="label_place">
           Lieu
          </span>
</span>
<select class="place-select w-full px-1 py-0.5 text-[10px] rounded border border-slate-200 bg-white outline-none h-[22px]" data-action-change="update-stats">
<option data-i18n="opt_insitu" value="situ">
           Présentiel (sur site)
          </option>
<option data-i18n="opt_online" value="online">
           Distanciel (en ligne)
          </option>
<option data-i18n="opt_hybrid" value="hybrid">
           Hybride (sur site et en ligne)
          </option>
</select>
</div>
<div class="space-y-0.5">
<span class="step-left-label text-[10px] w-12 text-slate-400 font-bold uppercase flex items-center gap-0.5 relative z-10">
<span class="material-icons-round text-[10px]">
           event
          </span>
<span data-i18n="label_time">
           Temps
          </span>
</span>
<select class="time-select w-full px-1 py-0.5 text-[10px] rounded border border-slate-200 bg-white outline-none h-[22px]" data-action-change="update-stats">
<option data-i18n="opt_sync" value="sync">
           Synchrone
          </option>
<option data-i18n="opt_async" value="async">
           Asynchrone
          </option>
</select>
</div>
<div class="space-y-0.5">
  <span class="step-left-label text-[10px] w-12 text-slate-400 font-bold uppercase flex items-center gap-0.5 relative z-10">
    <span class="material-icons-round text-[10px]">fact_check</span>
    <span>Évaluation</span>
  </span>
  <select class="evaluation-select w-full px-1 py-0.5 text-[10px] rounded border border-slate-200 focus:ring-1 focus:ring-indigo-500 bg-white outline-none h-[22px]" data-action-change="update-stats">
    <option value="Aucune" selected>Aucune</option>
    <option value="Diagnostique">Diagnostique</option>
    <option value="Formative">Formative</option>
    <option value="Certificative/Sommative">Certificative/Sommative</option>
  </select>
</div>

</div>
</div>
<div class="lg:flex-1 step-right-col">
  <!-- Onglets : Déroulé / Alignement / Ressources -->
  <div class="step-tabs" role="tablist" aria-label="Panneaux de l'activité">
            <button class="step-tab" type="button" role="tab" aria-selected="true" tabindex="0" data-step-tab="description" data-i18n="tab_description">Description</button>
    <button class="step-tab" type="button" role="tab" aria-selected="false" tabindex="-1" data-step-tab="flow" data-i18n="tab_flow">Déroulé</button>
    <button class="step-tab" type="button" role="tab" aria-selected="false" tabindex="-1" data-step-tab="alignment" data-i18n="tab_alignment">Alignement</button>
    <button class="step-tab" type="button" role="tab" aria-selected="false" tabindex="-1" data-step-tab="resources" data-i18n="tab_resources">Ressources</button>
    <button class="step-tab" type="button" role="tab" aria-selected="false" tabindex="-1" data-step-tab="notes" data-i18n="label_notes">Notes</button>
  </div>

  <div class="step-tabpanels">
        <!-- Description -->
    <div class="step-tabpanel mt-2 space-y-2" data-step-panel="description">
      <div class="step-right-section border border-slate-200 rounded-lg bg-white p-2">
        <div class="compact-label flex items-center gap-1 mb-1">
          <span class="material-icons-round text-[10px] text-slate-400">flag</span>
          <span data-i18n="label_step_objective">Description de l'activité</span>
        </div>
        <textarea class="step-input-objective w-full px-2 py-1.5 text-[12px] border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-200 focus:border-indigo-300 bg-slate-50 text-slate-700" data-i18n-placeholder="ph_step_objective" placeholder="Décrivez l'activité..." rows="2"></textarea>
      </div>
    </div>

    <!-- Déroulé -->
    <div class="step-tabpanel mt-2 space-y-2" data-step-panel="flow" hidden>
<details class="step-right-section border border-slate-200 rounded-lg bg-white" open>
        <summary class="compact-label flex items-center gap-1 cursor-pointer select-none px-2 py-1.5">
          <span class="material-icons-round text-[10px] text-slate-400">assignment</span>
          <span data-i18n="label_tasks">Ce que les apprenants doivent faire</span>
          <span class="ml-auto flex items-center gap-1 text-[10px] text-slate-400 font-normal">
            <span>Afficher</span>
            <span class="material-icons-round text-[14px] step-right-chevron">expand_more</span>
          </span>
        </summary>
        <div class="px-2 pb-2 pt-1">
          <textarea class="step-input-tasks w-full px-2 py-1.5 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y leading-relaxed" data-i18n-placeholder="ph_tasks" placeholder="Décrivez les étapes, instructions et tâches..." rows="2"></textarea>
        </div>
      </details>

      <details class="step-right-section border border-slate-200 rounded-lg bg-white" open>
        <summary class="compact-label flex items-center gap-1 cursor-pointer select-none px-2 py-1.5">
          <span class="material-icons-round text-[10px] text-slate-400">support_agent</span>
          <span data-i18n="label_trainer_tasks">Ce que le ou les formateurs doivent faire</span>
          <span class="ml-auto flex items-center gap-1 text-[10px] text-slate-400 font-normal">
            <span>Afficher</span>
            <span class="material-icons-round text-[14px] step-right-chevron">expand_more</span>
          </span>
        </summary>
        <div class="px-2 pb-2 pt-1">
          <textarea class="step-input-trainer-tasks w-full px-2 py-1.5 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y leading-relaxed bg-slate-50" data-i18n-placeholder="ph_trainer_tasks" placeholder="Décrivez les actions attendues du formateur..." rows="2"></textarea>
        </div>
      </details>
    </div>

    <!-- Alignement -->
    <div class="step-tabpanel mt-2 space-y-2" data-step-panel="alignment" hidden>
      <details class="step-right-section border border-slate-200 rounded-lg bg-white">
        <summary class="compact-label flex items-center gap-1 cursor-pointer select-none px-2 py-1.5">
          <span class="material-icons-round text-[10px] text-slate-400">school</span>
          <span>Compétences ciblées</span>
          <span class="ml-auto flex items-center gap-1 text-[10px] text-slate-400 font-normal">
            <span>Afficher</span>
            <span class="material-icons-round text-[14px] step-right-chevron">expand_more</span>
          </span>
        </summary>
        <div class="px-2 pb-2 pt-1">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
            <div>
              <div class="text-[10px] text-slate-500 font-bold uppercase mb-1">Compétences du sujet</div>
              <div class="step-competences-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[140px] overflow-auto text-[11px] space-y-1"></div>
              <select class="step-competences-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
            </div>
            <div>
              <div class="text-[10px] text-slate-500 font-bold uppercase mb-1">Compétences transversales</div>
              <div class="step-competences-transversales-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[140px] overflow-auto text-[11px] space-y-1"></div>
              <select class="step-competences-transversales-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
            </div>
          </div>
          <p class="text-[11px] text-slate-400 mt-1">Sélection : cochez les compétences concernées</p>
          <div class="mt-2 flex items-center justify-between gap-2 no-print">
            <div class="text-[10px] text-slate-400 italic">Si une compétence/objectif manque, ajoutez-la manuellement.</div>
            <button class="text-[10px] font-bold text-indigo-700 bg-indigo-50 border border-indigo-200 px-2 py-1 rounded hover:bg-indigo-100 transition-colors flex items-center gap-1" data-action="open-aims-from-step" title="Ajouter une compétence dans les paramètres" type="button">
              <span class="material-icons-round text-[14px]">add</span>
              Ajouter une compétence
            </button>
          </div>
        </div>
      </details>

      <details class="step-right-section border border-slate-200 rounded-lg bg-white">
        <summary class="compact-label flex items-center gap-1 cursor-pointer select-none px-2 py-1.5">
          <span class="material-icons-round text-[10px] text-slate-400">flag</span>
          <span>Objectifs ciblés</span>
          <span class="ml-auto flex items-center gap-1 text-[10px] text-slate-400 font-normal">
            <span>Afficher</span>
            <span class="material-icons-round text-[14px] step-right-chevron">expand_more</span>
          </span>
        </summary>
        <div class="px-2 pb-2 pt-1">
          <div class="step-aims-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[140px] overflow-auto text-[11px] space-y-1"></div>
          <select class="step-aims-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
          <p class="text-[11px] text-slate-400 mt-1">Sélection : cochez les objectifs concernés</p>
          <div class="mt-2 flex items-center justify-between gap-2 no-print">
            <div class="text-[10px] text-slate-400 italic">Si un objectif manque, ajoutez-le manuellement.</div>
            <button class="text-[10px] font-bold text-indigo-700 bg-indigo-50 border border-indigo-200 px-2 py-1 rounded hover:bg-indigo-100 transition-colors flex items-center gap-1" data-action="open-aims-from-step" title="Ajouter un objectif dans les paramètres" type="button">
              <span class="material-icons-round text-[14px]">add</span>
              Ajouter un objectif
            </button>
          </div>
        </div>
      </details>

      <details class="step-right-section border border-slate-200 rounded-lg bg-white">
        <summary class="compact-label flex items-center gap-1 cursor-pointer select-none px-2 py-1.5">
          <span class="material-icons-round text-[10px] text-slate-400">assignment_turned_in</span>
          <span>Résultats d'apprentissage ciblés</span>
          <span class="ml-auto flex items-center gap-1 text-[10px] text-slate-400 font-normal">
            <span>Afficher</span>
            <span class="material-icons-round text-[14px] step-right-chevron">expand_more</span>
          </span>
        </summary>
        <div class="px-2 pb-2 pt-1">
          <div class="step-outcomes-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[140px] overflow-auto text-[11px] space-y-1"></div>
          <select class="step-outcomes-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
          <p class="text-[11px] text-slate-400 mt-1">Sélection : cochez les résultats concernés</p>
          <div class="mt-2 flex items-center justify-between gap-2 no-print">
            <div class="text-[10px] text-slate-400 italic">Si un résultat manque, ajoutez-le manuellement.</div>
            <button class="text-[10px] font-bold text-indigo-700 bg-indigo-50 border border-indigo-200 px-2 py-1 rounded hover:bg-indigo-100 transition-colors flex items-center gap-1" data-action="open-outcomes-from-step" title="Ajouter un résultat dans les paramètres" type="button">
              <span class="material-icons-round text-[14px]">add</span>
              Ajouter un résultat
            </button>
          </div>
        </div>
      </details>
    </div>

    <!-- Ressources -->
    <div class="step-tabpanel mt-2 space-y-2" data-step-panel="resources" hidden>
      <details class="step-right-section border border-slate-200 rounded-lg bg-white" data-section="tools-materials">
        <summary class="compact-label flex items-center gap-1 cursor-pointer select-none px-2 py-1.5 bg-slate-50 rounded-lg">
          <span class="material-icons-round text-[10px] text-slate-400">construction</span>
          <span>Outils et matériel (activité)</span>
          <span class="ml-auto flex items-center gap-1 text-[10px] text-slate-400 font-normal">
            <span>Afficher</span>
            <span class="material-icons-round text-[14px] step-right-chevron">expand_more</span>
          </span>
        </summary>
        <div class="px-2 pb-2 pt-2">
          <div class="flex items-center justify-between gap-2 mb-1 text-[11px] text-slate-500">
            <label class="flex items-center gap-2 cursor-pointer select-none">
              <input type="checkbox" class="tm-show-selected-toggle accent-indigo-600" />
              <span>Afficher uniquement les sélectionnés</span>
            </label>
            <span class="tm-selected-count text-[10px] text-slate-400"></span>
          </div>
          <div class="step-tools-materials-checkboxes w-full border border-slate-200 rounded-lg bg-slate-50 p-2 max-h-[160px] overflow-auto text-[11px] space-y-1"></div>
          <select class="step-tools-materials-select w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none min-h-[74px] hidden" multiple=""></select>
          <p class="text-[11px] text-slate-400 mt-1">Sélection : cochez les outils et matériels requis pour cette activité (ajoutez une remarque si nécessaire).</p>
        </div>
      </details>
    

      <details class="step-right-section border border-slate-200 rounded-lg bg-white" data-section="links-refs">
        <summary class="compact-label flex items-center gap-1 cursor-pointer select-none px-2 py-1.5 bg-slate-50 rounded-lg">
          <span class="material-icons-round text-[10px] text-slate-400">link</span>
          <span data-i18n="label_step_links_refs">Liens et références</span>
          <span class="ml-auto flex items-center gap-1 text-[10px] text-slate-400 font-normal">
            <span>Afficher</span>
            <span class="material-icons-round text-[14px] step-right-chevron">expand_more</span>
          </span>
        </summary>
        <div class="px-2 pb-2 pt-2">
          <textarea class="step-input-linksrefs w-full px-2 py-1.5 text-xs border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none resize-y bg-slate-50 text-slate-700"
                    rows="3"
                    data-i18n-placeholder="ph_step_links_refs"
                    placeholder="Liens, références, bibliographie, DOI, normes, etc."></textarea>
          <p class="text-[11px] text-slate-400 mt-1" data-i18n="hint_step_links_refs">Un lien par ligne, ou une référence courte (auteur, année, page...).</p>
        </div>
      </details>

</div>

    <!-- Notes -->
    <div class="step-tabpanel mt-2 space-y-2" data-step-panel="notes" hidden>
      <details class="step-right-section border border-slate-200 rounded-lg bg-white" open>
        <summary class="compact-label flex items-center gap-1 cursor-pointer select-none px-2 py-1.5">
          <span class="material-icons-round text-[10px] text-slate-400">comment</span>
          <span data-i18n="label_notes">Notes</span>
          <span class="ml-auto flex items-center gap-1 text-[10px] text-slate-400 font-normal">
            <span>Afficher</span>
            <span class="material-icons-round text-[14px] step-right-chevron">expand_more</span>
          </span>
        </summary>
        <div class="px-2 pb-2 pt-1">
          <textarea class="step-input-notes w-full px-2 py-1.5 text-xs border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y bg-slate-50 text-slate-600 italic" data-i18n-placeholder="ph_notes" placeholder="Notes formateur, ressources ou liens..." rows="2"></textarea>
        </div>
      </details>
    </div>
  </div>
</div>

</div>
</div>
</div>
</div>
</template>
<script>


const root = document.getElementById('activities-root');

// ---- Duration comparison settings ----
const durationComparisonSettings = {
    absoluteTolerance: 0,     // Tolérance absolue en secondes (fixée à 0)
    relativeTolerance: 0.02,  // Tolérance relative (±2% par défaut)
    useRounding: true,        // Arrondir à la seconde près
    showMinorDeviations: false // Masquer les écarts < 2%
};

// ---- Duration comparison function ----
/**
 * Compare deux durées et détermine si elles sont conformes
 * @param {number} designedSecs - Durée conçue en secondes
 * @param {number} targetSecs - Durée prévue en secondes
 * @param {object} options - Options de tolérance
 * @returns {object} { isMatch, deviation, deviationPct, isOver, isUnder, severity }
 */
function compareDurations(designedSecs, targetSecs, options = {}) {
    const {
        absoluteTolerance = durationComparisonSettings.absoluteTolerance,
        relativeTolerance = durationComparisonSettings.relativeTolerance,
        useRounding = durationComparisonSettings.useRounding,
        showMinorDeviations = durationComparisonSettings.showMinorDeviations
    } = options;

    if (targetSecs <= 0) {
        return {
            isMatch: true,
            deviation: 0,
            deviationPct: 0,
            isOver: false,
            isUnder: false,
            severity: 'ok'
        };
    }

    const designed = useRounding ? Math.round(designedSecs) : designedSecs;
    const target = useRounding ? Math.round(targetSecs) : targetSecs;

    const deviation = designed - target;
    const deviationPct = Math.abs(deviation) / target;

    // Considérer comme conforme si dans la tolérance absolue OU relative
    const isWithinAbsolute = Math.abs(deviation) <= absoluteTolerance;
    const isWithinRelative = deviationPct <= relativeTolerance;
    const isMatch = isWithinAbsolute || isWithinRelative;

    // Masquer les déviations mineures si configuré
    if (showMinorDeviations === false && deviationPct < 0.02) {
        return {
            isMatch: true,
            deviation,
            deviationPct: deviationPct * 100,
            isOver: false,
            isUnder: false,
            severity: 'ok'
        };
    }

    // Déterminer la sévérité
    let severity = 'ok';
    if (!isMatch) {
        const absDev = Math.abs(deviationPct) * 100;
        if (absDev < 5) severity = 'warning';      // Écart < 5%
        else if (absDev < 15) severity = 'moderate'; // Écart 5-15%
        else severity = 'severe';                    // Écart > 15%
    }

    return {
        isMatch,
        deviation,
        deviationPct: deviationPct * 100, // En pourcentage
        isOver: !isMatch && deviation > 0,
        isUnder: !isMatch && deviation < 0,
        severity
    };
}
try { window.compareDurations = compareDurations; } catch(_){ __ldSilentErr(_); }



// ---- Delta bar helper (Target vs Designed) ----
// Visualise l'écart centré sur la cible : trop court (gauche) vs trop long (droite).
function __ldEnsureDeltaBar(badgeEl){
  try{
    if(!badgeEl) return null;

    // Nettoyer l'ancien mini-histogramme si présent (rétrocompat)
    const old = badgeEl.querySelector('.ld-mini-hist');
    if(old) old.remove();

    let wrap = badgeEl.querySelector('.ld-delta-bar');
    if(!wrap){
      wrap = document.createElement('div');
      wrap.className = 'ld-delta-bar';
      wrap.setAttribute('aria-hidden','true');

      const axis = document.createElement('div'); axis.className = 'ld-delta-axis';
      const neg  = document.createElement('div'); neg.className  = 'ld-delta-neg';
      const pos  = document.createElement('div'); pos.className  = 'ld-delta-pos';

      wrap.appendChild(axis);
      wrap.appendChild(neg);
      wrap.appendChild(pos);
      badgeEl.appendChild(wrap);
    }
    return wrap;
  }catch(_){ return null; }
}

function __ldUpdateDeltaBar(badgeEl, targetSecs, designedSecs){
  try{
    if(!badgeEl) return;
    const wrap = __ldEnsureDeltaBar(badgeEl);
    if(!wrap) return;

    const negEl = wrap.querySelector('.ld-delta-neg');
    const posEl = wrap.querySelector('.ld-delta-pos');

    const t = Math.max(0, Number(targetSecs) || 0);
    const d = Math.max(0, Number(designedSecs) || 0);

    // Reset
    if (negEl) negEl.style.width = '0%';
    if (posEl) posEl.style.width = '0%';
    wrap.classList.remove('ld-delta-ok');

    // Sans cible : pas d'écart interprétable (on laisse la barre neutre)
    if (!(t > 0)) return;

    const delta = d - t;

    // Largeur relative à la cible, saturée : |delta| >= cible => demi-largeur complète (50%)
    const ratio = Math.min(1, Math.abs(delta) / t);
    const sidePct = Math.max(0, Math.min(50, ratio * 50)); // 0..50 (% de la largeur totale)

    if (delta > 0) {
      if (posEl) posEl.style.width = `${sidePct}%`;
    } else if (delta < 0) {
      if (negEl) negEl.style.width = `${sidePct}%`;
    }

    // Marquer conforme (couleur verte) selon la logique existante de tolérance
    try{
      const cmp = (typeof compareDurations === 'function')
        ? compareDurations(d, t)
        : { isMatch: Math.round(d) === Math.round(t), deviation: d - t };
      if (cmp && cmp.isMatch) wrap.classList.add('ld-delta-ok');
    }catch(_){ __ldSilentErr(_); }
  }catch(_){ __ldSilentErr(_); }
}
try { window.__ldUpdateDeltaBar = __ldUpdateDeltaBar; } catch(_){ __ldSilentErr(_); }

// ---- Global step duration helper (seconds) ----
// Used for all designed-duration aggregates (module/moment), regardless of per-step unit.
function getStepDurationSecs(stepCard) {
  try {
    if (!stepCard) return 0;
    const v = Math.max(0, parseFloat(stepCard.querySelector('.duration-input')?.value) || 0);
    const rawUnit = stepCard.querySelector('.duration-unit')?.value;
    const u = mapUnitToSecs(rawUnit || 60);
    const secs = v * (u || 60); // unit values are seconds-per-unit
    return Number.isFinite(secs) ? secs : 0;
  } catch (_) { return 0; }
}
try { window.getStepDurationSecs = getStepDurationSecs; } catch(_){ __ldSilentErr(_); }



// ---- Designed step-card query helper (includes steps inside submoments) ----
// IMPORTANT: Submoment step containers use `.submoment-steps` (not `.activity-steps-container`).
// For all "designed duration" aggregates, we must include BOTH containers.

/* --- Ignore (cocher-décocher) helpers --- */
function __ldIsSelfIgnored(el){
  try {
    if (!el) return false;
    const d = el.dataset || {};
    return d.ldIgnored === '1' || d.ignored === '1' || d.ignore === '1' || el.classList.contains('ld-ignored');
  } catch(_) { return false; }
}
function __ldHasIgnoredAncestor(el){
  try {
    let p = el && el.parentElement;
    while (p && p !== document.body) {
      if (p.classList && (p.classList.contains('moment-group') || p.classList.contains('submoment-card') || p.classList.contains('step-card'))) {
        if (__ldIsSelfIgnored(p)) return true;
      }
      p = p.parentElement;
    }
  } catch(_){ __ldSilentErr(_); }
  return false;
}
function __ldIsIgnored(el){
  return __ldIsSelfIgnored(el) || __ldHasIgnoredAncestor(el);
}
function __ldFilterStepNodeList(list){
  try { return Array.from(list || []).filter(el => !__ldIsIgnored(el)); } catch(_) { return Array.from(list || []); }
}
function __ldSetIgnored(el, flag, opts){
  if (!el) return;
  const silent = !!(opts && opts.silent);
  try { if (!silent && typeof historyCaptureNow === 'function') historyCaptureNow(); } catch(_){ __ldSilentErr(_); }
  try {
    if (flag) el.dataset.ldIgnored = '1';
    else delete el.dataset.ldIgnored;
  } catch(_){ __ldSilentErr(_); }
  try { el.classList.toggle('ld-ignored', !!flag); } catch(_){ __ldSilentErr(_); }
}
function __ldRefreshIgnoreCascade(){
  try {
    document.querySelectorAll('.moment-group').forEach(mEl => {
      const self = __ldIsSelfIgnored(mEl);
      const cb = mEl.querySelector('.ld-ignore-toggle[data-ignore-scope="moment"]');
      if (cb) { cb.checked = self; cb.indeterminate = false; cb.disabled = false; }

      mEl.querySelectorAll('.submoment-card, .step-card').forEach(child => {
        const inherited = !__ldIsSelfIgnored(child) && __ldHasIgnoredAncestor(child);
        child.classList.toggle('ld-ignored-inherited', inherited);
        const sc = child.querySelector('.ld-ignore-toggle');
        if (!sc) return;
        if (inherited) {
          sc.checked = true;
          sc.indeterminate = true;
          sc.disabled = true;
        } else {
          sc.disabled = false;
          sc.indeterminate = false;
          sc.checked = __ldIsSelfIgnored(child);
        }
      });
    });

    // Defensive: outside moments (shouldn't happen, but keeps UI consistent)
    document.querySelectorAll('.submoment-card').forEach(smEl => {
      const inherited = !__ldIsSelfIgnored(smEl) && __ldHasIgnoredAncestor(smEl);
      smEl.classList.toggle('ld-ignored-inherited', inherited);
    });
    __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stEl => {
      const inherited = !__ldIsSelfIgnored(stEl) && __ldHasIgnoredAncestor(stEl);
      stEl.classList.toggle('ld-ignored-inherited', inherited);
    });
  } catch(_){ __ldSilentErr(_); }
}

document.addEventListener('change', function(e){
  try {
    const t = e.target;
    if (!t || !t.classList || !t.classList.contains('ld-ignore-toggle')) return;
    const scope = t.dataset ? (t.dataset.ignoreScope || '') : '';
    let host = null;
    if (scope === 'moment') host = t.closest('.moment-group');
    else if (scope === 'submoment') host = t.closest('.submoment-card');
    else host = t.closest('.step-card');
    if (!host) return;

    __ldSetIgnored(host, !!t.checked, { silent: false });
    __ldRefreshIgnoreCascade();
    try { if (typeof updateStatsDebounced === 'function') updateStatsDebounced(); else if (typeof updateStats === 'function') updateStats(); } catch(_){ __ldSilentErr(_); }
    try { if (typeof renderPanoramaView === 'function') renderPanoramaView(); } catch(_){ __ldSilentErr(_); }
  } catch(_){ __ldSilentErr(_); }
}, true);

document.addEventListener('DOMContentLoaded', function(){
  try { __ldRefreshIgnoreCascade(); } catch(_){ __ldSilentErr(_); }
});
/* --- End ignore helpers --- */

function __ldQueryDesignedStepCards(scopeEl) {
  try {
    if (!scopeEl) return [];
    const arr = Array.from(scopeEl.querySelectorAll('.activity-steps-container .step-card, .submoment-steps .step-card'));
    try { return arr.filter(el => !__ldIsIgnored(el)); } catch (_) { return arr; }
  } catch (_) { return []; }
}
try { window.__ldQueryDesignedStepCards = __ldQueryDesignedStepCards; } catch(_){ __ldSilentErr(_); }


function __ldQueryAllDesignedStepCards(scopeEl) {
  try {
    if (!scopeEl) return [];
    return Array.from(scopeEl.querySelectorAll('.activity-steps-container .step-card, .submoment-steps .step-card'));
  } catch (_) { return []; }
}
try { window.__ldQueryAllDesignedStepCards = __ldQueryAllDesignedStepCards; } catch(_){ __ldSilentErr(_); }
// LD_ESCAPE_HTML_GLOBAL_V1
function __esc(s){
  const str = String(s ?? "");
  return str.replace(/[&<>"']/g, function(c){
    switch(c){
      case "&": return "&amp;";
      case "<": return "&lt;";
      case ">": return "&gt;";
      case "\"": return "&quot;";
      case "'": return "&#39;";
      default: return c;
    }
  });
}
try { window.__ldEscapeHtml = __ldEscapeHtml; } catch(_){ __ldSilentErr(_); }
// END_LD_ESCAPE_HTML_GLOBAL_V1

// ---- View level (modules / moments / submoments / activities) ----
// Simplified view level UI update - CSS handles all visual styles via [aria-pressed]
function __ldUpdateViewLevelSegmentedUI(level) {
  const sel = document.getElementById('ld-view-level-select');
  if (!sel) return;
  const normalizedLevel = String(level || '').trim();
  try { sel.value = normalizedLevel; } catch(_){ __ldSilentErr(_); }
}

function applyViewLevel(level) {
  const _lvl = String(level || "").trim();
  const allowed = new Set(['modules','moments','submoments','activities','panorama']);
  const v = allowed.has(_lvl) ? _lvl : 'activities';
  try { document.body.setAttribute('data-view-level', v); } catch(_){ __ldSilentErr(_); }
  try { localStorage.setItem('ld_view_level', v); } catch(_){ __ldSilentErr(_); }
  try { __ldUpdateViewLevelSegmentedUI(v); } catch(_){ __ldSilentErr(_); }

  try { if (v === "panorama") renderPanoramaView(); } catch(_){ __ldSilentErr(_); }
}

// Initialize view level UI on page load
document.addEventListener('DOMContentLoaded', () => {
  // Set initial select state based on saved or default level
  try {
    const savedLevel = localStorage.getItem('ld_view_level') || 'activities';
    applyViewLevel(savedLevel); // Apply the view level (sets body attribute and updates UI)
  } catch(_){ __ldSilentErr(_); }
}, { once: true });

// ---- Panorama view (tableau compact) ----
function __ldGetSelectedOptionText(sel) {
  try { return sel && sel.selectedIndex >= 0 ? (sel.options[sel.selectedIndex]?.text || '') : ''; } catch (_) { return ''; }
}

// Panorama: sélection + tri (persistés)
let __ldPanoramaSelected = new Set();
let __ldPanoramaVisibleIds = [];
let __ldPanoSortKey = 'n';
let __ldPanoSortDir = 'asc';

function __ldLoadPanoramaPrefs(){
  try {
    const k = localStorage.getItem('ld_panorama_sort_key');
    const d = localStorage.getItem('ld_panorama_sort_dir');
    if (k) __ldPanoSortKey = k;
    if (d === 'asc' || d === 'desc') __ldPanoSortDir = d;
  } catch(_){ __ldSilentErr(_); }
}

function __ldSavePanoramaSort(){
  try {
    localStorage.setItem('ld_panorama_sort_key', String(__ldPanoSortKey || 'n'));
    localStorage.setItem('ld_panorama_sort_dir', String(__ldPanoSortDir || 'asc'));
  } catch(_){ __ldSilentErr(_); }
}

function __ldPanoStatusLabel(st){
  const v = (typeof normaliseStepStatus === 'function') ? normaliseStepStatus(st) : String(st || '').trim();
  if (v === 'done') return 'Finalisé';
  if (v === 'review') return 'À revoir';
  return 'En cours';
}

function __ldPanoStatusRank(st){
  const v = (typeof normaliseStepStatus === 'function') ? normaliseStepStatus(st) : String(st || '').trim();
  // Priorité: À revoir → En cours → Finalisé
  if (v === 'review') return 0;
  if (v === 'in_progress') return 1;
  if (v === 'done') return 2;
  return 9;
}

function __ldPanoStr(x){
  return String(x ?? '').trim();
}

function __ldPanoCompare(a, b, key){
  const k = String(key || 'n');
  if (k === 'n') return (Number(a?.n || 0) - Number(b?.n || 0));
  if (k === 'duree') return (Number(a?.dureeSecs || 0) - Number(b?.dureeSecs || 0));
  if (k === 'status') {
    const r = __ldPanoStatusRank(a?.status) - __ldPanoStatusRank(b?.status);
    if (r !== 0) return r;
    // Tie-breaker: activité
    return __ldPanoStr(a?.activite).localeCompare(__ldPanoStr(b?.activite), 'fr', { sensitivity: 'base' });
  }
  if (k === 'module') return __ldPanoStr(a?.module).localeCompare(__ldPanoStr(b?.module), 'fr', { sensitivity: 'base' });
  if (k === 'moment') return __ldPanoStr(a?.moment).localeCompare(__ldPanoStr(b?.moment), 'fr', { sensitivity: 'base' });
  if (k === 'bloc') return __ldPanoStr(a?.bloc).localeCompare(__ldPanoStr(b?.bloc), 'fr', { sensitivity: 'base' });
  if (k === 'activite') return __ldPanoStr(a?.activite).localeCompare(__ldPanoStr(b?.activite), 'fr', { sensitivity: 'base' });
  return 0;
}

function __ldUpdatePanoramaSortIndicators(){
  try {
    document.querySelectorAll('#panorama-table th[data-sort-key]').forEach(th => {
      const key = th.getAttribute('data-sort-key');
      const ind = th.querySelector('.pano-sort-ind');
      if (!ind) return;
      if (String(key) === String(__ldPanoSortKey)) ind.textContent = (__ldPanoSortDir === 'desc') ? '▼' : '▲';
      else ind.textContent = '';
    });
  } catch(_){ __ldSilentErr(_); }
}

function __ldUpdatePanoramaBatchUI(){
  try {
    const countEl = document.getElementById('panorama-selected-count');
    if (countEl) countEl.textContent = String(__ldPanoramaSelected.size);

    const applyBtn = document.getElementById('panorama-batch-apply');
    const clearBtn = document.getElementById('panorama-batch-clear');

    const hasSel = __ldPanoramaSelected.size > 0;
    if (applyBtn) applyBtn.disabled = !hasSel;
    if (clearBtn) clearBtn.disabled = !hasSel;

    // Select all checkbox (checked / indeterminate)
    const selAll = document.getElementById('panorama-select-all');
    if (selAll) {
      const vis = Array.isArray(__ldPanoramaVisibleIds) ? __ldPanoramaVisibleIds : [];
      const any = vis.some(id => __ldPanoramaSelected.has(id));
      const all = vis.length > 0 && vis.every(id => __ldPanoramaSelected.has(id));
      selAll.checked = all;
      selAll.indeterminate = any && !all;
    }
  } catch(_){ __ldSilentErr(_); }
}

function __ldFindStepByPanoId(panoId){
  if (!panoId) return null;
  try {
    const id = String(panoId);
    if (window.CSS && typeof CSS.escape === 'function') {
      return document.querySelector(`.step-card[data-pano-id="${CSS.escape(id)}"]`);
    }
    return document.querySelector(`.step-card[data-pano-id="${id.replace(/"/g, '\"')}"]`);
  } catch (_) {
    return document.querySelector(`.step-card[data-pano-id="${panoId}"]`);
  }
}

function __ldPanoramaApplyStatusToIds(ids, statusKey){
  const st = (typeof normaliseStepStatus === 'function') ? normaliseStepStatus(statusKey) : String(statusKey || 'in_progress');
  const arr = Array.isArray(ids) ? ids : [];
  if (!arr.length) return;

  try { historyCaptureNow(); } catch(_){ __ldSilentErr(_); }

  arr.forEach(pid => {
    const stepEl = __ldFindStepByPanoId(pid);
    if (!stepEl) return;
    try { applyStepStatus(stepEl, st); } catch(_){ __ldSilentErr(_); }
  });

  try { __ldUpdateAllStatusSummariesDebounced(); } catch(_){ __ldSilentErr(_); }
  try { updateStatsDebounced(); } catch(_){ __ldSilentErr(_); }
  try { __ldApplyStatusFilterDebounced(); } catch(_){ __ldSilentErr(_); }

  try { renderPanoramaView(); } catch(_){ __ldSilentErr(_); }
}

function buildPanoramaRowsFromDOM() {
  const rows = [];
  const root = document.getElementById('activities-root');
  if (!root) return rows;

  const modules = Array.from(root.querySelectorAll('.activity-group'));
  let counter = 0;

  modules.forEach((modEl, mIdx) => {
    const modTitle = (modEl.querySelector('.activity-title')?.value || modEl.querySelector('.module-title')?.value || `Module ${mIdx+1}`).trim();

    const moments = Array.from(modEl.querySelectorAll('.activity-moments-container .moment-group')).filter(m => !__ldIsIgnored(m));
    if (!moments.length) return;

    moments.forEach((momentEl, moIdx) => {
      const moTitle = (momentEl.querySelector('.moment-title')?.value || `Moment ${moIdx+1}`).trim();

      // Sub-moments
      const subs = Array.from(momentEl.querySelectorAll('.submoments-container .submoment-card')).filter(sm => !__ldIsIgnored(sm));
      if (subs.length) {
        subs.forEach((smEl, smIdx) => {
          const smTitle = (smEl.querySelector('.submoment-title')?.value || '').trim();
          const steps = Array.from(__ldFilterStepNodeList(smEl.querySelectorAll('.step-card'))).filter(st => !__ldIsIgnored(st));
          steps.forEach((stepEl, sIdx) => {
            counter += 1;
            const stTitle = (stepEl.querySelector('.step-input-title')?.value || `Activité ${sIdx+1}`).trim();

            let durTxt = '';
            let durSecs = 0;
            try {
              durSecs = (typeof getStepDurationSecs === 'function') ? getStepDurationSecs(stepEl) : 0;
              durTxt = (typeof formatTimelineDuration === 'function') ? formatTimelineDuration(durSecs) : '';
            } catch(_){ __ldSilentErr(_); }

            if (!stepEl.dataset.panoId) stepEl.dataset.panoId = `pano_${Date.now()}_${Math.random().toString(16).slice(2)}`;

            rows.push({
              n: counter,
              module: modTitle,
              moment: moTitle,
              bloc: smTitle,
              activite: stTitle,
              duree: durTxt,
              dureeSecs: durSecs,
              status: (typeof getStepStatus === 'function') ? getStepStatus(stepEl) : (stepEl?.dataset?.status || 'in_progress'),
              panoId: stepEl.dataset.panoId
            });
          });
        });
      }

      // Direct steps in moment (no sub-moment)
      const directSteps = Array.from(momentEl.querySelectorAll('.moment-direct-steps .step-card')).filter(st => !__ldIsIgnored(st));
      if (directSteps.length) {
        directSteps.forEach((stepEl, sIdx) => {
          counter += 1;
          const stTitle = (stepEl.querySelector('.step-input-title')?.value || `Activité ${sIdx+1}`).trim();

          let durTxt = '';
          let durSecs = 0;
          try {
            durSecs = (typeof getStepDurationSecs === 'function') ? getStepDurationSecs(stepEl) : 0;
            durTxt = (typeof formatTimelineDuration === 'function') ? formatTimelineDuration(durSecs) : '';
          } catch(_){ __ldSilentErr(_); }

          if (!stepEl.dataset.panoId) stepEl.dataset.panoId = `pano_${Date.now()}_${Math.random().toString(16).slice(2)}`;

          rows.push({
            n: counter,
            module: modTitle,
            moment: moTitle,
            bloc: '',
            activite: stTitle,
            duree: durTxt,
            dureeSecs: durSecs,
            status: (typeof getStepStatus === 'function') ? getStepStatus(stepEl) : (stepEl?.dataset?.status || 'in_progress'),
            panoId: stepEl.dataset.panoId
          });
        });
      }
    });
  });

  return rows;
}

function renderPanoramaView() {
  const wrap = document.getElementById('panorama-view');
  const tbody = document.getElementById('panorama-tbody');
  if (!wrap || !tbody) return;

  // Sync panorama state filter with the global status filter (one source of truth)
  try {
    const panoSel = document.getElementById('panorama-status-filter');
    if (panoSel && typeof __ldGetStatusFilterValue === 'function') panoSel.value = __ldGetStatusFilterValue();
  } catch(_){ __ldSilentErr(_); }

  const filterVal = (document.getElementById('panorama-filter')?.value || '').trim().toLowerCase();
  const statusFilter = (typeof __ldGetStatusFilterValue === 'function') ? __ldGetStatusFilterValue() : 'all';

  const rows = buildPanoramaRowsFromDOM();

  const __esc = (typeof __ldEscapeHtml === 'function') ? __ldEscapeHtml : ((window && window.__ldEscapeHtml) ? window.__ldEscapeHtml : (x => String(x ?? '')));

  // Banding par module : alternance très légère sur les lignes d’un même module
  let __lastMod = null;
  let __idxInMod = 0;
  rows.forEach(rr => {
    const cur = String(rr.module || '');
    if (cur !== __lastMod) { __idxInMod = 0; __lastMod = cur; }
    rr._band = (__idxInMod % 2 === 0) ? 'a' : 'b';
    __idxInMod += 1;
  });

  // Filter (état + texte)
  const filtered = rows.filter(r => {
    if (statusFilter && statusFilter !== 'all') {
      let st = 'in_progress';
      try { st = (typeof normaliseStepStatus === 'function') ? normaliseStepStatus(r.status) : String(r.status || '').trim(); } catch(_){ __ldSilentErr(_); }
      if (st !== statusFilter) return false;
    }
    if (!filterVal) return true;
    const hay = `${r.module} ${r.moment} ${r.bloc} ${r.activite} ${r.duree} ${__ldPanoStatusLabel(r.status)}`.toLowerCase();
    return hay.includes(filterVal);
  });

  // Sort
  try {
    const dir = (__ldPanoSortDir === 'desc') ? -1 : 1;
    filtered.sort((a, b) => dir * __ldPanoCompare(a, b, __ldPanoSortKey));
  } catch(_){ __ldSilentErr(_); }

  // Visible IDs (for "select all" behaviour)
  __ldPanoramaVisibleIds = filtered.map(r => r.panoId).filter(Boolean);

  tbody.innerHTML = '';
  const frag = document.createDocumentFragment();

  filtered.forEach(r => {
    const tr = document.createElement('tr');

    // Banding by module (alternating group background)
    const bandClass = (r && r._band === 'a') ? 'pano-band-a' : 'pano-band-b';
    tr.className = bandClass;

    const modTxt = r.module ? __esc(r.module) : '<span class="muted">—</span>';
    const moTxt = r.moment ? __esc(r.moment) : '<span class="muted">—</span>';
    const smTxt = r.bloc ? __esc(r.bloc) : '<span class="muted">—</span>';
    const actTxt = r.activite ? __esc(r.activite) : '<span class="muted">—</span>';
    const durTxt = r.duree ? __esc(r.duree) : '<span class="muted">—</span>';

    const modCell = `<span class="pano-text font-semibold">${modTxt}</span>`;
    const moCell = `<span class="pano-text">${moTxt}</span>`;
    const smCell = r.bloc ? `<span class="pano-text">${smTxt}</span>` : `${smTxt}`;

    const stKey = (typeof normaliseStepStatus === 'function') ? normaliseStepStatus(r.status) : String(r.status || 'in_progress');
    const isChecked = __ldPanoramaSelected.has(r.panoId);

    tr.innerHTML = `
      <td class="px-2 py-1 pano-col-select">
        <input type="checkbox" class="pano-select align-middle" data-pano-select="${r.panoId}" ${isChecked ? 'checked' : ''} title="Sélectionner cette ligne"/>
      </td>
      <td class="px-2 py-1 text-slate-500 font-semibold">${r.n}</td>
      <td class="px-2 py-1">${modCell}</td>
      <td class="px-2 py-1">${moCell}</td>
      <td class="px-2 py-1">${smCell}</td>
      <td class="px-2 py-1">${actTxt}</td>
      <td class="px-2 py-1 pano-col-status">
        <select class="pano-status-select h-[22px] px-1.5 text-[11px] font-semibold border border-slate-200 rounded bg-white outline-none focus:ring-2 focus:ring-indigo-200" data-pano-status="${r.panoId}" aria-label="État" title="Modifier l’état">
          <option value="review" ${stKey==='review' ? 'selected' : ''}>À revoir</option>
          <option value="in_progress" ${stKey==='in_progress' ? 'selected' : ''}>En cours</option>
          <option value="done" ${stKey==='done' ? 'selected' : ''}>Finalisé</option>
        </select>
      </td>
      <td class="px-2 py-1 font-semibold pano-col-duration">${durTxt}</td>
      <td class="px-2 py-1">
        <button type="button" class="pano-open text-xs font-extrabold hover:underline" data-pano-open="${r.panoId}">Aller</button>
      </td>
    `;
    frag.appendChild(tr);
  });

  tbody.appendChild(frag);

  __ldUpdatePanoramaSortIndicators();
  __ldUpdatePanoramaBatchUI();
}

function focusStepByPanoId(panoId) {
  if (!panoId) return;
  const stepEl = __ldFindStepByPanoId(panoId);
  if (!stepEl) return;

  // switch back to detailed view for editing
  try { applyViewLevel('activities'); } catch(_){ __ldSilentErr(_); }
  setTimeout(() => {
    try {
      stepEl.classList.add('ld-panorama-highlight');
      stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => { try { stepEl.classList.remove('ld-panorama-highlight'); } catch(_){ __ldSilentErr(_); } }, 1600);
    } catch(_){ __ldSilentErr(_); }
  }, 50);
}

function initPanoramaUI() {
  const wrap = document.getElementById('panorama-view');
  if (!wrap) return;

  __ldLoadPanoramaPrefs();

  const refreshBtn = document.getElementById('panorama-refresh');
  const filterInput = document.getElementById('panorama-filter');
  const statusSel = document.getElementById('panorama-status-filter');
  const batchSel = document.getElementById('panorama-batch-status');
  const batchApply = document.getElementById('panorama-batch-apply');
  const batchClear = document.getElementById('panorama-batch-clear');
  const table = document.getElementById('panorama-table');

  if (refreshBtn) refreshBtn.addEventListener('click', () => renderPanoramaView());
  if (filterInput) filterInput.addEventListener('input', () => renderPanoramaView());

  // Filtrer par état depuis Panorama (agit sur le filtre global pour rester cohérent)
  if (statusSel) {
    statusSel.addEventListener('change', () => {
      const v = String(statusSel.value || 'all').trim();
      try { if (typeof __ldSetStatusFilterValue === 'function') __ldSetStatusFilterValue(v); } catch(_){ __ldSilentErr(_); }
      try { if (typeof __ldApplyStatusFilterDebounced === 'function') __ldApplyStatusFilterDebounced(); } catch(_){ __ldSilentErr(_); }
      try { renderPanoramaView(); } catch(_){ __ldSilentErr(_); }
    });
  }

  // Batch status apply / clear selection
  if (batchApply) {
    batchApply.addEventListener('click', () => {
      const v = String(batchSel?.value || 'in_progress').trim();
      __ldPanoramaApplyStatusToIds(Array.from(__ldPanoramaSelected), v);
    });
  }
  if (batchClear) {
    batchClear.addEventListener('click', () => {
      __ldPanoramaSelected = new Set();
      __ldUpdatePanoramaBatchUI();
      try { renderPanoramaView(); } catch(_){ __ldSilentErr(_); }
    });
  }

  if (table) {
    // Click: tri (en-têtes) + aller
    table.addEventListener('click', (e) => {
      // Open
      const btn = e.target && e.target.closest ? e.target.closest('[data-pano-open]') : null;
      if (btn) {
        focusStepByPanoId(btn.getAttribute('data-pano-open'));
        return;
      }

      // Sort
      const th = e.target && e.target.closest ? e.target.closest('th[data-sort-key]') : null;
      if (th && !e.target?.closest?.('input')) {
        const key = String(th.getAttribute('data-sort-key') || '').trim();
        if (!key) return;
        if (key === __ldPanoSortKey) __ldPanoSortDir = (__ldPanoSortDir === 'asc') ? 'desc' : 'asc';
        else { __ldPanoSortKey = key; __ldPanoSortDir = 'asc'; }
        __ldSavePanoramaSort();
        renderPanoramaView();
      }
    });

    // Change: sélection + édition d’état
    table.addEventListener('change', (e) => {
      const t = e.target;

      // Select all visible
      if (t && t.id === 'panorama-select-all') {
        const check = !!t.checked;
        const vis = Array.isArray(__ldPanoramaVisibleIds) ? __ldPanoramaVisibleIds : [];
        if (check) vis.forEach(id => __ldPanoramaSelected.add(id));
        else vis.forEach(id => __ldPanoramaSelected.delete(id));
        __ldUpdatePanoramaBatchUI();
        try { renderPanoramaView(); } catch(_){ __ldSilentErr(_); }
        return;
      }

      // Row checkbox
      if (t && t.classList && t.classList.contains('pano-select')) {
        const pid = t.getAttribute('data-pano-select');
        if (t.checked) __ldPanoramaSelected.add(pid);
        else __ldPanoramaSelected.delete(pid);
        __ldUpdatePanoramaBatchUI();
        return;
      }

      // Row status select
      if (t && t.classList && t.classList.contains('pano-status-select')) {
        const pid = t.getAttribute('data-pano-status');
        const v = String(t.value || 'in_progress').trim();
        __ldPanoramaApplyStatusToIds([pid], v);
        return;
      }
    });
  }

  // Init UI state
  __ldUpdatePanoramaBatchUI();
  try { renderPanoramaView(); } catch(_){ __ldSilentErr(_); }
}
// ---- End Panorama view ----

function initViewLevelSegmentedUI() {
  const sel = document.getElementById('ld-view-level-select');
  if (!sel) return;

  // Guard against multiple initialisations (called from several init paths)
  if (sel.dataset && sel.dataset.boundViewLevel === '1') return;
  if (sel.dataset) sel.dataset.boundViewLevel = '1';

  let saved = null;
  try { saved = localStorage.getItem('ld_view_level'); } catch(_){ __ldSilentErr(_); }
  const initial = saved || 'activities';
  applyViewLevel(initial);

  sel.addEventListener('change', () => {
    const lvl = String(sel.value || 'activities').trim();
    applyViewLevel(lvl);
  });
}
        const emptyState = document.getElementById('empty-state');
        const activityTemplate = document.getElementById('activity-template');
        const momentTemplate = document.getElementById('moment-template');
        const stepTemplate = document.getElementById('step-template');
        const submomentTemplate = document.getElementById('submoment-template');
        let tooltipEl = null;
        function getTooltipEl() {
            if (tooltipEl && tooltipEl.nodeType === 1) return tooltipEl;
            tooltipEl = document.getElementById('global-tooltip');
            return tooltipEl;
        }
        const DEFAULT_LANG = 'fr';
        let currentLang = DEFAULT_LANG;
        let loadedLangCode = null;

        // ------------------------------
        // Import diagnostics (global, safe)
        // Ensures import errors are reportable even when the payload cannot be loaded.
        // ------------------------------
        (function(){
            if (window.__ld_importDiagReady) return;
            window.__ld_importDiagReady = true;

            window.__lastImportReport = null;
            window.__lastImportParsedObject = null;
            window.__lastImportRawJson = null;

            function __esc(s){
                return String(s ?? '').replace(/[&<>"']/g, function(ch){
                    return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]) || ch;
                });
            }

            function __ldI18n(key, fallback){
                try {
                    const pack = (typeof translations !== 'undefined' && translations && translations[currentLang])
                        ? translations[currentLang]
                        : (typeof translations !== 'undefined' && translations && translations.fr ? translations.fr : null);
                    const v = pack ? pack[key] : null;
                    return (typeof v === 'string' && v.length) ? v : (fallback || '');
                } catch (_) { return fallback || ''; }
            }

            function __ldSummariseKeys(obj, limit){
                try {
                    if (!obj || typeof obj !== 'object') return [];
                    const keys = Object.keys(obj);
                    const lim = Number.isFinite(limit) ? limit : 18;
                    return (keys.length <= lim) ? keys : keys.slice(0, lim).concat([`…(+${keys.length - lim})`]);
                } catch (_) { return []; }
            }

            function __ldAnalyseShape(obj){
                const shape = { type: (obj === null) ? 'null' : (Array.isArray(obj) ? 'array' : typeof obj), rootKeys: __ldSummariseKeys(obj, 18), flags: {} };
                if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return shape;

                const p = (obj.project || obj.data || obj.conception || obj.learningDesign || obj);
                shape.flags.hasProjectWrapper = !!(obj.project || obj.data || obj.conception || obj.learningDesign);

                try {
                    const keys = Object.keys(p || {});
                    const has = (k) => keys.includes(k);
                    shape.flags.hasActivities = has('activities') || has('activites') || has('modules');
                    shape.flags.hasKeyParams = has('keyParams') || has('parametres') || has('parameters') || has('params');
                    shape.flags.hasI18n = has('i18n') || has('languagePack') || has('langPack');
                    shape.flags.hasSchemaVersion = has('schemaVersion') || has('schema') || has('version');
                    shape.flags.schemaVersionValue = (p && (p.schemaVersion ?? p.schema ?? p.version)) ?? null;
                    shape.flags.looksLikeSlides = has('slides') || has('pptx') || has('presentation');
                    shape.flags.looksLikeGraph = has('nodes') || has('edges');
                } catch(_){ __ldSilentErr(_); }
                return shape;
            }

            window.__ld_buildImportReport = function ({ file = null, stage = 'unknown', error = null, parsedObject = null } = {}) {
                const now = new Date();
                const errObj = (error && typeof error === 'object') ? {
                    name: error.name || 'Error',
                    message: error.message || String(error),
                    stack: (typeof error.stack === 'string') ? error.stack.split('\n').slice(0, 10).join('\n') : ''
                } : (error ? { name: 'Error', message: String(error), stack: '' } : null);

                const shape = __ldAnalyseShape(parsedObject);

                return {
                    kind: 'import_report',
                    generatedAt: now.toISOString(),
                    stage,
                    file: file ? {
                        name: file.name || '',
                        size: file.size ?? null,
                        type: file.type || '',
                        lastModified: file.lastModified ? new Date(file.lastModified).toISOString() : null
                    } : null,
                    error: errObj,
                    detected: shape,
                    ui: {
                        title: document && document.title ? document.title : '',
                        url: (typeof location !== 'undefined' && location && location.href) ? location.href : '',
                        userAgent: (typeof navigator !== 'undefined' && navigator && navigator.userAgent) ? navigator.userAgent : ''
                    }
                };
            };

            function __ldDownloadText(filename, text, mime){
                const blob = new Blob([String(text ?? '')], { type: mime || 'text/plain;charset=utf-8' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { try { URL.revokeObjectURL(a.href); } catch(_){ __ldSilentErr(_); } try { a.remove(); } catch(_){ __ldSilentErr(_); } }, 0);
            }

            async function __ldCopyToClipboard(text){
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.setAttribute('readonly', '');
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                ta.style.top = '0';
                document.body.appendChild(ta);
                ta.select();
                ta.setSelectionRange(0, ta.value.length);
                let ok = false;
                try { ok = document.execCommand('copy'); } catch(_) { ok = false; }
                ta.remove();
                if (!ok) throw new Error('copy_failed');
                return true;
            }

            window.__ld_closeImportErrorModal = function(){
                const modal = document.getElementById('import-error-modal');
                if (modal) modal.classList.add('hidden');
            };

            window.__ld_downloadLastImportReport = function(){
                if (!window.__lastImportReport) return;
                const stamp = (new Date()).toISOString().slice(0,19).replace(/[:T]/g,'-');
                __ldDownloadText(`rapport_import_${stamp}.json`, JSON.stringify(window.__lastImportReport, null, 2), 'application/json;charset=utf-8');
            };

            window.__ld_copyLastImportDiagnostic = async function(){
                if (!window.__lastImportReport) return;
                const header = 'IMPORT_DIAGNOSTIC\n';
                const payload = JSON.stringify(window.__lastImportReport, null, 2);
                await __ldCopyToClipboard(header + payload);
            };

            window.__ld_downloadLastImportRecovery = function(){
                const obj = window.__lastImportParsedObject;
                if (!obj) return;
                const stamp = (new Date()).toISOString().slice(0,19).replace(/[:T]/g,'-');
                __ldDownloadText(`recuperation_import_${stamp}.json`, JSON.stringify(obj, null, 2), 'application/json;charset=utf-8');
            };

            window.__ld_copyLastImportRecovery = async function(){
                const obj = window.__lastImportParsedObject;
                if (!obj) return;
                const header = 'IMPORT_RECOVERY_JSON\n';
                await __ldCopyToClipboard(header + JSON.stringify(obj, null, 2));
            };

            window.__ld_showImportError = function(report){
                window.__lastImportReport = report || null;

                const modal = document.getElementById('import-error-modal');
                const body = document.getElementById('import-error-body');
                const btnDl = document.getElementById('import-error-download');
                const btnCopy = document.getElementById('import-error-copy');
                const btnCopyRec = document.getElementById('import-error-copy-recovery');
                const btnRec = document.getElementById('import-error-recover');

                if (!modal || !body) {
                    try { alert(__ldI18n('import_error_cause_generic', 'Import impossible.')); } catch(_){ __ldSilentErr(_); }
                    return;
                }

                const stage = (report && report.stage) ? report.stage : 'unknown';
                const errMsg = (report && report.error && report.error.message) ? report.error.message : '';
                const keys = (report && report.detected && Array.isArray(report.detected.rootKeys)) ? report.detected.rootKeys : [];
                const flags = (report && report.detected && report.detected.flags) ? report.detected.flags : {};

                const parts = [];
                parts.push(`<div class="text-sm font-semibold text-slate-800">${__esc(__ldI18n('import_error_title', 'Import impossible'))}</div>`);
                parts.push(`<div class="text-xs text-slate-500 mt-1">${__esc(__ldI18n('import_error_stage', 'Étape'))}: <span class="font-semibold text-slate-700">${__esc(stage)}</span></div>`);
                if (errMsg) parts.push(`<div class="mt-2 text-sm text-red-700"><span class="font-semibold">${__esc(__ldI18n('import_error_details', 'Détails'))}:</span> ${__esc(errMsg)}</div>`);
                if (keys.length) parts.push(`<div class="mt-2 text-xs text-slate-600"><span class="font-semibold">${__esc(__ldI18n('import_error_detected', 'Détecté'))}:</span> ${__esc(keys.join(', '))}</div>`);

                const hintBits = [];
                try {
                    if (flags.hasProjectWrapper) hintBits.push('wrapper');
                    if (flags.hasActivities) hintBits.push('activities');
                    if (flags.hasKeyParams) hintBits.push('keyParams');
                    if (flags.hasI18n) hintBits.push('i18n');
                    if (flags.looksLikeSlides) hintBits.push('slides');
                    if (flags.looksLikeGraph) hintBits.push('graph');
                } catch(_){ __ldSilentErr(_); }
                if (hintBits.length) parts.push(`<div class="mt-1 text-xs text-slate-500">${__esc(__ldI18n('import_error_hints', 'Indices'))}: ${__esc(hintBits.join(', '))}</div>`);

                body.innerHTML = parts.join('');

                if (btnDl) btnDl.disabled = !window.__lastImportReport;
                if (btnCopy) btnCopy.disabled = !window.__lastImportReport;

                const hasRec = !!window.__lastImportParsedObject;
                if (btnRec) btnRec.classList.toggle('hidden', !hasRec);
                if (btnCopyRec) btnCopyRec.classList.toggle('hidden', !hasRec);

                modal.classList.remove('hidden');
            };

            function __ldBindImportModal(){
                const modal = document.getElementById('import-error-modal');
                const closeBtn = document.getElementById('import-error-close');
                const dlBtn = document.getElementById('import-error-download');
                const copyBtn = document.getElementById('import-error-copy');
                const copyRecBtn = document.getElementById('import-error-copy-recovery');
                const recBtn = document.getElementById('import-error-recover');

                if (modal && modal.dataset && modal.dataset.ldBound === '1') return;
                if (modal && modal.dataset) modal.dataset.ldBound = '1';

                if (closeBtn) closeBtn.addEventListener('click', window.__ld_closeImportErrorModal);
                if (dlBtn) dlBtn.addEventListener('click', window.__ld_downloadLastImportReport);
                if (copyBtn) copyBtn.addEventListener('click', () => { window.__ld_copyLastImportDiagnostic().catch(()=>{}); });
                if (copyRecBtn) copyRecBtn.addEventListener('click', () => { window.__ld_copyLastImportRecovery().catch(()=>{}); });
                if (recBtn) recBtn.addEventListener('click', window.__ld_downloadLastImportRecovery);

                if (modal) {
                    modal.addEventListener('click', (e) => { if (e.target === modal) window.__ld_closeImportErrorModal(); });
                    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !modal.classList.contains('hidden')) window.__ld_closeImportErrorModal(); });
                }
            }

            // Bind immediately if DOM is already ready, otherwise wait.
            if (document.readyState === 'loading') window.addEventListener('DOMContentLoaded', __ldBindImportModal);
            else __ldBindImportModal();

        })();
        
        let loadedLangPackRaw = null;

        let __confirmAction = null;

        // Wire the custom confirmation modal buttons (Annuler / Supprimer)
        // so they reliably trigger the pending action set by trashModule().
        (function initCustomConfirmModal() {
            const modal = document.getElementById('custom-confirm-modal');
            const btnNo = document.getElementById('custom-confirm-no');
            const btnYes = document.getElementById('custom-confirm-yes');
            if (!modal || !btnNo || !btnYes) return;

            const close = () => {
                modal.classList.add('hidden');
            };

            btnNo.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                __confirmAction = null;
                close();
            });

            btnYes.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const action = __confirmAction;
                __confirmAction = null;
                close();
                if (typeof action === 'function') action();
            });

            // Optional: click outside the dialog cancels
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    e.preventDefault();
                    e.stopPropagation();
                    __confirmAction = null;
                    close();
                }
            });

            // Optional: Escape closes the modal
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
                    __confirmAction = null;
                    close();
                }
            });
        })();
        
        


        
        function showJsErrorBanner(message) {
            const el = document.getElementById('js-error-banner');
            if (!el) return;
            el.style.display = 'block';
            el.querySelector('[data-js-error-text]').innerText = message;
            try { if (window.__uiDiagLogError) window.__uiDiagLogError(String(message || 'Erreur'), 'banner'); } catch(_){ __ldSilentErr(_); }
        }

        


        


        function safeAddOutcome() {
            const input = document.getElementById('new-outcome-input');
            try {
                
                if (input && !input.value.trim()) {
                    input.setCustomValidity("Saisissez un résultat avant d'ajouter.");
                    input.reportValidity();
                    input.focus();
                    input.setCustomValidity('');
                    return;
                }
                addOutcome();
            } catch (err) {

                showJsErrorBanner('Erreur lors de l\'ajout du résultat : ' + (err && err.message ? err.message : String(err)));
            }
        }


        

        // --- Key params: Objectifs (liste) & Résultats (texte) (liste) ---
        function _getListTextLinesFromContainer(container, selector) {
            if (!container) return [];
            const out = [];
            container.querySelectorAll(selector).forEach(sp => {
                const s = String(sp.textContent || '').trim();
                if (s) out.push(s);
            });
            return out;
        }

        function _setNoDataTextVisible(el, isEmpty) {
            if (!el) return;
            el.style.display = isEmpty ? '' : 'none';
        }

        function _formatCatSubItemLine(cat, sub, item) {
            const c = String(cat || '').trim();
            const s = String(sub || '').trim();
            const it = String(item || '').trim();
            if (!it) return '';
            if (!c && !s) return it;
            if (c && !s) return `${c} — ${it}`;
            if (!c && s) return `${s} — ${it}`;
            return `${c} / ${s} — ${it}`;
        }

        function getAimsItemsFromUI() {
            const list = document.getElementById('aims-list');
            if (!list) return [];
            const out = [];
            list.querySelectorAll('li').forEach(li => {
                const cat = (li.querySelector('.aim-cat-input')?.value || li.getAttribute('data-cat') || '').trim();
                const sub = (li.querySelector('.aim-subcat-input')?.value || li.getAttribute('data-subcat') || '').trim();
                const item = (li.querySelector('.aim-item-input')?.value || li.getAttribute('data-item') || '').trim();
                if (!item) return;
                out.push({ categorie: cat, sousCategorie: sub, item });
            });
            return out;
        }

        function syncAimsTextareaFromList() {
            const ta = document.getElementById('param-aims');
            const list = document.getElementById('aims-list');
            if (!ta || !list) return;
            const items = getAimsItemsFromUI();
            const lines = items.map(o => _formatCatSubItemLine(o.categorie, o.sousCategorie, o.item)).filter(Boolean);
            ta.value = lines.join('\n');
            _setNoDataTextVisible(document.getElementById('no-aims-text'), lines.length === 0);
            try { updateStatsDebounced(); } catch(_){ __ldSilentErr(_); }
            try { refreshAllStepToolsMaterialsOptions(); } catch(_){ __ldSilentErr(_); }
        }


        function getOutcomesTextItemsFromUI() {
            const list = document.getElementById('outcomes-text-list');
            if (!list) return [];
            const out = [];
            list.querySelectorAll('li').forEach(li => {
                const cat = (li.querySelector('.outcomes-cat-input')?.value || li.getAttribute('data-cat') || '').trim();
                const sub = (li.querySelector('.outcomes-subcat-input')?.value || li.getAttribute('data-subcat') || '').trim();
                const item = (li.querySelector('.outcomes-item-input')?.value || li.getAttribute('data-item') || '').trim();
                if (!item) return;
                out.push({ categorie: cat, sousCategorie: sub, item });
            });
            return out;
        }

        function syncOutcomesTextTextareaFromList() {
            const ta = document.getElementById('param-outcomes-text');
            const list = document.getElementById('outcomes-text-list');
            if (!ta || !list) return;
            const items = getOutcomesTextItemsFromUI();
            const lines = items.map(o => _formatCatSubItemLine(o.categorie, o.sousCategorie, o.item)).filter(Boolean);
            ta.value = lines.join('\n');
            _setNoDataTextVisible(document.getElementById('no-outcomes-text-text'), lines.length === 0);
            try { updateStatsDebounced(); } catch(_){ __ldSilentErr(_); }
        }


        

        

        // --- Outils & matériel (liste catégorisée optionnelle) ---
        function getToolsMaterialsItemsFromUI() {
            const list = document.getElementById('tools-materials-list');
            if (!list) return [];
            const out = [];
            list.querySelectorAll('li').forEach(li => {
                const cat = (li.querySelector('.tm-cat-input')?.value || li.getAttribute('data-cat') || '').trim();
                const sub = (li.querySelector('.tm-subcat-input')?.value || li.getAttribute('data-subcat') || '').trim();
                const item = (li.querySelector('.tm-item-input')?.value || li.getAttribute('data-item') || '').trim();
                if (!item) return;
                out.push({ categorie: cat, sousCategorie: sub, item });
            });
            return out;
        }

        function refreshToolsMaterialsDatalists() {
            try {
                const items = getToolsMaterialsItemsFromUI();
                const cats = new Set();
                const subs = new Set();
                items.forEach(o => {
                    const c = String(o?.categorie || '').trim();
                    const s = String(o?.sousCategorie || '').trim();
                    if (c) cats.add(c);
                    if (s) subs.add(s);
                });
                const catDl = document.getElementById('tools-materials-cat-datalist');
                const subDl = document.getElementById('tools-materials-subcat-datalist');
                if (catDl) catDl.innerHTML = Array.from(cats).sort().map(v => `<option value="${escapeHtml(v)}"></option>`).join('');
                if (subDl) subDl.innerHTML = Array.from(subs).sort().map(v => `<option value="${escapeHtml(v)}"></option>`).join('');
            } catch(_){ __ldSilentErr(_); }
        }

        function syncToolsMaterialsTextareaFromList() {
            const ta = document.getElementById('param-tools-materials');
            const list = document.getElementById('tools-materials-list');
            if (!ta || !list) return;
            const items = getToolsMaterialsItemsFromUI();
            const lines = items.map(o => _formatCatSubItemLine(o.categorie, o.sousCategorie, o.item)).filter(Boolean);
            ta.value = lines.join('\n');
            _setNoDataTextVisible(document.getElementById('no-tools-materials-text'), lines.length === 0);
            refreshToolsMaterialsDatalists();
            try { updateStatsDebounced(); } catch(_){ __ldSilentErr(_); }
        }

        function addToolsMaterialsItem(obj) {
            const list = document.getElementById('tools-materials-list');
            if (!list) return;
            const cat = (obj && (obj.categorie ?? obj.cat ?? obj.category) || '').toString().trim();
            const sub = (obj && (obj.sousCategorie ?? obj.subcat ?? obj.subCategory ?? obj.subcategory) || '').toString().trim();
            const item = (obj && (obj.item ?? obj.text ?? obj.label) || '').toString().trim();
            if (!item) return;

            const li = document.createElement('li');
            li.className = 'flex items-start gap-1 bg-white border border-slate-200 rounded p-1';
            li.setAttribute('data-cat', cat);
            li.setAttribute('data-subcat', sub);
            li.setAttribute('data-item', item);

            li.innerHTML = `
                <span class="material-icons-round text-slate-400 text-sm cursor-grab drag-handle-tools-materials drag-handle mt-1" title="Glisser-déposer pour réorganiser" aria-label="Glisser-déposer pour réorganiser">drag_indicator</span>
                <div class="flex flex-col sm:flex-row gap-1 flex-1 min-w-0">
                    <input class="tm-cat-input px-2 py-1 border border-slate-200 rounded text-xs w-full sm:w-[28%]" placeholder="Catégorie..." value="${escapeHtml(cat)}" />
                    <input class="tm-subcat-input px-2 py-1 border border-slate-200 rounded text-xs w-full sm:w-[28%]" placeholder="Sous-catégorie..." value="${escapeHtml(sub)}" />
                    <input class="tm-item-input px-2 py-1 border border-slate-200 rounded text-xs flex-1 min-w-0" placeholder="Outil / matériel..." value="${escapeHtml(item)}" />
                </div>
                <button class="text-[10px] px-2 py-1 rounded bg-red-50 text-red-700 hover:bg-red-100 border border-red-100" data-action="remove-tools-materials-item" title="Supprimer" type="button">
                    <span class="material-icons-round text-sm">delete</span>
                </button>
            `;

            const onAnyInput = () => syncToolsMaterialsTextareaFromList();
            li.querySelectorAll('input').forEach(inp => {
                inp.addEventListener('input', onAnyInput);
                inp.addEventListener('change', onAnyInput);
            });

            list.appendChild(li);
            syncToolsMaterialsTextareaFromList();
        }

        function safeAddToolsMaterialsItem() {
            const itemIn = document.getElementById('new-tools-materials-item-input');
            const catIn = document.getElementById('new-tools-materials-cat-input');
            const subIn = document.getElementById('new-tools-materials-subcat-input');
            const item = (itemIn?.value || '').trim();
            if (!item) return;
            const cat = (catIn?.value || '').trim();
            const sub = (subIn?.value || '').trim();
            addToolsMaterialsItem({ categorie: cat, sousCategorie: sub, item });
            if (itemIn) itemIn.value = '';
            if (catIn) catIn.value = '';
            if (subIn) subIn.value = '';
            try { itemIn?.focus(); } catch(_){ __ldSilentErr(_); }
        }

        function handleToolsMaterialsCsvFileImport(file) {
            _readTextFile(file, (err, content) => {
                const status = document.getElementById('tools-materials-csv-status');
                if (err) {
                    console.error('[ToolsMaterialsCsvImportError]', err);
                    if (status) status.textContent = 'Erreur CSV';
                    return;
                }
                const items = _parseCategorisedListFile(content, file && file.name);
                let added = 0;
                try {
                    items.forEach(it => {
                        const before = document.getElementById('tools-materials-list')?.querySelectorAll('.tm-item-input')?.length || 0;
                        addToolsMaterialsItem(it);
                        const after = document.getElementById('tools-materials-list')?.querySelectorAll('.tm-item-input')?.length || 0;
                        if (after > before) added += 1;
                    });
                } catch (e) {
                    console.error('[ToolsMaterialsCsvImportError2]', e);
                }
                if (status) status.textContent = `Importé : ${added} élément(s)`;
            });
        }

        function downloadToolsMaterialsTemplateCSV() {
            const csv = 'categorie;sous_categorie;item\n'
                      + '"Plateforme";"LMS";"Moodle — Forum"\n'
                      + '"Outil";"Collaboratif";"Padlet — Mur"\n'
                      + '"Matériel";"Salle";"Paperboard + marqueurs"\n';
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'modele_outils_materiel.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

// --- CSV import helpers for Objectifs & Résultats (texte) ---
        function _parseSimpleListCSV(csvContent, fileName) {
            // Robust import for simple lists (Objectifs / Résultats texte)
            // Supports: CSV (comma/semicolon), TSV, and TXT (one item per line).
            // Heuristics:
            // - If header contains "item" (or "id"+"item"), use the item column.
            // - If rows are split into multiple columns (e.g., commas/; in sentences), we rejoin to preserve the full sentence.
            const name = String(fileName || '').toLowerCase();
            const isTxt = name.endsWith('.txt');
            const raw = String(csvContent || '').replace(/\uFEFF/g, '');
            const lines = raw.split(/\r?\n/);
            const out = [];

            function detectDelimiter(sample) {
                const s = String(sample || '');
                const counts = {
                    '	': (s.match(/	/g) || []).length,
                    ';' : (s.match(/;/g) || []).length,
                    ',' : (s.match(/,/g) || []).length
                };
                // Prefer tab if present (TSV), otherwise pick the most frequent.
                if (counts['	'] > 0) return '	';
                if (counts[';'] >= counts[',']) return ';';
                return ',';
            }

            function parseLine(line, delim) {
                const fields = [];
                let cur = '';
                let inQuotes = false;
                const s = String(line || '');
                for (let i = 0; i < s.length; i++) {
                    const ch = s[i];
                    if (ch === '"') {
                        // Handle doubled quotes inside quoted field
                        if (inQuotes && s[i + 1] === '"') {
                            cur += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                        continue;
                    }
                    if (!inQuotes && ch === delim) {
                        fields.push(cur.trim());
                        cur = '';
                        continue;
                    }
                    cur += ch;
                }
                fields.push(cur.trim());
                return fields;
            }

            // Find first non-empty line for delimiter/header detection
            let firstDataLineIdx = -1;
            for (let i = 0; i < lines.length; i++) {
                if (String(lines[i] || '').trim()) { firstDataLineIdx = i; break; }
            }
            if (firstDataLineIdx < 0) return out;

            // TXT: one item per line (no CSV parsing)
            if (isTxt) {
                for (let i = 0; i < lines.length; i++) {
                    const line = String(lines[i] || '').trim();
                    if (!line) continue;
                    const lower = line.toLowerCase();
                    if (i === firstDataLineIdx && (lower === 'item' || lower.includes('objectif') || lower.includes('outcome') || lower.includes('résultat') || lower.includes('resultat'))) {
                        continue;
                    }
                    out.push(line);
                }
                return out;
            }

            const delim = detectDelimiter(lines[firstDataLineIdx]);
            let itemIndex = null;
            let hasHeader = false;

            // Header detection
            const headerFields = parseLine(lines[firstDataLineIdx], delim).map(f => String(f || '').trim());
            const headerLower = headerFields.map(f => f.toLowerCase());
            if (headerLower.includes('item')) {
                itemIndex = headerLower.indexOf('item');
                hasHeader = true;
            } else if (headerLower.includes('objectif') || headerLower.includes('objectifs') || headerLower.includes('outcome') || headerLower.includes('outcomes') || headerLower.includes('résultat') || headerLower.includes('resultat') || headerLower.includes('résultats') || headerLower.includes('resultats')) {
                // Consider it a header but keep index 0
                itemIndex = 0;
                hasHeader = true;
            } else if (headerLower.includes('id') && headerLower.includes('label')) {
                itemIndex = headerLower.indexOf('label');
                hasHeader = true;
            }

            const start = hasHeader ? (firstDataLineIdx + 1) : firstDataLineIdx;

            for (let i = start; i < lines.length; i++) {
                const line = String(lines[i] || '').trim();
                if (!line) continue;

                const fields = parseLine(line, delim).filter(f => String(f || '').trim().length > 0);
                if (!fields.length) continue;

                let text = '';
                if (itemIndex != null && fields[itemIndex] != null) {
                    text = String(fields[itemIndex] || '').trim();
                } else if (fields.length === 1) {
                    text = String(fields[0] || '').trim();
                } else if (fields.length >= 2) {
                    // If first looks like an ID, take second; otherwise rejoin to preserve full sentence.
                    const f0 = String(fields[0] || '').trim();
                    const f1 = String(fields[1] || '').trim();
                    const looksLikeId = /^[A-Za-z]{2,12}[-_ ]?\d{1,6}$/.test(f0) || (/^[A-Za-z0-9_-]{1,12}$/.test(f0) && f1.length > 6);
                    text = looksLikeId ? f1 : fields.join(delim);
                }

                text = String(text || '').trim();
                if (text) out.push(text);
            }
            return out;
        }


        function _parseCategorisedListFile(content, fileName) {
            const name = String(fileName || '').toLowerCase();
            const isTxt = name.endsWith('.txt');
            const raw = String(content || '').replace(/\uFEFF/g, '');
            const lines = raw.split(/\r?\n/);
            const out = [];

            // TXT: one item per line => item only
            if (isTxt) {
                for (let i = 0; i < lines.length; i++) {
                    const line = String(lines[i] || '').trim();
                    if (!line) continue;
                    const lower = line.toLowerCase();
                    if (i === 0 && (lower === 'item' || lower.includes('objectif') || lower.includes('outcome') || lower.includes('résultat') || lower.includes('resultat'))) continue;
                    out.push({ categorie: '', sousCategorie: '', item: line });
                }
                return out;
            }

            function detectDelimiter(sample) {
                const s = String(sample || '');
                const tab = (s.match(/	/g) || []).length;
                const semi = (s.match(/;/g) || []).length;
                const comma = (s.match(/,/g) || []).length;
                if (tab > 0) return '	';
                if (semi >= comma) return ';';
                return ',';
            }

            function parseLine(line, delim) {
                const fields = [];
                let cur = '';
                let inQuotes = false;
                const s = String(line || '');
                for (let i = 0; i < s.length; i++) {
                    const ch = s[i];
                    if (ch === '"') {
                        if (inQuotes && s[i + 1] === '"') { cur += '"'; i++; }
                        else { inQuotes = !inQuotes; }
                        continue;
                    }
                    if (!inQuotes && ch === delim) {
                        fields.push(cur.trim());
                        cur = '';
                        continue;
                    }
                    cur += ch;
                }
                fields.push(cur.trim());
                return fields;
            }

            let first = -1;
            for (let i = 0; i < lines.length; i++) {
                if (String(lines[i] || '').trim()) { first = i; break; }
            }
            if (first < 0) return out;

            const delim = detectDelimiter(lines[first]);
            const header = parseLine(lines[first], delim).map(s => String(s || '').trim());
            const headerLower = header.map(h => h.toLowerCase());

            let hasHeader = false;

            let idxCat = null;
            let idxSub = null;
            let idxItem = null;

            const catKeys = ['categorie', 'catégorie', 'category', 'cat'];
            const subKeys = ['sous_categorie', 'sous-categorie', 'souscat', 'souscatégorie', 'subcategory', 'subcat'];
            const itemKeys = ['item', 'objectif', 'objectifs', 'outcome', 'outcomes', 'résultat', 'resultat', 'résultats', 'resultats', 'texte', 'text', 'label', 'outil', 'outils', 'matériel', 'materiel', 'tools', 'tool', 'material', 'materials'];

            function findIndex(keys) {
                for (const k of keys) {
                    const i = headerLower.indexOf(k);
                    if (i >= 0) return i;
                }
                return -1;
            }

            const iCat = findIndex(catKeys);
            const iSub = findIndex(subKeys);
            const iItem = findIndex(itemKeys);

            if (iCat >= 0 || iSub >= 0 || iItem >= 0) {
                hasHeader = true;
                idxCat = iCat >= 0 ? iCat : null;
                idxSub = iSub >= 0 ? iSub : null;
                idxItem = iItem >= 0 ? iItem : null;
            }

            const start = hasHeader ? (first + 1) : first;

            for (let i = start; i < lines.length; i++) {
                const line = String(lines[i] || '').trim();
                if (!line) continue;
                const fields = parseLine(line, delim).filter(f => String(f || '').trim().length > 0);
                if (!fields.length) continue;

                let cat = '';
                let sub = '';
                let item = '';

                if (hasHeader) {
                    cat = (idxCat != null && fields[idxCat] != null) ? String(fields[idxCat] || '').trim() : '';
                    sub = (idxSub != null && fields[idxSub] != null) ? String(fields[idxSub] || '').trim() : '';
                    if (idxItem != null && fields[idxItem] != null) item = String(fields[idxItem] || '').trim();
                    else {
                        // If item column not explicit, rejoin remaining
                        item = fields.join(delim);
                    }
                } else {
                    if (fields.length >= 3) {
                        cat = String(fields[0] || '').trim();
                        sub = String(fields[1] || '').trim();
                        item = String(fields.slice(2).join(delim) || '').trim();
                    } else if (fields.length == 2) {
                        cat = String(fields[0] || '').trim();
                        item = String(fields[1] || '').trim();
                    } else {
                        item = String(fields[0] || '').trim();
                    }
                }

                item = String(item || '').trim();
                if (!item) continue;
                out.push({ categorie: cat, sousCategorie: sub, item });
            }

            return out;
        }

function _readTextFile(file, cb) {
            try {
                const reader = new FileReader();
                reader.onload = () => cb(null, String(reader.result || ''));
                reader.onerror = () => cb(new Error('Lecture du fichier impossible'));
                reader.readAsText(file);
            } catch (e) {
                cb(e);
            }
        }

        function handleAimsCsvFileImport(file) {
            _readTextFile(file, (err, content) => {
                const status = document.getElementById('aims-csv-status');
                if (err) {
                    console.error('[AimsCsvImportError]', err);
                    if (status) status.textContent = 'Erreur CSV';
                    return;
                }
                const items = _parseCategorisedListFile(content, file && file.name);
                let added = 0;
                try {
                    items.forEach(it => {
                        const before = document.getElementById('aims-list')?.querySelectorAll('.aim-item-input')?.length || 0;
                        addAimItem(it);
                        const after = document.getElementById('aims-list')?.querySelectorAll('.aim-item-input')?.length || 0;
                        if (after > before) added += 1;
                    });
                } catch (e) {
                    console.error('[AimsCsvImportError2]', e);
                }
                if (status) status.textContent = `Importé : ${added} élément(s)`;
            });
        }

        function handleOutcomesTextCsvFileImport(file) {
            _readTextFile(file, (err, content) => {
                const status = document.getElementById('outcomes-text-csv-status');
                if (err) {
                    console.error('[OutcomesTextCsvImportError]', err);
                    if (status) status.textContent = 'Erreur CSV';
                    return;
                }
                const items = _parseCategorisedListFile(content, file && file.name);
                let added = 0;
                try {
                    items.forEach(it => {
                        const before = document.getElementById('outcomes-text-list')?.querySelectorAll('.outcomes-item-input')?.length || 0;
                        addOutcomesTextItem(it);
                        const after = document.getElementById('outcomes-text-list')?.querySelectorAll('.outcomes-item-input')?.length || 0;
                        if (after > before) added += 1;
                    });
                } catch (e) {
                    console.error('[OutcomesTextCsvImportError2]', e);
                }
                if (status) status.textContent = `Importé : ${added} élément(s)`;
            });
        }

        function downloadAimsTemplateCSV() {
            // One item per line. Columns: categorie ; sous_categorie ; item
            // Fields are quoted for Excel/Sheets robustness.
            const csv = 'categorie;sous_categorie;item\n'
                      + '"Pédagogie";"Différenciation";"Adapter les activités aux besoins des participants."\n'
                      + '"Évaluation";"Formative";"Définir des critères de réussite et des indicateurs."\n';
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'modele_objectifs.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function downloadOutcomesTextTemplateCSV() {
            // One item per line. Columns: categorie ; sous_categorie ; item
            // Fields are quoted for Excel/Sheets robustness.
            const csv = 'categorie;sous_categorie;item\n'
                      + '"Connaissances";"Définitions";"Le participant saura définir les concepts clés."\n'
                      + '"Compétences";"Production";"Le participant produira une séquence conforme au référentiel."\n';
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'modele_resultats_texte.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }


        // --- Compétences (onglet 4): Taxonomies + import CSV ---
        const COMP_SUBJ_TAXONOMY_STORAGE_KEY = 'ld_competences_taxonomy';
        const COMP_SUBJ_TAXONOMY_TRANSLATIONS_KEY = 'ld_competences_taxonomy_translations';
        let ACTIVE_COMP_SUBJ_TAXONOMY = {};
        let ACTIVE_COMP_SUBJ_TAXONOMY_TRANSLATIONS = {};

        const COMP_TRANS_TAXONOMY_STORAGE_KEY = 'ld_competences_trans_taxonomy';
        const COMP_TRANS_TAXONOMY_TRANSLATIONS_KEY = 'ld_competences_trans_taxonomy_translations';
        let ACTIVE_COMP_TRANS_TAXONOMY = {};
        let ACTIVE_COMP_TRANS_TAXONOMY_TRANSLATIONS = {};


        // ====================================================================
        // TAXONOMY MANAGER FACTORY — replaces 28 duplicate functions (4 × 7)
        // ====================================================================
        function createTaxonomyManager(config) {
            // config: { taxonomyVar, translationsVar, storageKey, translationsKey,
            //           statusElId, catDatalistId, subcatDatalistId, catInputId,
            //           label, templateFilename, templateRows }
            //
            // Returns: { refresh, reset, save, apply, handleImport, downloadTemplate, updateStatus }

            const mgr = {};

            mgr.updateStatus = function(message) {
                const el = document.getElementById(config.statusElId);
                if (el) el.textContent = message || '';
            };

            mgr.refresh = function() {
                const catList  = document.getElementById(config.catDatalistId);
                const subList  = document.getElementById(config.subcatDatalistId);
                if (catList)  catList.innerHTML = '';
                if (subList)  subList.innerHTML = '';

                const taxonomy = config.getTaxonomy();
                const cats = Object.keys(taxonomy || {});
                cats.sort((a, b) => String(a).localeCompare(String(b), 'fr'));

                if (catList) {
                    cats.forEach(c => { const opt = document.createElement('option'); opt.value = c; catList.appendChild(opt); });
                }

                const catInput = document.getElementById(config.catInputId);
                const currentCat = String(catInput?.value || '').trim();

                let subs = [];
                if (currentCat && taxonomy[currentCat]) {
                    subs = (taxonomy[currentCat] || []).slice();
                } else {
                    const set = new Set();
                    cats.forEach(c => (taxonomy[c] || []).forEach(s => set.add(s)));
                    subs = Array.from(set);
                }
                subs.sort((a, b) => String(a).localeCompare(String(b), 'fr'));
                if (subList) {
                    subs.forEach(s => { const opt = document.createElement('option'); opt.value = s; subList.appendChild(opt); });
                }
            };

            mgr.save = function(taxonomy, translations) {
                try {
                    localStorage.setItem(config.storageKey, JSON.stringify(taxonomy || {}));
                    localStorage.setItem(config.translationsKey, JSON.stringify(translations || {}));
                } catch (e) { __ldSilentErr(e); }
            };

            mgr.reset = function() {
                config.setTaxonomy({});
                config.setTranslations({});
                try {
                    localStorage.removeItem(config.storageKey);
                    localStorage.removeItem(config.translationsKey);
                } catch (e) { __ldSilentErr(e); }
                mgr.refresh();
                mgr.updateStatus('Aucune taxonomie chargée');
            };

            mgr.apply = function(taxonomy, translations) {
                config.setTaxonomy(taxonomy || {});
                config.setTranslations(translations || {});
                mgr.save(config.getTaxonomy(), config.getTranslations());
                mgr.refresh();
                mgr.updateStatus('Taxonomie appliquée (' + Object.keys(config.getTaxonomy()).length + ' catégories)');
            };

            mgr.handleImport = function(file) {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function() {
                    try {
                        const content = String(reader.result || '');
                        const parsed = parseTaxonomyCSV(content);
                        mgr.apply(parsed.taxonomy, parsed.translations);
                    } catch (e) {
                        console.error('Erreur import taxonomie ' + config.label + ':', e);
                        showAlert('Erreur', (e && e.message) ? e.message : 'Import de taxonomie impossible.');
                    }
                };
                reader.onerror = function() { showAlert('Erreur', 'Lecture du fichier impossible.'); };
                reader.readAsText(file);
            };

            mgr.downloadTemplate = function() {
                const rows = config.templateRows || ['categorie;sous_categorie', 'Domaine;Sous-domaine'];
                const csv = rows.join('\n');
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = config.templateFilename || 'modele_taxonomie.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            return mgr;
        }


        // --- Taxonomy manager: compétences (disciplinaires) (delegates to createTaxonomyManager) ---
        const __compSubjTaxMgr = createTaxonomyManager({
            storageKey: COMP_SUBJ_TAXONOMY_STORAGE_KEY,
            translationsKey: COMP_SUBJ_TAXONOMY_TRANSLATIONS_KEY,
            statusElId: 'competences-taxonomy-status',
            catDatalistId: 'competences-cat-datalist',
            subcatDatalistId: 'competences-subcat-datalist',
            catInputId: 'new-competence-cat-input',
            label: 'compétences (disciplinaires)',
            templateFilename: 'modele_taxonomie_competences.csv',
            templateRows: ['categorie;sous_categorie', 'Domaine;Sous-domaine', 'Domaine;Niveau'],
            getTaxonomy:     () => ACTIVE_COMP_SUBJ_TAXONOMY,
            getTranslations: () => ACTIVE_COMP_SUBJ_TAXONOMY_TRANSLATIONS,
            setTaxonomy:     (v) => { ACTIVE_COMP_SUBJ_TAXONOMY = v; },
            setTranslations: (v) => { ACTIVE_COMP_SUBJ_TAXONOMY_TRANSLATIONS = v; },
        });
        function updateCompetencesTaxonomyStatus(msg)           { __compSubjTaxMgr.updateStatus(msg); }
        function refreshCompetencesTaxonomyHints()             { __compSubjTaxMgr.refresh(); }
        function resetCompetencesTaxonomy()               { __compSubjTaxMgr.reset(); }
        function saveCompetencesTaxonomyToStorage(tax, trans)      { __compSubjTaxMgr.save(tax, trans); }
        function applyCompetencesTaxonomy(tax, trans)     { __compSubjTaxMgr.apply(tax, trans); }
        function handleCompetencesTaxonomyFileImport(file)          { __compSubjTaxMgr.handleImport(file); }
        function downloadCompetencesTaxonomyTemplate()            { __compSubjTaxMgr.downloadTemplate(); }


        // --- Taxonomy manager: compétences transversales (delegates to createTaxonomyManager) ---
        const __compTransTaxMgr = createTaxonomyManager({
            storageKey: COMP_TRANS_TAXONOMY_STORAGE_KEY,
            translationsKey: COMP_TRANS_TAXONOMY_TRANSLATIONS_KEY,
            statusElId: 'competences-trans-taxonomy-status',
            catDatalistId: 'competences-trans-cat-datalist',
            subcatDatalistId: 'competences-trans-subcat-datalist',
            catInputId: 'new-competence-trans-cat-input',
            label: 'compétences transversales',
            templateFilename: 'modele_taxonomie_comp_transversales.csv',
            templateRows: ['categorie;sous_categorie', 'Domaine;Sous-domaine', 'Domaine;Niveau'],
            getTaxonomy:     () => ACTIVE_COMP_TRANS_TAXONOMY,
            getTranslations: () => ACTIVE_COMP_TRANS_TAXONOMY_TRANSLATIONS,
            setTaxonomy:     (v) => { ACTIVE_COMP_TRANS_TAXONOMY = v; },
            setTranslations: (v) => { ACTIVE_COMP_TRANS_TAXONOMY_TRANSLATIONS = v; },
        });
        function updateCompetencesTransTaxonomyStatus(msg)           { __compTransTaxMgr.updateStatus(msg); }
        function refreshCompetencesTransTaxonomyHints()             { __compTransTaxMgr.refresh(); }
        function resetCompetencesTransTaxonomy()               { __compTransTaxMgr.reset(); }
        function saveCompetencesTransTaxonomyToStorage(tax, trans)      { __compTransTaxMgr.save(tax, trans); }
        function applyCompetencesTransTaxonomy(tax, trans)     { __compTransTaxMgr.apply(tax, trans); }
        function handleCompetencesTransTaxonomyFileImport(file)          { __compTransTaxMgr.handleImport(file); }
        function downloadCompetencesTransTaxonomyTemplate()            { __compTransTaxMgr.downloadTemplate(); }

        function handleCompetencesCsvFileImport(file, isTransversal) {
            _readTextFile(file, (err, content) => {
                const status = document.getElementById(isTransversal ? 'competences-trans-csv-status' : 'competences-csv-status');
                if (err) {
                    console.error('[CompetencesCsvImportError]', err);
                    if (status) status.textContent = 'Erreur CSV';
                    return;
                }
                const items = _parseCategorisedListFile(content, file && file.name);
                let added = 0;
                try {
                    items.forEach(it => {
                        const cat = String(it.categorie || it.category || it.cat || '').trim();
                        const sub = String(it.sousCategorie || it.subcategory || it.subcat || '').trim();
                        const item = String(it.item || it.label || it.text || '').trim();
                        if (!item) return;
                        const before = (isTransversal ? document.getElementById('competences-transversales-list') : document.getElementById('competences-list'))?.querySelectorAll('li')?.length || 0;
                        if (isTransversal) addCompetenceTransversal({ item, categorie: cat, sousCategorie: sub });
                        else addCompetence({ item, categorie: cat, sousCategorie: sub });
                        const after = (isTransversal ? document.getElementById('competences-transversales-list') : document.getElementById('competences-list'))?.querySelectorAll('li')?.length || 0;
                        if (after > before) added += 1;
                    });
                } catch (e) {
                    console.error('[CompetencesCsvImportError2]', e);
                }
                if (status) status.textContent = `Importé : ${added} élément(s)`;
            });
        }

        function downloadCompetencesTemplateCSV() {
            const csv = 'categorie;sous_categorie;item\n'
                      + '"Domaine";"Sous-domaine";"Mobiliser des concepts clés du cours."\n'
                      + '"Domaine";"Niveau";"Résoudre un problème authentique en contexte."\n';
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'modele_competences_sujet.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function downloadCompetencesTransTemplateCSV() {
            const csv = 'categorie;sous_categorie;item\n'
                      + '"EU";"Compétences";"Collaborer et co-construire des solutions."\n'
                      + '"EU";"Attitudes";"Faire preuve de responsabilité et d\'autonomie."\n';
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'modele_competences_transversales.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
function addAimItem(textValue = null) {
            const catIn = document.getElementById('new-aim-cat-input');
            const subIn = document.getElementById('new-aim-subcat-input');
            const input = document.getElementById('new-aim-item-input');
            const list = document.getElementById('aims-list');
            if (!list) return;

            let cat = '';
            let sub = '';
            let rawItem = '';

            if (textValue && typeof textValue === 'object') {
                cat = String(textValue.categorie || textValue.category || textValue.cat || '').trim();
                sub = String(textValue.sousCategorie || textValue.subcategory || textValue.subcat || '').trim();
                rawItem = String(textValue.item || textValue.text || textValue.label || '').trim();
            } else {
                cat = String(catIn ? catIn.value : '').trim();
                sub = String(subIn ? subIn.value : '').trim();
                rawItem = String(textValue != null ? textValue : (input ? input.value : '')).trim();
            }

            const cleanedItem = (typeof _cleanTextListLine === 'function') ? _cleanTextListLine(rawItem) : rawItem.trim();
            if (!cleanedItem) return;

            const key = `${cat.toLowerCase()}|${sub.toLowerCase()}|${cleanedItem.toLowerCase()}`;
            const existing = Array.from(list.querySelectorAll('li')).some(li => {
                const c = (li.querySelector('.aim-cat-input')?.value || li.getAttribute('data-cat') || '').trim().toLowerCase();
                const s = (li.querySelector('.aim-subcat-input')?.value || li.getAttribute('data-subcat') || '').trim().toLowerCase();
                const it = (li.querySelector('.aim-item-input')?.value || li.getAttribute('data-item') || '').trim().toLowerCase();
                return `${c}|${s}|${it}` === key;
            });
            if (existing) {
                if (input) { input.value = ''; input.focus(); }
                return;
            }

            const li = document.createElement('li');
            li.className = 'flex items-center gap-1 border border-slate-200 rounded bg-white px-2 py-1 text-xs';
            li.setAttribute('data-cat', cat);
            li.setAttribute('data-subcat', sub);
            li.setAttribute('data-item', cleanedItem);

            const drag = document.createElement('span');
            drag.className = 'material-icons-round text-slate-400 text-sm cursor-grab drag-handle-aim-item';
            drag.textContent = 'drag_indicator';

            const catInput = document.createElement('input');
            catInput.type = 'text';
            catInput.value = cat;
            catInput.placeholder = 'Catégorie…';
            catInput.className = 'aim-cat-input w-28 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            catInput.addEventListener('input', () => {
                li.setAttribute('data-cat', String(catInput.value || '').trim());
                syncAimsTextareaFromList();
                try { updateAllModuleLearningTargetsSummaries(); } catch(_){ __ldSilentErr(_); }
                try { __kpwizRefreshAimsOptionsNotice(); } catch(_){ __ldSilentErr(_); }
            });

            const subInput = document.createElement('input');
            subInput.type = 'text';
            subInput.value = sub;
            subInput.placeholder = 'Sous-catégorie…';
            subInput.className = 'aim-subcat-input w-28 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            subInput.addEventListener('input', () => {
                li.setAttribute('data-subcat', String(subInput.value || '').trim());
                syncAimsTextareaFromList();
                try { updateAllModuleLearningTargetsSummaries(); } catch(_){ __ldSilentErr(_); }
                try { __kpwizRefreshAimsOptionsNotice(); } catch(_){ __ldSilentErr(_); }
            });

            const itemInput = document.createElement('input');
            itemInput.type = 'text';
            itemInput.value = cleanedItem;
            itemInput.className = 'aim-item-input flex-1 min-w-[140px] px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            itemInput.addEventListener('input', () => {
                li.setAttribute('data-item', String(itemInput.value || '').trim());
                syncAimsTextareaFromList();
                try { updateAllModuleLearningTargetsSummaries(); } catch(_){ __ldSilentErr(_); }
                try { __kpwizRefreshAimsOptionsNotice(); } catch(_){ __ldSilentErr(_); }
            });

            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'text-slate-400 hover:text-red-600 p-1 transition-colors';
            del.setAttribute('data-action', 'remove-aim-item');
            del.title = 'Supprimer';
            del.innerHTML = '<span class="material-icons-round text-sm">close</span>';

            li.appendChild(drag);
            li.appendChild(catInput);
            li.appendChild(subInput);
            li.appendChild(itemInput);
            li.appendChild(del);
            list.appendChild(li);

            if (input && textValue == null) {
                input.value = '';
                if (catIn) catIn.value = '';
                if (subIn) subIn.value = '';
                input.focus();
            }
            syncAimsTextareaFromList();
        }


        function addOutcomesTextItem(textValue = null) {
            const catIn = document.getElementById('new-outcomes-text-cat-input');
            const subIn = document.getElementById('new-outcomes-text-subcat-input');
            const input = document.getElementById('new-outcomes-text-item-input');
            const list = document.getElementById('outcomes-text-list');
            if (!list) return;

            let cat = '';
            let sub = '';
            let rawItem = '';

            if (textValue && typeof textValue === 'object') {
                cat = String(textValue.categorie || textValue.category || textValue.cat || '').trim();
                sub = String(textValue.sousCategorie || textValue.subcategory || textValue.subcat || '').trim();
                rawItem = String(textValue.item || textValue.text || textValue.label || '').trim();
            } else {
                cat = String(catIn ? catIn.value : '').trim();
                sub = String(subIn ? subIn.value : '').trim();
                rawItem = String(textValue != null ? textValue : (input ? input.value : '')).trim();
            }

            const cleanedItem = (typeof _cleanTextListLine === 'function') ? _cleanTextListLine(rawItem) : rawItem.trim();
            if (!cleanedItem) return;

            const key = `${cat.toLowerCase()}|${sub.toLowerCase()}|${cleanedItem.toLowerCase()}`;
            const existing = Array.from(list.querySelectorAll('li')).some(li => {
                const c = (li.querySelector('.outcomes-cat-input')?.value || li.getAttribute('data-cat') || '').trim().toLowerCase();
                const s = (li.querySelector('.outcomes-subcat-input')?.value || li.getAttribute('data-subcat') || '').trim().toLowerCase();
                const it = (li.querySelector('.outcomes-item-input')?.value || li.getAttribute('data-item') || '').trim().toLowerCase();
                return `${c}|${s}|${it}` === key;
            });
            if (existing) {
                if (input) { input.value = ''; input.focus(); }
                return;
            }

            const li = document.createElement('li');
            li.className = 'flex items-center gap-1 border border-slate-200 rounded bg-white px-2 py-1 text-xs';
            li.setAttribute('data-cat', cat);
            li.setAttribute('data-subcat', sub);
            li.setAttribute('data-item', cleanedItem);

            const drag = document.createElement('span');
            drag.className = 'material-icons-round text-slate-400 text-sm cursor-grab drag-handle-outcomes-text-item';
            drag.textContent = 'drag_indicator';

            const catInput = document.createElement('input');
            catInput.type = 'text';
            catInput.value = cat;
            catInput.placeholder = 'Catégorie…';
            catInput.className = 'outcomes-cat-input w-28 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            catInput.addEventListener('input', () => {
                li.setAttribute('data-cat', String(catInput.value || '').trim());
                syncOutcomesTextTextareaFromList();
            });

            const subInput = document.createElement('input');
            subInput.type = 'text';
            subInput.value = sub;
            subInput.placeholder = 'Sous-catégorie…';
            subInput.className = 'outcomes-subcat-input w-28 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            subInput.addEventListener('input', () => {
                li.setAttribute('data-subcat', String(subInput.value || '').trim());
                syncOutcomesTextTextareaFromList();
            });

            const itemInput = document.createElement('input');
            itemInput.type = 'text';
            itemInput.value = cleanedItem;
            itemInput.className = 'outcomes-item-input flex-1 min-w-[140px] px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            itemInput.addEventListener('input', () => {
                li.setAttribute('data-item', String(itemInput.value || '').trim());
                syncOutcomesTextTextareaFromList();
            });

            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'text-slate-400 hover:text-red-600 p-1 transition-colors';
            del.setAttribute('data-action', 'remove-outcomes-text-item');
            del.title = 'Supprimer';
            del.innerHTML = '<span class="material-icons-round text-sm">close</span>';

            li.appendChild(drag);
            li.appendChild(catInput);
            li.appendChild(subInput);
            li.appendChild(itemInput);
            li.appendChild(del);
            list.appendChild(li);

            if (input && textValue == null) {
                input.value = '';
                if (catIn) catIn.value = '';
                if (subIn) subIn.value = '';
                input.focus();
            }

            syncOutcomesTextTextareaFromList();
        }


        function safeAddAimItem() {
            const input = document.getElementById('new-aim-item-input');
            try {
                if (input && !String(input.value || '').trim()) {
                    input.setCustomValidity('Saisissez un objectif avant d\'ajouter.');
                    input.reportValidity();
                    input.focus();
                    input.setCustomValidity('');
                    return;
                }
                addAimItem();
                try { updateAllModuleLearningTargetsSummaries(); } catch(_){ __ldSilentErr(_); }
                try { __kpwizRefreshAimsOptionsNotice(); } catch(_){ __ldSilentErr(_); }
            } catch (err) {
                showJsErrorBanner('Erreur lors de l\'ajout de l\'objectif : ' + (err && err.message ? err.message : String(err)));
            }
        }

        // --- Navigation helper: from an activity step to Key Parameters > Step 3 > Objectifs ---
        // Stores origin so user can return to the exact activity.
        window.__kpwizAimsOrigin = null;

        function __kpwizDescribeOrigin(origin) {
            try {
                if (!origin) return '';
                const mTitle = String(origin.moduleTitle || '').trim();
                const moTitle = String(origin.momentTitle || '').trim();
                const sTitle = String(origin.stepTitle || '').trim();
                const parts = [];
                if (mTitle) parts.push(mTitle);
                if (moTitle) parts.push(moTitle);
                if (sTitle) parts.push('Activité : ' + sTitle);
                return parts.join(' • ') || 'Activité';
            } catch (_) {
                return 'Activité';
            }
        }

        function __kpwizShowAimsOriginBar(origin) {
            const bar = document.getElementById('aims-origin-bar');
            const label = document.getElementById('aims-origin-label');
            if (!bar || !label) return;
            if (!origin) {
                bar.classList.add('hidden');
                label.textContent = '';
                return;
            }
            label.textContent = __kpwizDescribeOrigin(origin);
            bar.classList.remove('hidden');
        }

        function __kpwizOpenKeyParamsStep3Aims() {
            // Ensure panel is open
            const panel = document.getElementById('key-params-panel');
            const icon = document.getElementById('key-params-panel-icon');
            if (panel) {
                const disp = (panel.style && panel.style.display) ? panel.style.display : '';
                const computed = (typeof getComputedStyle === 'function') ? getComputedStyle(panel).display : disp;
                if (disp === 'none' || computed === 'none') {
                    panel.style.display = 'block';
                }
            }
            if (icon) icon.style.transform = 'rotate(180deg)';

            // Activate wizard step 3 if present
            const stepBtn = document.querySelector('#kpwiz-bar [data-kpwiz-step="3"]');
            if (stepBtn) {
                try { stepBtn.click(); } catch(_){ __ldSilentErr(_); }
            } else {
                // Fallback: show the step explicitly
                const step3 = document.getElementById('kpwiz-step-3');
                if (step3) step3.classList.remove('hidden');
            }

            // Open the Objectifs details and focus input
            const aimsList = document.getElementById('aims-list');
            const aimsDetails = aimsList ? aimsList.closest('details') : null;
            if (aimsDetails) aimsDetails.open = true;

            const target = aimsDetails || document.getElementById('kpwiz-step-3') || panel;
            if (target && target.scrollIntoView) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            const input = document.getElementById('new-aim-item-input');
            if (input) {
                try { input.focus(); } catch(_){ __ldSilentErr(_); }
            }
        }

        function __kpwizGetOriginFromStepBtn(btn) {
            const stepEl = btn ? btn.closest('.step-card') : null;
            if (!stepEl) return null;
            const moduleEl = stepEl.closest('.activity-group');
            if (!moduleEl) return null;

            const modules = Array.from(document.querySelectorAll('.activity-group'));
            const moduleIndex = modules.indexOf(moduleEl);

            const steps = Array.from(__ldFilterStepNodeList(moduleEl.querySelectorAll('.step-card')));
            const stepIndex = steps.indexOf(stepEl);

            const moduleTitle = moduleEl.querySelector('.activity-title')?.value || moduleEl.querySelector('.activity-title')?.getAttribute('value') || '';
            const momentTitle = stepEl.closest('.moment-group')?.querySelector('.moment-title')?.value || '';
            const stepTitle = stepEl.querySelector('.step-input-title')?.value || '';

            return {
                moduleIndex: moduleIndex,
                stepIndex: stepIndex,
                moduleTitle: moduleTitle,
                momentTitle: momentTitle,
                stepTitle: stepTitle
            };
        }

        

        // --- Quick creation from Activity blocks (prompt-based, no navigation) ---
        function __kpwizFormatCatSubItemLine(cat, sub, item) {
            try {
                if (typeof _formatCatSubItemLine === 'function') return _formatCatSubItemLine(cat, sub, item);
            } catch(_){ __ldSilentErr(_); }
            const c = String(cat || '').trim();
            const s = String(sub || '').trim();
            const it = String(item || '').trim();
            if (!it) return '';
            if (!c && !s) return it;
            if (c && !s) return `${c} — ${it}`;
            if (!c && s) return `${s} — ${it}`;
            return `${c} / ${s} — ${it}`;
        }

        function __kpwizSelectAimInStep(stepEl, aimLine) {
            if (!stepEl) return;
            const v = String(aimLine || '').trim();
            if (!v) return;
            const cur = (typeof getSelectedStepAims === 'function') ? (getSelectedStepAims(stepEl) || []) : [];
            if (!cur.includes(v)) cur.push(v);
            try { populateStepAimsSelect(stepEl, cur); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
        }
        function __kpwizSelectOutcomeInStep(stepEl, outcomeLine) {
            if (!stepEl) return;
            const v = String(outcomeLine || '').trim();
            if (!v) return;
            const cur = (typeof getSelectedStepOutcomes === 'function') ? (getSelectedStepOutcomes(stepEl) || []) : [];
            if (!cur.includes(v)) cur.push(v);
            try { populateStepOutcomesSelect(stepEl, cur); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
        }
        function __kpwizSelectCompetenceInStep(stepEl, id, isTransversal) {
            if (!stepEl) return;
            const v = String(id || '').trim();
            if (!v) return;
            if (isTransversal) {
                const cur = (typeof getSelectedStepCompetencesTransversalesIds === 'function') ? (getSelectedStepCompetencesTransversalesIds(stepEl) || []) : [];
                if (!cur.includes(v)) cur.push(v);
                try { populateStepCompetencesTransversalesSelect(stepEl, cur); } catch(_){ __ldSilentErr(_); }
            } else {
                const cur = (typeof getSelectedStepCompetenceIds === 'function') ? (getSelectedStepCompetenceIds(stepEl) || []) : [];
                if (!cur.includes(v)) cur.push(v);
                try { populateStepCompetencesSelect(stepEl, cur); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
        }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
        }
        function __kpwizPromptAddItem(kind) {
            // kind: 'aim' | 'outcome' | 'competence_sujet' | 'competence_transv'
            const k = String(kind || '').trim();

            if (k === 'competence_sujet' || k === 'competence_transv') {
                const label = window.prompt('Saisissez la compétence à ajouter :', '');
                if (label == null) return null;
                const txt = String(label || '').trim();
                if (!txt) return null;
                return { kind: k, label: txt };
            try { const modEl = stepEl ? stepEl.closest('.activity-group') : null; if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
        }
            const item = window.prompt(k === 'outcome' ? 'Saisissez le résultat d\'apprentissage à ajouter :' : 'Saisissez l\'objectif à ajouter :', '');
            if (item == null) return null;
            const it = String(item || '').trim();
            if (!it) return null;

            // Optional metadata (cancel = empty)
            const cat = window.prompt('Catégorie (optionnel) :', '')
            const sub = window.prompt('Sous-catégorie (optionnel) :', '')

            return {
                kind: k,
                categorie: String(cat == null ? '' : cat).trim(),
                sousCategorie: String(sub == null ? '' : sub).trim(),
                item: it
            };
        }
function openAimsFromStep(btn) {
            const origin = __kpwizGetOriginFromStepBtn(btn);
            window.__kpwizAimsOrigin = origin;
            __kpwizShowAimsOriginBar(origin);

            const stepEl = btn ? btn.closest('.step-card') : null;
            const details = btn ? btn.closest('details') : null;
            const summaryText = details ? (details.querySelector('summary')?.innerText || '') : '';
            const btnText = btn ? (btn.innerText || btn.textContent || '') : '';
            const isCompetenceContext = (summaryText.toLowerCase().includes('compétences ciblées') || btnText.toLowerCase().includes('ajouter une compétence') || btnText.toLowerCase().includes('objectif/compétence'));

            // If the button was used from the "Compétences ciblées" block, let the user choose what to add.
            if (isCompetenceContext) {
                const choice = window.prompt(
                    'Que souhaitez-vous ajouter ?\n1 = Compétence (sujet)\n2 = Compétence (transversale)',
                    '1'
                );
                if (choice == null) return;
                const c = String(choice || '').trim();

                if (c === '1' || c === '2') {
                    const payload = __kpwizPromptAddItem(c === '2' ? 'competence_transv' : 'competence_sujet');
                    if (!payload) return;

                    // Create in catalogue
                    const id = (typeof _genId === 'function') ? _genId(c === '2' ? 'compT' : 'comp') : ((c === '2' ? 'compT_' : 'comp_') + Date.now());
                    try {
                        if (c === '2') {
                            addCompetenceTransversal({ id: id, label: payload.label });
                        } else {
                            addCompetence({ id: id, label: payload.label });
                        }
                    } catch (e) {
                        console.error('Quick add competence failed', e);
                        return;
                    }

                    // Ensure the new competence is selected in the current Activity step
                    try { __kpwizSelectCompetenceInStep(stepEl, id, c === '2'); } catch(_){ __ldSilentErr(_); }
                    return;
                }

                // Any other input: do nothing (do not create an aim from the competence button)
                return;
            }

            const payload = __kpwizPromptAddItem('aim');
            if (!payload) return;

            try {
                addAimItem(payload);
                syncAimsTextareaFromList();
                refreshAllStepAimsOptions();
            } catch (e) {
                console.error('Quick add aim failed', e);
                return;
            }

            const aimLine = __kpwizFormatCatSubItemLine(payload.categorie, payload.sousCategorie, payload.item);
            try { __kpwizSelectAimInStep(stepEl, aimLine); } catch(_){ __ldSilentErr(_); }
        }

        function backToAimsOrigin() {
            const origin = window.__kpwizAimsOrigin;
            if (!origin) return;
            if (typeof scrollToEditor === 'function' && Number.isFinite(origin.moduleIndex) && origin.moduleIndex >= 0) {
                try { scrollToEditor(origin.moduleIndex, Number.isFinite(origin.stepIndex) && origin.stepIndex >= 0 ? origin.stepIndex : null); } catch(_){ __ldSilentErr(_); }
                return;
            }
            // Fallback: try to scroll to first matching element
            const modules = Array.from(document.querySelectorAll('.activity-group'));
            const moduleEl = modules[origin.moduleIndex];
            if (!moduleEl) return;
            const steps = Array.from(__ldFilterStepNodeList(moduleEl.querySelectorAll('.step-card')));
            const stepEl = steps[origin.stepIndex];
            if (stepEl && stepEl.scrollIntoView) stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Expose navigation helpers globally for the ActionRescue capturing handler
        window.openAimsFromStep = openAimsFromStep;
        window.backToAimsOrigin = backToAimsOrigin;

        function __kpwizRefreshAimsOptionsNotice(){
            // If the module-selection modal is open (aims/outcomes picker), keep it consistent.
            const modal = document.getElementById('module-selection-modal');
            if (!modal || modal.classList.contains('hidden')) return;
            // The modal content is regenerated when (re)opened; here we simply refresh the summary chips elsewhere.
            try { updateAllModuleLearningTargetsSummaries(); } catch(_){ __ldSilentErr(_); }
        }

        function safeAddOutcomesTextItem() {
            const input = document.getElementById('new-outcomes-text-item-input');
            try {
                if (input && !String(input.value || '').trim()) {
                    input.setCustomValidity('Saisissez un résultat avant d\'ajouter.');
                    input.reportValidity();
                    input.focus();
                    input.setCustomValidity('');
                    return;
                }
                addOutcomesTextItem();
            } catch (err) {
                showJsErrorBanner('Erreur lors de l\'ajout du résultat : ' + (err && err.message ? err.message : String(err)));
            }
        }

        function _parseCatSubItemLine(line) {
            const s = String(line || '').trim();
            if (!s) return null;
            // Expected export format: "Cat / Sub — Item" (or "Cat — Item")
            const parts = s.split(' — ');
            if (parts.length >= 2) {
                const left = parts[0].trim();
                const item = parts.slice(1).join(' — ').trim();
                let cat = '';
                let sub = '';
                if (left.includes(' / ')) {
                    const lr = left.split(' / ');
                    cat = (lr[0] || '').trim();
                    sub = (lr.slice(1).join(' / ') || '').trim();
                } else {
                    cat = left;
                }
                return { categorie: cat, sousCategorie: sub, item };
            }
            return { categorie: '', sousCategorie: '', item: s };
        }

        function initAimsAndOutcomesTextListsFromTextareas() {
            try {
                // Aims
                const aimsTa = document.getElementById('param-aims');
                const aimsList = document.getElementById('aims-list');
                if (aimsTa && aimsList) {
                    aimsList.innerHTML = '';
                    const fromLoad = (window.__kpwizAimsItemsFromLoad && Array.isArray(window.__kpwizAimsItemsFromLoad)) ? window.__kpwizAimsItemsFromLoad : null;
                    const lines = fromLoad ? [] : ((typeof _parseTextList === 'function') ? _parseTextList(aimsTa.value) : String(aimsTa.value||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean));
                    if (fromLoad) {
                        fromLoad.forEach(o => addAimItem(o));
                        window.__kpwizAimsItemsFromLoad = null;
                    } else {
                        lines.forEach(v => { const o = _parseCatSubItemLine(v); if (o) addAimItem(o); });
                    }
                    syncAimsTextareaFromList();
                }

                // Outcomes (free text)
                const outTa = document.getElementById('param-outcomes-text');
                const outList = document.getElementById('outcomes-text-list');
                if (outTa && outList) {
                    outList.innerHTML = '';
                    const fromLoad = (window.__kpwizOutcomesTextItemsFromLoad && Array.isArray(window.__kpwizOutcomesTextItemsFromLoad)) ? window.__kpwizOutcomesTextItemsFromLoad : null;
                    const lines = fromLoad ? [] : ((typeof _parseTextList === 'function') ? _parseTextList(outTa.value) : String(outTa.value||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean));
                    if (fromLoad) {
                        fromLoad.forEach(o => addOutcomesTextItem(o));
                        window.__kpwizOutcomesTextItemsFromLoad = null;
                    } else {
                        lines.forEach(v => { const o = _parseCatSubItemLine(v); if (o) addOutcomesTextItem(o); });
                    }
                    syncOutcomesTextTextareaFromList();
                }

                // Tools & materials
                const tmTa = document.getElementById('param-tools-materials');
                const tmList = document.getElementById('tools-materials-list');
                if (tmTa && tmList) {
                    tmList.innerHTML = '';
                    const fromLoad = (window.__kpwizToolsMaterialsItemsFromLoad && Array.isArray(window.__kpwizToolsMaterialsItemsFromLoad)) ? window.__kpwizToolsMaterialsItemsFromLoad : null;
                    const lines = fromLoad ? [] : ((typeof _parseTextList === 'function') ? _parseTextList(tmTa.value) : String(tmTa.value||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean));
                    if (fromLoad) {
                        fromLoad.forEach(o => addToolsMaterialsItem(o));
                        window.__kpwizToolsMaterialsItemsFromLoad = null;
                    } else {
                        lines.forEach(v => { const o = _parseCatSubItemLine(v); if (o) addToolsMaterialsItem(o); });
                    }
                    syncToolsMaterialsTextareaFromList();
                }

                // Enter key adds item (only on item fields)
                const aIn = document.getElementById('new-aim-item-input');
                if (aIn && !aIn.__kpListBound) {
                    aIn.__kpListBound = true;
                    aIn.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') { e.preventDefault(); safeAddAimItem(); }
                    });
                }
                const oIn = document.getElementById('new-outcomes-text-item-input');
                if (oIn && !oIn.__kpListBound) {
                    oIn.__kpListBound = true;
                    oIn.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') { e.preventDefault(); safeAddOutcomesTextItem(); }
                    });
                }
                const tmIn = document.getElementById('new-tools-materials-item-input');
                if (tmIn && !tmIn.__kpListBound) {
                    tmIn.__kpListBound = true;
                    tmIn.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') { e.preventDefault(); safeAddToolsMaterialsItem(); }
                    });
                }
            } catch (e) {
                console.error('initAimsAndOutcomesTextListsFromTextareas failed', e);
            }
        }


        function safeAddCompetence() {
            const input = document.getElementById('new-competence-input');
            const catIn = document.getElementById('new-competence-cat-input');
            const subIn = document.getElementById('new-competence-subcat-input');
            try {
                if (input && !input.value.trim()) {
                    input.setCustomValidity("Saisissez une compétence avant d'ajouter.");
                    input.reportValidity();
                    input.focus();
                    input.setCustomValidity('');
                    return;
                }

                const raw = String(input ? input.value : '').trim();
                const cat = String(catIn ? catIn.value : '').trim();
                const sub = String(subIn ? subIn.value : '').trim();

                addCompetence({ item: raw, categorie: cat, sousCategorie: sub });

                // Clear inputs (since addCompetence with data won't clear automatically)
                if (input) input.value = '';
                if (catIn) catIn.value = '';
                if (subIn) subIn.value = '';
                if (typeof notifyCompetencesUpdated === 'function') notifyCompetencesUpdated();
            } catch (err) {
                showJsErrorBanner('Erreur lors de l\'ajout de la compétence : ' + (err && err.message ? err.message : String(err)));
            }
        }

        function safeAddCompetenceTransversal() {
            const input = document.getElementById('new-competence-transversal-input');
            const catIn = document.getElementById('new-competence-trans-cat-input');
            const subIn = document.getElementById('new-competence-trans-subcat-input');
            try {
                if (input && !input.value.trim()) {
                    input.setCustomValidity("Saisissez une compétence avant d'ajouter.");
                    input.reportValidity();
                    input.focus();
                    input.setCustomValidity('');
                    return;
                }

                const raw = String(input ? input.value : '').trim();
                const cat = String(catIn ? catIn.value : '').trim();
                const sub = String(subIn ? subIn.value : '').trim();

                addCompetenceTransversal({ item: raw, categorie: cat, sousCategorie: sub });

                if (input) input.value = '';
                if (catIn) catIn.value = '';
                if (subIn) subIn.value = '';
                if (typeof notifyCompetencesUpdated === 'function') notifyCompetencesUpdated();
            } catch (err) {
                showJsErrorBanner('Erreur lors de l\'ajout de la compétence : ' + (err && err.message ? err.message : String(err)));
            }
        }

        function escapeHtml(str) {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

        // ------------------------------------------------------------
        // Export convenience helpers (used by Markdown/HTML exports)
        // ------------------------------------------------------------
        // NOTE: exportMarkdown() and several templates reference __esc/__selTxt.
        // They must exist in global scope to avoid ReferenceError.
        function __esc(v) {
            return escapeHtml(String(v ?? ''));
        }

        function __selTxt(el) {
            return __esc((el && el.selectedOptions && el.selectedOptions[0]) ? el.selectedOptions[0].innerText : '');
        }


function sanitizeTooltipHtml(unsafeHtml) {
    // Allow a minimal, controlled subset of tags/attributes for tooltips.
    // This prevents XSS even if a future change forgets to escape dynamic values.
    const allowedTags = new Set(['STRONG', 'BR', 'SPAN']);
    const allowedAttrs = new Set(['class']);
    const parser = new DOMParser();
    const doc = parser.parseFromString(String(unsafeHtml ?? ''), 'text/html');

    const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, null);
    const toRemove = [];
    while (walker.nextNode()) {
        const el = walker.currentNode;

        if (!allowedTags.has(el.tagName)) {
            toRemove.push(el);
            continue;
        }

        // Remove disallowed attributes
        [...el.attributes].forEach(attr => {
            const name = attr.name.toLowerCase();
            if (!allowedAttrs.has(name) || name.startsWith('on')) {
                el.removeAttribute(attr.name);
            }
        });
    }

    // Remove disallowed elements (replace by their text to avoid losing meaning)
    toRemove.forEach(el => {
        const text = doc.createTextNode(el.textContent || '');
        el.replaceWith(text);
    });

    return doc.body.innerHTML;
}


function sanitizeBasicHtml(unsafeHtml) {
    // Generic sanitiser for controlled internal UI strings (e.g., i18n labels).
    // Removes all attributes and keeps only simple formatting tags.
    const allowedTags = new Set(['BR', 'STRONG', 'B', 'EM', 'I', 'U', 'SPAN']);
    const parser = new DOMParser();
    const doc = parser.parseFromString(String(unsafeHtml ?? ''), 'text/html');

    const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, null);
    const toRemove = [];
    while (walker.nextNode()) {
        const el = walker.currentNode;
        if (!allowedTags.has(el.tagName)) {
            toRemove.push(el);
            continue;
        }
        // Remove all attributes (incl. style, href, on*, etc.)
        [...el.attributes].forEach(attr => el.removeAttribute(attr.name));
    }

    toRemove.forEach(el => {
        const textNode = doc.createTextNode(el.textContent || '');
        el.replaceWith(textNode);
    });

    return doc.body.innerHTML;
}

function showTooltip(e, content, isHtml = false) {
    const el = getTooltipEl();
    if (!el) return;
    if (isHtml) {
        el.innerHTML = sanitizeTooltipHtml(content);
    } else {
        el.textContent = content;
    }
    el.classList.remove('hidden');
    updateTooltipPos(e);
}

        function hideTooltip() {
            const el = getTooltipEl();
            if (!el) return;
            el.classList.add('hidden');
        }

        function updateTooltipPos(e) {
            const el = getTooltipEl();
            if (!el) return;
            const x = e.clientX + 15;
            const y = e.clientY + 15;
            
            
            const rect = el.getBoundingClientRect();
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            
            let finalX = x;
            let finalY = y;

            if (x + rect.width > winW) finalX = e.clientX - rect.width - 10;
            if (y + rect.height > winH) finalY = e.clientY - rect.height - 10;

            el.style.left = `${finalX}px`;
            el.style.top = `${finalY}px`;
        }

        
        const DEFAULT_TAXONOMY = {};

        // Taxonomie active (peut être remplacée par l'utilisateur via CSV)
        let ACTIVE_TAXONOMY = {};
        let ACTIVE_TAXONOMY_TRANSLATIONS = {}; // { key: label }

        const TAXONOMY_STORAGE_KEY = 'custom_taxonomy_v1';
        const TAXONOMY_TRANSLATIONS_KEY = 'custom_taxonomy_translations_v1';

        function updateTaxonomyStatus(message) {
            const el = document.getElementById('taxonomy-status');
            if (el) el.textContent = message || '';
        }

        /**
         * Sauvegarde la taxonomie dans le localStorage
         */
        function saveTaxonomyToStorage(taxonomy, translations) {
            try {
                localStorage.setItem(TAXONOMY_STORAGE_KEY, JSON.stringify(taxonomy));
                localStorage.setItem(TAXONOMY_TRANSLATIONS_KEY, JSON.stringify(translations || {}));
                return true;
            } catch (e) {
                console.error('Erreur lors de la sauvegarde de la taxonomie:', e);
                return false;
            }
        }

        function loadTaxonomyFromStorage() {
            try {
                const stored = localStorage.getItem(TAXONOMY_STORAGE_KEY);
                const storedTr = localStorage.getItem(TAXONOMY_TRANSLATIONS_KEY);
                if (!stored) {
                    ACTIVE_TAXONOMY = JSON.parse(JSON.stringify(DEFAULT_TAXONOMY));
                    ACTIVE_TAXONOMY_TRANSLATIONS = {};
                    updateTaxonomyStatus('Aucune taxonomie chargée');
                    return;
                }
                const tax = JSON.parse(stored);
                const tr = storedTr ? JSON.parse(storedTr) : {};
                if (tax && typeof tax === 'object' && Object.keys(tax).length) {
                    ACTIVE_TAXONOMY = tax;
                    ACTIVE_TAXONOMY_TRANSLATIONS = (tr && typeof tr === 'object') ? tr : {};
                    updateTaxonomyStatus(`Taxonomie personnalisée (${Object.keys(tax).length} catégories)`);
                } else {
                    resetTaxonomy();
                }
            } catch (e) {
                console.warn('Impossible de charger la taxonomie depuis le stockage:', e);
                resetTaxonomy();
            }
        }

        /**
         * Parse le fichier CSV et extrait la taxonomie
         * @param {string} csvContent - Contenu du fichier CSV
         * @returns {Object} - { taxonomy, translations } ou null en cas d'erreur
         */
        function parseTaxonomyCSV(csvContent) {
            const lines = String(csvContent || '').trim().split(/\r?\n/);

            if (lines.length < 2) {
                throw new Error('Le fichier CSV doit contenir au moins une ligne d\'en-tête et une ligne de données.');
            }

            // Vérifier l'en-tête
            const header = lines[0].split(';').map(h => h.trim().toLowerCase());
            const expectedHeaders = ['categorie', 'sous_categorie'];

            if (!expectedHeaders.every((h, i) => header[i] === h)) {
                throw new Error(`En-têtes invalides. Attendu: ${expectedHeaders.join(';')}`);
            }

            const taxonomy = {};
            const translations = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const parts = line.split(';').map(p => p.trim());
                if (parts.length < 2) {
                    console.warn(`Ligne ${i + 1} ignorée: format invalide`);
                    continue;
                }

                const [categorie, sousCategorie] = parts;

                if (!categorie || !sousCategorie) continue;
if (!taxonomy[categorie]) taxonomy[categorie] = [];
                if (!taxonomy[categorie].includes(sousCategorie)) taxonomy[categorie].push(sousCategorie);

                translations[categorie] = categorie;
                translations[sousCategorie] = sousCategorie;
            }

            if (Object.keys(taxonomy).length === 0) {
                throw new Error('Aucune donnée valide trouvée dans le fichier CSV.');
            }

            return { taxonomy, translations };
        }

        /**
         * Applique une nouvelle taxonomie
         */
        function applyTaxonomy(taxonomy, translations) {
            ACTIVE_TAXONOMY = taxonomy;
            ACTIVE_TAXONOMY_TRANSLATIONS = translations || {};

            saveTaxonomyToStorage(taxonomy, translations || {});
            refreshAllTaxonomySelectors();
            updateTaxonomyStatus(`Taxonomie appliquée (${Object.keys(taxonomy).length} catégories)`);
        }

        /**
         * Réinitialise vers la taxonomie par défaut
         */
        function resetTaxonomy() {
            ACTIVE_TAXONOMY = {};
            ACTIVE_TAXONOMY_TRANSLATIONS = {};

            try {
                localStorage.removeItem(TAXONOMY_STORAGE_KEY);
                localStorage.removeItem(TAXONOMY_TRANSLATIONS_KEY);
            } catch (e) {}

            refreshAllTaxonomySelectors();
            updateTaxonomyStatus('Aucune taxonomie chargée');
        }

        /**
         * Rafraîchit tous les sélecteurs de taxonomie dans l'interface
         */
        function refreshAllTaxonomySelectors() {
            // Sélecteur principal d'ajout (catégorie + sous-catégorie)
            const mainLevelSelect = document.getElementById('new-bloom-level');
            const mainSubSelect = document.getElementById('new-bloom-sub');

            if (mainLevelSelect) {
                const currentLevel = mainLevelSelect.value || "";
                const currentSub = mainSubSelect ? (mainSubSelect.value || "") : "";
                renderBloomOptions(mainLevelSelect, currentLevel);
                if (mainSubSelect) {
                    renderBloomSubOptions(mainSubSelect, currentLevel, currentSub);
                }
            }

            // Sélecteurs dans la liste des résultats existants
            document.querySelectorAll('#outcomes-list .outcome-bloom-level').forEach(select => {
                const currentValue = select.value || "";
                renderBloomOptions(select, currentValue);

                const subSelect = select.nextElementSibling;
                if (subSelect && subSelect.classList.contains('outcome-bloom-sub')) {
                    const currentSubValue = subSelect.value || "";
                    renderBloomSubOptions(subSelect, currentValue, currentSubValue);
                }
            });
        }


        function handleTaxonomyFileImport(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const content = e.target.result;
                    const parsed = parseTaxonomyCSV(content);

                    const catCount = Object.keys(parsed.taxonomy).length;
                    const subCount = Object.values(parsed.taxonomy).reduce((a, arr) => a + (Array.isArray(arr) ? arr.length : 0), 0);

                    const ok = confirm(`Taxonomie détectée :\n- ${catCount} catégories\n- ${subCount} sous-catégories\n\nAppliquer cette taxonomie ?`);
                    if (!ok) return;

                    applyTaxonomy(parsed.taxonomy, parsed.translations);
                } catch (err) {
                    console.error(err);
                    showAlert('Erreur', String((err && err.message) ? err.message : err));
                }
            };
            reader.onerror = function () {
                showAlert('Erreur', 'Lecture du fichier impossible.');
            };

            reader.readAsText(file);
        }

        function downloadTaxonomyTemplate() {
            const csv = `categorie;sous_categorie
`;
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'modele_taxonomie.csv';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

// --- Taxonomie des objectifs (onglet 3) ---
        const AIMS_TAXONOMY_STORAGE_KEY = 'ld_aims_taxonomy';
        const AIMS_TAXONOMY_TRANSLATIONS_KEY = 'ld_aims_taxonomy_translations';
        let ACTIVE_AIMS_TAXONOMY = {};
        let ACTIVE_AIMS_TAXONOMY_TRANSLATIONS = {};


        // --- Taxonomy manager: objectifs (delegates to createTaxonomyManager) ---
        const __aimsTaxMgr = createTaxonomyManager({
            storageKey: AIMS_TAXONOMY_STORAGE_KEY,
            translationsKey: AIMS_TAXONOMY_TRANSLATIONS_KEY,
            statusElId: 'aims-taxonomy-status',
            catDatalistId: 'aims-cat-datalist',
            subcatDatalistId: 'aims-subcat-datalist',
            catInputId: 'new-aim-cat-input',
            label: 'objectifs',
            templateFilename: 'modele_taxonomie_objectifs.csv',
            templateRows: ['categorie;sous_categorie', 'Connaissances;Concepts', 'Connaissances;Méthodes', 'Compétences;Analyse', 'Compétences;Création'],
            getTaxonomy:     () => ACTIVE_AIMS_TAXONOMY,
            getTranslations: () => ACTIVE_AIMS_TAXONOMY_TRANSLATIONS,
            setTaxonomy:     (v) => { ACTIVE_AIMS_TAXONOMY = v; },
            setTranslations: (v) => { ACTIVE_AIMS_TAXONOMY_TRANSLATIONS = v; },
        });
        function updateAimsTaxonomyStatus(msg)           { __aimsTaxMgr.updateStatus(msg); }
        function refreshAimsTaxonomyHints()             { __aimsTaxMgr.refresh(); }
        function resetAimsTaxonomy()               { __aimsTaxMgr.reset(); }
        function saveAimsTaxonomyToStorage(tax, trans)      { __aimsTaxMgr.save(tax, trans); }
        function applyAimsTaxonomy(tax, trans)     { __aimsTaxMgr.apply(tax, trans); }
        function handleAimsTaxonomyFileImport(file)          { __aimsTaxMgr.handleImport(file); }
        function downloadAimsTaxonomyTemplate()            { __aimsTaxMgr.downloadTemplate(); }


// Résultats (texte): Taxonomie (catégories / sous-catégories)
        const OUTCOMES_TEXT_TAXONOMY_STORAGE_KEY = 'ld_outcomes_text_taxonomy';
        const OUTCOMES_TEXT_TAXONOMY_TRANSLATIONS_KEY = 'ld_outcomes_text_taxonomy_translations';
        let ACTIVE_OUTCOMES_TEXT_TAXONOMY = {};
        let ACTIVE_OUTCOMES_TEXT_TAXONOMY_TRANSLATIONS = {};


        // --- Taxonomy manager: résultats (delegates to createTaxonomyManager) ---
        const __outcomesTextTaxMgr = createTaxonomyManager({
            storageKey: OUTCOMES_TEXT_TAXONOMY_STORAGE_KEY,
            translationsKey: OUTCOMES_TEXT_TAXONOMY_TRANSLATIONS_KEY,
            statusElId: 'outcomes-text-taxonomy-status',
            catDatalistId: 'outcomes-text-cat-datalist',
            subcatDatalistId: 'outcomes-text-subcat-datalist',
            catInputId: 'new-outcomes-text-cat-input',
            label: 'résultats',
            templateFilename: 'modele_taxonomie_resultats.csv',
            templateRows: ['categorie;sous_categorie', 'Connaissances;Concepts', 'Connaissances;Méthodes', 'Compétences;Analyse', 'Compétences;Création'],
            getTaxonomy:     () => ACTIVE_OUTCOMES_TEXT_TAXONOMY,
            getTranslations: () => ACTIVE_OUTCOMES_TEXT_TAXONOMY_TRANSLATIONS,
            setTaxonomy:     (v) => { ACTIVE_OUTCOMES_TEXT_TAXONOMY = v; },
            setTranslations: (v) => { ACTIVE_OUTCOMES_TEXT_TAXONOMY_TRANSLATIONS = v; },
        });
        function updateOutcomesTextTaxonomyStatus(msg)           { __outcomesTextTaxMgr.updateStatus(msg); }
        function refreshOutcomesTextTaxonomyHints()             { __outcomesTextTaxMgr.refresh(); }
        function resetOutcomesTextTaxonomy()               { __outcomesTextTaxMgr.reset(); }
        function saveOutcomesTextTaxonomyToStorage(tax, trans)      { __outcomesTextTaxMgr.save(tax, trans); }
        function applyOutcomesTextTaxonomy(tax, trans)     { __outcomesTextTaxMgr.apply(tax, trans); }
        function handleOutcomesTextTaxonomyFileImport(file)          { __outcomesTextTaxMgr.handleImport(file); }
        function downloadOutcomesTextTaxonomyTemplate()            { __outcomesTextTaxMgr.downloadTemplate(); }

        const translations = {
            fr: {
                app_title: "Concepteur Pédagogique",
                app_subtitle: "Design Pédagogique & Analytique",
                btn_new_activity: "Nouveau Module",
                btn_export_md: "Exporter pour IA/RAG",
                btn_print: "Imprimer / PDF",
                btn_save: "Enregistrer",
                btn_load: "Charger",
                grp_project: "Projet",
                grp_view: "Vue",
                grp_learning_types: "Types",
                grp_actions: "Actions",
                grp_help: "Aide",
                
                
                grp_interface: "Interface",
                btn_load_language_pack: "Charger langue",
                title_load_language_pack: "Charger un pack de langue (JSON)",
                btn_export_language_template: "Exporter modèle",
                title_export_language_template: "Exporter le modèle JSON du pack de langue",
                btn_i18n_audit: "Vérifier traductions",
                title_i18n_audit: "Vérifier la couverture des traductions",
                i18n_audit_title: "Vérification des traductions",
                i18n_audit_subtitle: "Détecte les clés manquantes dans le pack chargé et les textes statiques non couverts par data-i18n.",
                i18n_audit_used_label: "Clés UI",
                i18n_audit_missing_pack_label: "Manquantes (pack)",
                i18n_audit_missing_fr_label: "Clés inconnues (FR)",
                i18n_audit_uncovered_label: "Textes non couverts",
                i18n_audit_section_missing_pack: "Clés utilisées mais absentes du pack chargé (fallback FR)",
                i18n_audit_section_missing_fr: "Clés utilisées mais absentes du FR (à corriger dans le code)",
                i18n_audit_section_uncovered: "Éléments visibles avec texte statique sans data-i18n (échantillon)",
                btn_refresh: "Rafraîchir",

btn_download_report: "Télécharger rapport",
btn_recover_text: "Récupérer version texte",
btn_close: "Fermer",
import_recovery_unavailable: "Aucune donnée exploitable pour la récupération.",
import_recovery_failed: "La récupération a échoué.",
import_recovery_default_title: "Conception pédagogique (récupération)",
import_recovery_disclaimer: "Récupération automatique depuis un fichier JSON (import échoué). À relire et ajuster si nécessaire.",
import_recovery_generated_at: "Généré le",
import_recovery_description: "Description",
import_recovery_aims: "Objectifs",
import_recovery_outcomes: "Résultats d’apprentissage",
import_recovery_structure: "Structure",
import_recovery_no_modules: "Aucun module détecté dans ce fichier.",
import_recovery_module: "Module",
import_recovery_no_steps: "Aucune activité détectée dans ce module.",
import_recovery_activities: "Activités",
import_recovery_activity: "Activité",
import_recovery_type: "Type",
import_recovery_grouping: "Regroupement",
import_recovery_trainer: "Formateur",
import_recovery_context: "Contexte",
import_recovery_objective: "Objectif",
import_recovery_tasks: "À faire",
import_recovery_notes: "Notes",
title_ui_language_select: "Choisir la langue de l’interface",
                opt_lang_fr: "Français",
                opt_lang_loaded: "Langue chargée",
btn_export_dropdown: "Exporter...",
                title_export_dropdown: "Choisir le format d'export",
                opt_md: "Markdown (conseillé pour l'IA)",
                opt_csv: "CSV (modules/moments/activités)",
                opt_pdf: "PDF (pour imprimer)",
                opt_rtf: "Page Web HTML (contient les graphiques)",
                opt_real_rtf: "Texte (.rtf)",
                csv_synthetic_moment: "Moment (auto)",
                title_export_term: "Exporter le tableau de traduction",
                info_export_genai: "Le format d'exportation est le design pédagogique au format Markdown pour un traitement facilité par un chatbot d'IA générative.",
                label_total_time: "Chronologie",
                status_calculating: "",
                label_class_size: "Taille de la cohorte",
                label_timeline_structure: "Modules conçus",
                label_timeline_moments: "Moments",
                label_timeline_submoments: "Sous-moments",
                label_out_of_moments: "Hors moments",
                label_out_of_submoments: "Hors sous-moments",
                label_direct_steps: "Direct",
                label_timeline_details: "Détails",
                label_timeline_structure_planned: "Modules prévus",
                label_timeline_pedagogy: "Types d'apprentissage",
                empty_title: "Aucun module conçu",
                empty_subtitle: "Commencez par créer votre premier module.",
                btn_create_activity: "Créer un Module",
                btn_add_step: "Ajouter Activité",
                ph_activity_title: "Titre du module (ex: Module 1 : Introduction)",
                ph_activity_desc: "Objectif(s) du module...",
                label_step_title: "Titre de l'activité",
                ph_step_title: "Titre pour cette activité...",
                label_learning_type: "Type d'apprentissage",
                label_duration: "Durée",
                label_grouping: "Regroupement",
                opt_whole_class: "Groupe entier",
                opt_individual: "Individuel",
                opt_groups: "Sous-groupe",
                ph_nb_groups: "Nb groupes",
                label_short_groups: "Grps",
                ph_per_group: "Par groupe",
                label_short_pers: "Pers",
                label_trainer: "Formateur",
                opt_present: "Présent",
                opt_absent: "Absent",
                label_place: "Lieu",
                opt_insitu: "Présentiel (sur site)",
                opt_online: "Distanciel (en ligne)",
                opt_hybrid: "Hybride (sur site et en ligne)",
                label_time: "Temps",
                opt_sync: "Synchrone",
                opt_async: "Asynchrone",
                label_step_objective: "Description de l'activité",
                ph_step_objective: "Décrivez l'activité...",
                label_tasks: "Ce que les apprenants doivent faire",
                ph_tasks: "Décrivez les étapes, instructions et tâches...",
                label_trainer_tasks: "Ce que le ou les formateurs doivent faire",
                ph_trainer_tasks: "Décrivez les actions attendues du formateur...",
                label_notes: "Notes",
                ph_notes: "Notes formateur, ressources ou liens...",
                type_none: "Aucun",

                type_acquisition: "Acquisition",
                type_collaboration: "Collaboration",
                type_discussion: "Discussion",
                type_investigation: "Enquête",
                type_practice: "Entraînement",
                type_production: "Production",
                unit_mins: "min",
                unit_hours: "Heures",
                unit_days: "Jours",
                unit_weeks: "Semaines",
                unit_months: "Mois",
                md_title: "# Profil de Design d'Expérience d'Apprentissage",
                md_class_size: "Taille de la cohorte",
                md_total_duration: "Durée totale estimée",
                md_untitled_activity: "Module sans titre",
                md_untitled_step: "Activité sans titre",
                md_format_whole: "Classe entière",
                md_format_individual: "Individuel",
                md_format_groups: "Groupes de",
                md_tasks: "Tâches et instructions des apprenants",
                md_notes: "Notes pédagogiques",
                rtf_title: "Profil de Design d'Expérience d'Apprentissage",
                title_duplicate: "Dupliquer",
                panel_key_parameters: "Informations et paramètres de la formation",
                panel_timelines_title: "Visualisations des séquences",
                panel_analysis_charts: "Graphiques d'analyse des modalités",
                chart_learning_types: "Types d'apprentissage",
                chart_percent_duration: "(% de durée)",
                chart_trainer_presence: "Présence du formateur",
                chart_place_modes: "Modes de lieu",
                chart_time_modes: "Modes de temps",
                chart_group_modes: "Modes de groupes",
                label_course_name: "Nom de la formation",
                ph_course_name: "Entrez le nom de la formation...",
label_learning_time: "Temps d'Apprentissage (Cible)",
                label_designed_time: "Temps Conçu (Planifié)",
                label_duration_tolerance: "Tolérance (écart acceptable)",
                hint_duration_tolerance_pct: "%",
                label_hours: "h",
                label_minutes: "m",
                label_description: "Description générale",
                ph_description: "Description détaillée...",
                label_mode: "Modalité",
                label_level: "Niveau",
                label_authors: "Concepteurs(s)",
                ph_authors: "Entrez le nom du/des concepteurs...",
                label_trainers: "Formateur(s)",
                ph_trainers: "Entrez le nom du/des formateur(s)...",
                label_topic: "Thème",
                ph_topic: "Entrez le thème...",
                opt_level_unspecified: "Non spécifié",
                opt_level_mixed: "Mixte",
                opt_level_beginner: "Débutant",
                opt_level_intermediate: "Intermédiaire",
                opt_level_advanced: "Avancé",
                opt_level_expert: "Expert",
                label_target_audience: "Public cible",
                label_prerequisites: "Prérequis",
                label_tools_materials: "Outils et matériel",
                ph_tools_materials: "Entrez les outils et matériels...",
                opt_mode_placeholder: "Sélectionnez une modalité...",
                opt_mode_online: "Distanciel (en ligne)",
                opt_mode_blended: "Hybride (sur site et en ligne)",
                opt_mode_classroom: "Présentiel (sur site)",
                opt_mode_location: "Basé sur le lieu",
                opt_mode_other: "Autre",
                label_aims: "Objectifs d'apprentissage (ce qu'on va enseigner)",
                ph_aims: "Entrez les objectifs...",
                label_outcomes_text: "Résultats d'apprentissage (ce que les apprenants sauront faire)",
                ph_outcomes_text: "Entrez les résultats d'apprentissage...",
                label_outcomes: "Résultats d'apprentissage selon une taxonomie",
                ph_add_outcome: "Ajouter un résultat...",
                text_no_outcomes: "Aucun résultat défini",
                title_fold_all: "Tout replier / Tout déplier",
                btn_collapse_all: "Tout replier",
                btn_expand_all: "Tout déplier",
                title_duplicate_activity: "Dupliquer ce module",
                title_delete_activity: "Supprimer ce module",
                title_focus_module: "Mode focus",
                title_exit_focus: "Quitter le mode focus",
                title_duplicate_step: "Dupliquer cette activité",
                title_delete_step: "Supprimer cette activité",
                title_toggle_status_selectors: "Afficher ou masquer les sélecteurs d'état dans les activités",
                btn_show_status_selectors: "Afficher états",
                btn_hide_status_selectors: "Masquer états",
                title_save_project: "Enregistrer le projet dans un fichier",
                title_load_project: "Charger un projet depuis un fichier",
title_new_activity: "Ajouter un nouveau module",
                title_toggle_panel: "Afficher/Masquer les paramètres",
                title_toggle_description: "Afficher/Masquer la description",
                title_add_outcome: "Ajouter un résultat d'apprentissage",
                title_remove_outcome: "Supprimer le résultat",
                title_add_step: "Ajouter une nouvelle activité d'apprentissage",
                title_create_activity: "Créer votre premier module",
                title_help: "Aide & Information",
                help_title: "Comment utiliser le Concepteur Pédagogique",
                help_structure_title: "1. Structure du Design",
                help_structure_text: "Construisez votre cours en ajoutant des <strong>Modules</strong> (sujets) et en les remplissant d'<strong>Activités</strong> (tâches spécifiques). Réorganisez les éléments à l'aide des poignées <span class=\"inline-block align-middle\"><span class=\"material-icons-round text-base text-slate-400\">drag_indicator</span></span>.",
                help_types_title: "2. Types d'Apprentissage",
                help_types_intro: "Sélectionnez un type pédagogique pour chaque étape :",
                help_export_title: "3. Enregistrer & Exporter",
                help_export_text: "<strong>Enregistrer/Charger :</strong> Conservez votre travail dans un fichier .json.<br><strong>Exporter :</strong> Générez des fichiers aux formats Markdown (IA), PDF ou Texte Riche.",
                footer_disclaimer: "Ce site n'utilise pas de cookies de suivi ou de session. Aucune donnée personnelle n'est traitée en ligne.",
                footer_ai_disclaimer: "Cette application a été créée principalement à l'aide d'une IA générative ; le code peut contenir des erreurs.",
                footer_github: "Code disponible sur <a href=\"https://github.com/jourde/artefacts\" target=\"_blank\" class=\"underline hover:text-slate-500\">https://github.com/jourde/artefacts</a>",
                bloom_placeholder: "Catégorie...",
                bloom_sub_placeholder: "Sous-cat...",
                bloom_remember: "Mémoriser",
                bloom_understand: "Comprendre",
                bloom_apply: "Appliquer",
                bloom_analyze: "Analyser",
                bloom_evaluate: "Évaluer",
                bloom_create: "Créer",
                bloom_sub_recognizing: "Reconnaître",
                bloom_sub_recalling: "Se rappeler",
                bloom_sub_interpreting: "Interpréter",
                bloom_sub_exemplifying: "Illustrer",
                bloom_sub_classifying: "Classer",
                bloom_sub_summarizing: "Résumer",
                bloom_sub_inferring: "Inférer",
                bloom_sub_comparing: "Comparer",
                bloom_sub_explaining: "Expliquer",
                bloom_sub_executing: "Exécuter",
                bloom_sub_implementing: "Implémenter",
                bloom_sub_differentiating: "Différencier",
                bloom_sub_organizing: "Organiser",
                bloom_sub_attributing: "Attribuer",
                bloom_sub_checking: "Vérifier",
                bloom_sub_critiquing: "Critiquer",
                bloom_sub_generating: "Générer",
                bloom_sub_planning: "Planifier",
                bloom_sub_producing: "Produire",
                
                modal_confirm_title: "Confirmer l'action",
                confirm_delete_activity: "Supprimer tout le module ?",
                confirm_delete_moment: "Supprimer ce moment ?",
                btn_cancel: "Annuler",
                btn_delete: "Supprimer",

                btn_close: "Fermer",
                btn_download_report: "Télécharger le rapport",
                btn_copy_diagnostic: "Copier le diagnostic",
                btn_copy_recovery_text: "Copier le texte récupéré",
                btn_copied: "Copié",
                import_error_copy_failed: "Impossible de copier le diagnostic dans le presse-papiers.",
                import_error_title: "Erreur d’import",
                import_error_probable_cause: "Cause probable",
                import_error_detected: "Détecté",
                import_error_hints: "Indices",
                import_error_detail: "Détail",
                import_error_actions: "Actions recommandées",
                import_error_cause_parse: "JSON invalide ou fichier non conforme.",
                import_error_cause_structure: "Structure de projet non reconnue.",
                import_error_cause_version: "Fichier d’une version plus récente que cette interface.",
                import_error_cause_generic: "Import impossible.",
                import_error_action1: "Vérifiez que le fichier provient de « Sauver » dans cet outil.",
                import_error_action2: "Si le fichier a été modifié (éditeur/IA), assurez-vous que le JSON est valide (guillemets, virgules, accolades).",
                import_error_action3: "Si le fichier provient d’une ancienne version, réexportez-le depuis cette version puis réimportez-le ici.",
                import_error_action4: "Si le problème persiste, téléchargez le rapport d’import et joignez-le à votre demande de support.",
                
                legend_grouping: "Plein : Classe • Rayé : Groupes",
                legend_trainer: "Plein : Présent • Rayé : Absent",
                legend_place: "Plein : Présentiel • Rayé : En ligne",
                legend_time: "Plein : Synchrone • Rayé : Asynchrone",
                title_toggle_types: "Afficher/Masquer le menu Type d'Apprentissage",
                btn_toggle_types: "Types d'appr.",
                label_target: "Cible",
                label_designed: "Conçu",
                
                bloom_sub_cite: "Citer",
                bloom_sub_define: "Définir",
                bloom_sub_describe: "Décrire",
                bloom_sub_identify: "Identifier",
                bloom_sub_label: "Étiqueter",
                bloom_sub_list: "Lister",
                bloom_sub_match: "Apparier",
                bloom_sub_name: "Nommer",
                bloom_sub_outline: "Esquisser",
                bloom_sub_quote: "Citer",
                bloom_sub_recall: "Se rappeler",
                bloom_sub_report: "Rapporter",
                bloom_sub_reproduce: "Reproduire",
                bloom_sub_retrieve: "Récupérer",
                bloom_sub_show: "Montrer",
                bloom_sub_state: "Énoncer",
                bloom_sub_tabulate: "Tabuler",
                bloom_sub_tell: "Dire",
                bloom_sub_abstract: "Abstraire",
                bloom_sub_arrange: "Arranger",
                bloom_sub_articulate: "Articuler",
                bloom_sub_associate: "Associer",
                bloom_sub_categorize: "Catégoriser",
                bloom_sub_clarify: "Clarifier",
                bloom_sub_classify: "Classer",
                bloom_sub_compare: "Comparer",
                bloom_sub_compute: "Calculer",
                bloom_sub_conclude: "Conclure",
                bloom_sub_contrast: "Contraster",
                bloom_sub_defend: "Défendre",
                bloom_sub_diagram: "Diagrammer",
                bloom_sub_differentiate: "Différencier",
                bloom_sub_discuss: "Discuter",
                bloom_sub_distinguish: "Distinguer",
                bloom_sub_estimate: "Estimer",
                bloom_sub_exemplify: "Exemplifier",
                bloom_sub_explain: "Expliquer",
                bloom_sub_extend: "Étendre",
                bloom_sub_extrapolate: "Extrapoler",
                bloom_sub_generalize: "Généraliser",
                "bloom_sub_give examples of": "Donner des exemples",
                bloom_sub_illustrate: "Illustrer",
                bloom_sub_infer: "Inférer",
                bloom_sub_interpolate: "Interpoler",
                bloom_sub_interpret: "Interpréter",
                bloom_sub_paraphrase: "Paraphraser",
                bloom_sub_predict: "Prédire",
                bloom_sub_rearrange: "Réarranger",
                bloom_sub_reorder: "Réordonner",
                bloom_sub_rephrase: "Reformuler",
                bloom_sub_represent: "Représenter",
                bloom_sub_restate: "Réitérer",
                bloom_sub_summarize: "Résumer",
                bloom_sub_transform: "Transformer",
                bloom_sub_translate: "Traduire",
                bloom_sub_apply: "Appliquer",
                bloom_sub_calculate: "Calculer",
                "bloom_sub_carry out": "Effectuer",
                bloom_sub_complete: "Compléter",
                bloom_sub_demonstrate: "Démontrer",
                bloom_sub_dramatize: "Théâtraliser",
                bloom_sub_employ: "Employer",
                bloom_sub_examine: "Examiner",
                bloom_sub_execute: "Exécuter",
                bloom_sub_experiment: "Expérimenter",
                bloom_sub_implement: "Implémenter",
                bloom_sub_manipulate: "Manipuler",
                bloom_sub_modify: "Modifier",
                bloom_sub_operate: "Opérer",
                bloom_sub_organize: "Organiser",
                bloom_sub_solve: "Résoudre",
                bloom_sub_transfer: "Transférer",
                bloom_sub_use: "Utiliser",
                bloom_sub_analyze: "Analyser",
                "bloom_sub_break down": "Décomposer",
                bloom_sub_connect: "Connecter",
                bloom_sub_deconstruct: "Déconstruire",
                bloom_sub_detect: "Détecter",
                bloom_sub_discriminate: "Discriminer",
                bloom_sub_divide: "Diviser",
                bloom_sub_integrate: "Intégrer",
                bloom_sub_inventory: "Inventorier",
                bloom_sub_order: "Ordonner",
                bloom_sub_relate: "Relier",
                bloom_sub_separate: "Séparer",
                bloom_sub_structure: "Structurer",
                bloom_sub_appraise: "Apprécier",
                bloom_sub_apprise: "Informer",
                bloom_sub_argue: "Argumenter",
                bloom_sub_assess: "Évaluer",
                bloom_sub_consider: "Considérer",
                bloom_sub_convince: "Convaincre",
                bloom_sub_criticize: "Critiquer",
                bloom_sub_critique: "Critiquer",
                bloom_sub_decide: "Décider",
                bloom_sub_determine: "Déterminer",
                bloom_sub_evaluate: "Évaluer",
                bloom_sub_grade: "Noter",
                bloom_sub_judge: "Juger",
                bloom_sub_justify: "Justifier",
                bloom_sub_measure: "Mesurer",
                bloom_sub_rank: "Classer",
                bloom_sub_rate: "Évaluer",
                bloom_sub_recommend: "Recommander",
                bloom_sub_review: "Revoir",
                bloom_sub_score: "Scorer",
                bloom_sub_select: "Sélectionner",
                bloom_sub_standardize: "Standardiser",
                bloom_sub_support: "Soutenir",
                bloom_sub_test: "Tester",
                bloom_sub_validate: "Valider",
                bloom_sub_assemble: "Assembler",
                bloom_sub_build: "Bâtir",
                bloom_sub_collect: "Collecter",
                bloom_sub_combine: "Combiner",
                bloom_sub_compile: "Compiler",
                bloom_sub_compose: "Composer",
                bloom_sub_constitute: "Constituer",
                bloom_sub_construct: "Construire",
                bloom_sub_create: "Créer",
                bloom_sub_design: "Concevoir",
                bloom_sub_develop: "Développer",
                bloom_sub_devise: "Imaginer",
                bloom_sub_formulate: "Formuler",
                bloom_sub_generate: "Générer",
                bloom_sub_hypothesize: "Hypothétiser",
                bloom_sub_invent: "Inventer",
                bloom_sub_make: "Faire",
                bloom_sub_manage: "Gérer",
                bloom_sub_perform: "Performer",
                bloom_sub_plan: "Planifier",
                bloom_sub_prepare: "Préparer",
                bloom_sub_produce: "Produire",
                bloom_sub_propose: "Proposer",
                bloom_sub_reconstruct: "Reconstruire",
                bloom_sub_reorganize: "Réorganiser",
                bloom_sub_revise: "Réviser",
                bloom_sub_rewrite: "Réécrire",
                bloom_sub_specify: "Spécifier",
                bloom_sub_synthesize: "Synthétiser",
                bloom_sub_write: "Écrire",
                btn_apply: "Appliquer",
                btn_back_to_activity: "Retour à l'activité",
                btn_cancel: "Annuler",
                btn_clear: "Effacer",
                btn_copy_report: "Copier rapport",
                btn_download: "Télécharger",
                btn_go: "Aller",
                btn_refresh_view: "Actualiser",
                btn_reset: "Réinitialiser",
                btn_view_activities: "Activités",
                btn_view_modules: "Modules",
                btn_view_moments: "Moments",
                btn_view_panorama: "Panorama",
                btn_view_submoments: "Sous-moments",
                btn_wizard_audience: "2. Public",
                btn_wizard_competences: "4. Compétences",
                btn_wizard_identity: "1. Identité",
                btn_wizard_next: "Suivant",
                btn_wizard_objectives: "3. Objectifs et résultats",
                btn_wizard_prev: "Précédent",
                btn_wizard_showall: "Tout afficher",
                btn_wizard_tools: "5. Outils et matériel",
                chart_group_modes: "Modes de groupes",
                chart_learning_types: "Types d'apprentissage",
                chart_place_modes: "Modes de lieu",
                chart_time_modes: "Modes de temps",
                chart_trainer_presence: "Présence du formateur",
                heading_analysis_charts: "Graphiques d'analyse",
heading_metadata: "Métadonnées",
                heading_selection: "Sélection",
                label_description_compact: "Description",
                label_more: "Plus",
                label_path: "Parcours",
label_search: "Rechercher",
                label_templates: "Modèles",
                label_theme_colon: "Thème:",
                label_tools_materials: "Outils et matériel",
                msg_no_filter_match: "Aucun élément ne correspond au filtre.",
                opt_all_categories: "Toutes",
                opt_all_statuses: "Tous",
                opt_chart_style_contrast: "Contraste+",
                opt_chart_style_dark: "Sombre",
                opt_chart_style_hc: "HC",
                opt_chart_style_light: "Clair",
                opt_chart_style_std: "STD",
                opt_chart_style_transparent: "Transparent",
                opt_goto: "Aller à…",
                opt_status_completed: "Finalisé",
                opt_status_inprogress: "En cours",
                opt_status_review: "À revoir",
                ph_global_search: "Rechercher dans les modules, activités, contenus…",
                ph_grouping_details: "Détails du regroupement (composition, critères, etc.)",
                ph_links_references: "Liens, références, bibliographie, DOI, normes, etc.",
                ph_moment_description: "Description du moment...",
                ph_panorama_filter: "Filtrer (module, moment, activité…)",
                ph_timeline_filter: "Filtrer… (titre module/moment/activité)",
                tab_aims: "Objectifs",
                tab_alignment: "Alignement",
                tab_analysis: "GRAPHIQUES D'ANALYSE",
                tab_competences: "Compétences",
                tab_description: "Description",
                 tab_flow: "Déroulé",
                tab_info: "INFORMATIONS ET PARAMÈTRES DE LA FORMATION",
                tab_modalities: "Modalités",
                tab_outcomes: "Résultats",
                tab_resources: "Ressources",
                tab_visual: "VISUALISATIONS DES SÉQUENCES"
            }
        };


        // --- i18n runtime helpers (minimal, non-invasive) ---
        function normaliseLangCode(code) {
            const raw = (code == null ? '' : String(code)).trim();
            if (!raw) return '';
            // Keep simple BCP-47-ish tokens: letters, digits, hyphen/underscore.
            const cleaned = raw.replace(/[^A-Za-z0-9_-]/g, '').replace(/_/g, '-').toLowerCase();
            return cleaned.slice(0, 20);
        }

        function extractPackFromObject(obj) {
            // Accept:
            // 1) { lang:'en', translations:{...} } or { language:'en', strings:{...} }
            // 2) { meta:{ lang:'en' }, ...dictionary... }
            // 3) direct dictionary { key:'value', ... }
            let lang = '';
            let dict = null;

            if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
                lang = normaliseLangCode(obj.lang || obj.language || obj.locale || obj.code || (obj.meta && (obj.meta.lang || obj.meta.language || obj.meta.locale)));
                dict = (obj.translations && typeof obj.translations === 'object') ? obj.translations
                    : ((obj.strings && typeof obj.strings === 'object') ? obj.strings : null);
                if (!dict) {
                    // If it looks like a flat dictionary, accept it (ignore known meta keys)
                    const clone = {};
                    let found = 0;
                    Object.keys(obj).forEach(k => {
                        if (k === 'lang' || k === 'language' || k === 'locale' || k === 'code' || k === 'meta' || k === 'translations' || k === 'strings') return;
                        const v = obj[k];
                        if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {
                            clone[k] = String(v);
                            found++;
                        }
                    });
                    if (found > 0) dict = clone;
                }
            }

            if (!dict || typeof dict !== 'object' || Array.isArray(dict)) return { lang: '', dict: null };

            // Coerce to string dictionary
            const out = {};
            Object.keys(dict).forEach(k => {
                const v = dict[k];
                if (v == null) return;
                out[String(k)] = (typeof v === 'string') ? v : String(v);
            });

            return { lang, dict: out };
        }

        function ensureLangExists(code, rawPack) {
            const c = normaliseLangCode(code) || DEFAULT_LANG;
            if (c === DEFAULT_LANG) return;

            const base = translations[DEFAULT_LANG] || {};
            const pack = (rawPack && typeof rawPack === 'object') ? rawPack : {};
            translations[c] = { ...base, ...pack };
        }

        function updateUiLanguageSelector() {
            const sel = document.getElementById('ui-lang-select');
            if (!sel) return;

            // Ensure FR exists
            if (!translations[DEFAULT_LANG]) translations[DEFAULT_LANG] = translations[DEFAULT_LANG] || {};

            const loadedOpt = sel.querySelector('option[data-role="loaded-lang"]');
            if (loadedLangCode && loadedLangPackRaw && loadedOpt) {
                loadedOpt.disabled = false;
                loadedOpt.value = loadedLangCode;
                loadedOpt.textContent = loadedLangCode.toUpperCase();
                // Prevent this option from being overwritten by applyTranslations
                loadedOpt.removeAttribute('data-i18n');
            } else if (loadedOpt) {
                loadedOpt.disabled = true;
                loadedOpt.value = '';
                // Keep its data-i18n for FR placeholder
                if (!loadedOpt.getAttribute('data-i18n')) loadedOpt.setAttribute('data-i18n', 'opt_lang_loaded');
            }

            // Sync selection
            sel.value = currentLang || DEFAULT_LANG;
        }

        function setCurrentLang(code) {
            const c = normaliseLangCode(code) || DEFAULT_LANG;

            if (c !== DEFAULT_LANG) {
                // Create safe merged dictionary to protect code paths that assume translations[currentLang] exists.
                ensureLangExists(c, (c === loadedLangCode) ? loadedLangPackRaw : {});
            }

            // Guarantee invariant: translations[currentLang] exists
            if (!translations[c]) {
                if (c === DEFAULT_LANG) translations[c] = translations[DEFAULT_LANG] || {};
                else translations[c] = { ...(translations[DEFAULT_LANG] || {}) };
            }

            currentLang = c;

            try { document.documentElement.lang = c; } catch(_){ __ldSilentErr(_); }

            updateUiLanguageSelector();
            applyTranslations();
            try { __ldApplyUnitLabelFormat(); } catch(_){ __ldSilentErr(_); }
            // Some labels (durations) are computed dynamically; ensure they refresh after language change.
            try { updateStats();
        initViewLevelSegmentedUI();
        initPanoramaUI();
        try { __ldInitStatusFilterUI(); } catch(_){ __ldSilentErr(_); }
        try { updateAllStepHeaderChips(); } catch(_){ __ldSilentErr(_); }
    } catch(_){ __ldSilentErr(_); }
        }

        function handleLanguagePackObject(obj, filename) {
            const parsed = extractPackFromObject(obj);
            const codeFromFile = normaliseLangCode((filename || '').split('.')[0]);
            const langCode = parsed.lang || codeFromFile || 'xx';

            if (!parsed.dict || typeof parsed.dict !== 'object') {
                showAlert('Erreur', "Pack de langue invalide (dictionnaire introuvable).");
                return;
            }

            loadedLangCode = normaliseLangCode(langCode) || 'xx';
            loadedLangPackRaw = parsed.dict;

            ensureLangExists(loadedLangCode, loadedLangPackRaw);
            updateUiLanguageSelector();

            // Do not auto-switch; user chooses via the selector.
        }

        // Initialise selector state
        document.addEventListener('DOMContentLoaded', function () {
            try { updateUiLanguageSelector(); } catch(_){ __ldSilentErr(_); }
        });

        document.addEventListener('DOMContentLoaded', function () {
            try { initAimsAndOutcomesTextListsFromTextareas(); } catch (e) { console.warn('aims/outcomes text lists init failed', e); }
        });


        const TYPE_COLORS = {
            none: '#e5e7eb',
            acquisition: '#a1f5ed',
            collaboration: '#ffd966',
            discussion: '#7aaeea',
            investigation: '#f8807f',
            practice: '#bb98dc',
            production: '#bdea75'
        };

        
        try { if (typeof Sortable !== 'undefined' && root) {
            new Sortable(root, {
                animation: 150,
                handle: '.drag-handle-activity',
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                onStart: () => { __pendingDragSnapshot = snapshotProject(); },
                onEnd: () => {
                    if (__pendingDragSnapshot) { pushUndoSnapshot(__pendingDragSnapshot); __pendingDragSnapshot = null; }
                    updateEmptyState();
                }
            });

            
            const outcomesListEl = document.getElementById('outcomes-list');
            if (outcomesListEl) {
                new Sortable(outcomesListEl, {
                    animation: 150,
                    handle: '.drag-handle-outcome',
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag'
                });
            }
        


            const aimsListEl = document.getElementById('aims-list');
            if (aimsListEl) {
                new Sortable(aimsListEl, {
                    animation: 150,
                    handle: '.drag-handle-aim-item',
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag',
                    onEnd: function () { try { syncAimsTextareaFromList(); } catch(_){ __ldSilentErr(_); } }
                });
            }

            const outcomesTextListEl = document.getElementById('outcomes-text-list');
            if (outcomesTextListEl) {
                new Sortable(outcomesTextListEl, {
                    animation: 150,
                    handle: '.drag-handle-outcomes-text-item',
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag',
                    onEnd: function () { try { syncOutcomesTextTextareaFromList(); } catch(_){ __ldSilentErr(_); } }
                });
            }


            const toolsMaterialsListEl = document.getElementById('tools-materials-list');
            if (toolsMaterialsListEl) {
                new Sortable(toolsMaterialsListEl, {
                    animation: 150,
                    handle: '.drag-handle-tools-materials',
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag',
                    onEnd: function () {
                        try { syncToolsMaterialsTextareaFromList(); } catch(_){ __ldSilentErr(_); }
                        try { refreshAllStepToolsMaterialsOptions(); } catch(_){ __ldSilentErr(_); }
                    }
                });
            }

            const competencesListEl = document.getElementById('competences-list');
            if (competencesListEl) {
                new Sortable(competencesListEl, {
                    animation: 150,
                    handle: '.drag-handle-competence',
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag',
                    onEnd: function () { try { notifyCompetencesUpdated(); } catch(_){ __ldSilentErr(_); } }
                });
            }

            const competencesTransListEl = document.getElementById('competences-transversales-list');
            if (competencesTransListEl) {
                new Sortable(competencesTransListEl, {
                    animation: 150,
                    handle: '.drag-handle-competence',
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag',
                    onEnd: function () { try { notifyCompetencesUpdated(); } catch(_){ __ldSilentErr(_); } }
                });
            }

} } catch (e) { console.warn('Sortable init failed', e); }

function initSortableSteps(container) {
            if (typeof Sortable === 'undefined' || !container) return;
            new Sortable(container, {
                group: 'shared-steps',
                animation: 150,
                handle: '.drag-handle-step',
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                onStart: () => { __pendingDragSnapshot = snapshotProject(); },
                onEnd: () => {
                    if (__pendingDragSnapshot) { pushUndoSnapshot(__pendingDragSnapshot); __pendingDragSnapshot = null; }
                    updateStats();
                }
            });
        }

        function initSortableMoments(container) {
            if (typeof Sortable === 'undefined' || !container) return;
            new Sortable(container, {
                // Shared group enables moving moments between modules
                group: 'shared-moments',
                animation: 150,
                handle: '.drag-handle-moment',
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                onStart: () => { __pendingDragSnapshot = snapshotProject(); },
                onEnd: (evt) => {
                    if (__pendingDragSnapshot) { pushUndoSnapshot(__pendingDragSnapshot); __pendingDragSnapshot = null; }
                    // Re-index both source and destination modules after cross-module moves
                    const fromModule = evt?.from?.closest?.('.activity-group');
                    const toModule = evt?.to?.closest?.('.activity-group');
                    if (fromModule) updateMomentIndexes(fromModule);
                    if (toModule && toModule !== fromModule) updateMomentIndexes(toModule);
                    updateStats();
                }
            });
        }


function initSortableSubmoments(container) {
    if (typeof Sortable === 'undefined' || !container) return;
    // Avoid double initialisation
    if (container.__ldSortableSubmoments) return;

    container.__ldSortableSubmoments = new Sortable(container, {
        // Keep reordering inside a moment only (no cross-moment moves)
        group: { name: 'submoments', pull: false, put: false },
        animation: 150,
        handle: '.drag-handle-submoment',
        ghostClass: 'sortable-ghost',
        dragClass: 'sortable-drag',
        onStart: () => { __pendingDragSnapshot = snapshotProject(); },
        onEnd: (evt) => {
            if (__pendingDragSnapshot) { pushUndoSnapshot(__pendingDragSnapshot); __pendingDragSnapshot = null; }
            try {
                const fromMoment = evt?.from?.closest?.('.moment-group');
                const toMoment = evt?.to?.closest?.('.moment-group');
                if (fromMoment) syncMomentSubmomentsUI(fromMoment);
                if (toMoment && toMoment !== fromMoment) syncMomentSubmomentsUI(toMoment);
            } catch(_){ __ldSilentErr(_); }
            updateStats();
        }
    });
}

document.addEventListener('DOMContentLoaded', function () {
    try { document.querySelectorAll('.submoments-container').forEach(initSortableSubmoments); } catch(_){ __ldSilentErr(_); }
});

        function ensureDefaultMoment(activityGroup) {
            const momentsRoot = activityGroup.querySelector('.activity-moments-container');
            if (!momentsRoot) return null;
            const existing = momentsRoot.querySelector('.moment-group');
            if (existing) return existing;
            const clone = momentTemplate.content.cloneNode(true);
            momentsRoot.appendChild(clone);
            const moment = momentsRoot.lastElementChild;
            
            try { setupCompactTextareas(moment); } catch(_){ __ldSilentErr(_); }
initSortableSteps(moment.querySelector('.activity-steps-container'));
            try { initSortableSubmoments(moment.querySelector('.submoments-container')); } catch(_){ __ldSilentErr(_); }
            const mUnitSel = moment.querySelector('.moment-target-unit');
            if (mUnitSel) {
                __ldEnsureUnitOption(mUnitSel, 2592000, 'unit_months', 'Mois');
                mUnitSel.value = String(getDefaultDurationUnitSecs());
                __ldLockUnitSelect(mUnitSel);
            }
            updateMomentIndexes(activityGroup);
            syncMomentSubmomentsUI(moment);
            return moment;
        }

        /**
         * Solo-moment mode: when a module has exactly 1 moment with no title
         * and no description, apply .ld-solo-moment to hide moment chrome.
         * The user only sees activities. Adding a 2nd moment reveals all headers.
         */
        function syncSoloMomentUI(activityGroup) {
            if (!activityGroup) return;
            const momentsRoot = activityGroup.querySelector('.activity-moments-container');
            if (!momentsRoot) return;
            const moments = momentsRoot.querySelectorAll(':scope > .moment-group');
            if (moments.length === 1) {
                const m = moments[0];
                const title = (m.querySelector('.moment-title')?.value || '').trim();
                const desc  = (m.querySelector('.moment-description')?.value || '').trim();
                m.classList.toggle('ld-solo-moment', !title && !desc);
            } else {
                moments.forEach(m => m.classList.remove('ld-solo-moment'));
            }
        }

        function updateMomentIndexes(activityGroup) {
            if (!activityGroup) return;

            
            let moduleNum = '';
            const moduleBadge = activityGroup.querySelector('.activity-index');
            if (moduleBadge) moduleNum = String(moduleBadge.textContent || moduleBadge.innerText || '').trim();

            if (!moduleNum) {
                const allActs = Array.from(root.querySelectorAll('.activity-group'));
                const idx = allActs.indexOf(activityGroup);
                moduleNum = String((idx >= 0 ? idx : 0) + 1);
            }

            const moments = activityGroup.querySelectorAll('.activity-moments-container .moment-group');
            moments.forEach((m, i) => {
                const badge = m.querySelector('.moment-index');
                if (badge) badge.textContent = moduleNum + '.' + String(i + 1);
            });
        }

        function addMomentToActivity(btn) {
            const activityGroup = btn.closest('.activity-group');
            const momentsRoot = activityGroup.querySelector('.activity-moments-container');
            if (!momentsRoot) return;
            const clone = momentTemplate.content.cloneNode(true);
            momentsRoot.appendChild(clone);
            const moment = momentsRoot.lastElementChild;
            initSortableSteps(moment.querySelector('.activity-steps-container'));
            try { initSortableSubmoments(moment.querySelector('.submoments-container')); } catch(_){ __ldSilentErr(_); }
            const mUnitSel = moment.querySelector('.moment-target-unit');
            if (mUnitSel) {
                __ldEnsureUnitOption(mUnitSel, 2592000, 'unit_months', 'Mois');
                mUnitSel.value = String(getDefaultDurationUnitSecs());
                // BUGFIX: Do NOT lock moment target unit - users should be able to change it
                // __ldLockUnitSelect(mUnitSel); // REMOVED
            }
            
            // CRITICAL FIX: Ensure the new moment is visible
            // Moments are hidden in "modules" view
            try {
                const lvl = document.body && document.body.getAttribute ? document.body.getAttribute('data-view-level') : '';
                const currentLevel = String(lvl || '').trim();
                
                // Switch to moments view if we're in modules view
                if (currentLevel === 'modules') {
                    if (typeof applyViewLevel === 'function') {
                        applyViewLevel('moments');
                    } else if (document.body && document.body.setAttribute) {
                        document.body.setAttribute('data-view-level', 'moments');
                    }
                }
            } catch(_){ __ldSilentErr(_); }
            
            updateMomentIndexes(activityGroup);
            syncSoloMomentUI(activityGroup);
            syncMomentSubmomentsUI(moment);
            applyTranslations();
            try { __ldApplyUnitLabelFormat(); } catch(_){ __ldSilentErr(_); }
            updateStats();
        }


        /* SUBMOMENT_HELPERS_V1 */
        function syncMomentSubmomentsUI(momentEl) {
            try {
                if (!momentEl) return;
                const hasSub = momentEl.querySelectorAll('.submoments-container .submoment-card').length > 0;
                const direct = momentEl.querySelector('.moment-direct-steps');
                const directHasSteps = momentEl.querySelectorAll('.moment-direct-steps .step-card').length > 0;
                // Hide the direct container only when sub-moments exist AND it is empty.
                if (direct) direct.classList.toggle('hidden', hasSub && !directHasSteps);
            } catch(_){ __ldSilentErr(_); }
        }

        function addSubmomentToMoment(btnOrEvent) {
            try { historyCaptureNow(); } catch(_){ __ldSilentErr(_); }
            const btn = (btnOrEvent && (btnOrEvent.currentTarget || btnOrEvent.target)) ? (btnOrEvent.currentTarget || btnOrEvent.target) : btnOrEvent;
            const momentEl = btn && btn.closest ? btn.closest('.moment-group') : null;
            if (!momentEl) return;

            const container = momentEl.querySelector('.submoments-container');
            if (!container) return;


            try { initSortableSubmoments(container); } catch(_){ __ldSilentErr(_); }

            const tmpl = (typeof submomentTemplate !== 'undefined' && submomentTemplate) ? submomentTemplate : document.getElementById('submoment-template');
            if (!tmpl) return;

            const clone = tmpl.content.cloneNode(true);
            container.appendChild(clone);
            const subEl = container.lastElementChild;
            // Ensure the new sub-moment remains visible (expand moment + correct view level)
            try {
                const momentBody = momentEl.querySelector('.moment-body');
                if (momentBody) momentBody.classList.remove('collapsed');

                const toggleBtn = momentEl.querySelector('button[data-action="toggle-moment"]');
                if (toggleBtn) {
                    toggleBtn.setAttribute('aria-expanded', 'true');
                    const icon = toggleBtn.querySelector('.rotate-icon');
                    if (icon) icon.style.transform = 'rotate(180deg)';
                }

                // If the UI is currently in "moments" view, sub-moments are hidden by CSS.
                // Switch back to "activities" so the newly created sub-moment stays visible.
                const lvl = document.body && document.body.getAttribute ? document.body.getAttribute('data-view-level') : '';
                if (String(lvl || '').trim() === 'moments') {
                    if (typeof applyViewLevel === 'function') applyViewLevel('activities');
                    else if (document.body && document.body.setAttribute) document.body.setAttribute('data-view-level', 'activities');
                }
            } catch(_){ __ldSilentErr(_); }

            try { initSortableSteps(subEl.querySelector('.submoment-steps')); } catch(_){ __ldSilentErr(_); }

            // If this is the first submoment, migrate any existing direct steps into it
            try {
                const subCount = container.querySelectorAll('.submoment-card').length;
                if (subCount === 1) {
                    const directSteps = momentEl.querySelectorAll('.moment-direct-steps .step-card');
                    const subSteps = subEl.querySelector('.submoment-steps');
                    if (subSteps && directSteps.length) directSteps.forEach(st => subSteps.appendChild(st));
                }
            } catch(_){ __ldSilentErr(_); }

            syncMomentSubmomentsUI(momentEl);
            try { applyTranslations(); } catch(_){ __ldSilentErr(_); }
            try { __ldApplyUnitLabelFormat(); } catch(_){ __ldSilentErr(_); }
            try { updateStats(); } catch(_){ __ldSilentErr(_); }
        }

        function deleteSubmoment(btnOrEvent) {
            try { historyCaptureNow(); } catch(_){ __ldSilentErr(_); }
            const btn = (btnOrEvent && (btnOrEvent.currentTarget || btnOrEvent.target)) ? (btnOrEvent.currentTarget || btnOrEvent.target) : btnOrEvent;
            const subEl = btn && btn.closest ? btn.closest('.submoment-card') : null;
            if (!subEl) return;
            const momentEl = subEl.closest('.moment-group');
            const directContainer = momentEl ? momentEl.querySelector('.moment-direct-steps .activity-steps-container') : null;

            // Move contained steps to moment direct container (no data loss)
            try { if (directContainer) __ldFilterStepNodeList(subEl.querySelectorAll('.step-card')).forEach(st => directContainer.appendChild(st)); } catch(_){ __ldSilentErr(_); }

            try { subEl.remove(); } catch(_){ __ldSilentErr(_); }

            syncMomentSubmomentsUI(momentEl);
            try { updateStats(); } catch(_){ __ldSilentErr(_); }
        }

        function addStepToSubmoment(btnOrEvent) {
            try { historyCaptureNow(); } catch(_){ __ldSilentErr(_); }
            const btn = (btnOrEvent && (btnOrEvent.currentTarget || btnOrEvent.target)) ? (btnOrEvent.currentTarget || btnOrEvent.target) : btnOrEvent;
            const subEl = btn && btn.closest ? btn.closest('.submoment-card') : null;
            if (!subEl) return;
            const container = subEl.querySelector('.submoment-steps');
            if (!container) return;

            const tmpl = (typeof stepTemplate !== 'undefined' && stepTemplate) ? stepTemplate : document.getElementById('step-template');
            if (!tmpl) return;

            const clone = tmpl.content.cloneNode(true);
            container.appendChild(clone);
            const newStep = container.lastElementChild;

            try { applyStepStatus(newStep, 'in_progress'); } catch(_){ __ldSilentErr(_); }

            try { populateStepCompetencesSelect(newStep, []); } catch(_){ __ldSilentErr(_); }
            try { populateStepCompetencesTransversalesSelect(newStep, []); } catch(_){ __ldSilentErr(_); }
            try { populateStepAimsSelect(newStep, []); } catch(_){ __ldSilentErr(_); }
            try { populateStepOutcomesSelect(newStep, []); } catch(_){ __ldSilentErr(_); }
            try { populateStepToolsMaterialsSelect(newStep, []); } catch(_){ __ldSilentErr(_); }

            try { setupCompactTextareas(newStep); } catch(_){ __ldSilentErr(_); }
            try { const _tmD = newStep.querySelector('.step-tools-materials-wrap')?.closest('details'); if (_tmD) _tmD.open = false; } catch(_){ __ldSilentErr(_); }

            const unitSelect = newStep ? newStep.querySelector('.duration-unit') : null;
            if (unitSelect) {
                try { __ldEnsureUnitOption(unitSelect, 2592000, 'unit_months', 'Mois'); } catch(_){ __ldSilentErr(_); }
                try { unitSelect.value = String(getDefaultDurationUnitSecs()); } catch(_){ __ldSilentErr(_); }
                try { __ldLockUnitSelect(unitSelect); } catch(_){ __ldSilentErr(_); }
                try { __ldInitDurationUnitSelect(unitSelect); } catch(_){ __ldSilentErr(_); }
            }

            const groupSize = newStep ? newStep.querySelector('.step-group-size') : null;
            const globalSize = document.getElementById('global-class-size');
            if (groupSize && globalSize) groupSize.value = globalSize.value;

            const outLevel = newStep ? newStep.querySelector('.outcome-bloom-level') : null;
            try { if (outLevel) renderBloomOptions(outLevel, outLevel.value || ""); } catch(_){ __ldSilentErr(_); }

            // CRITICAL FIX: Ensure the new activity is visible
            // Activities in sub-moments are hidden when view level is "modules" or "moments"
            try {
                const lvl = document.body && document.body.getAttribute ? document.body.getAttribute('data-view-level') : '';
                const currentLevel = String(lvl || '').trim();
                
                // Switch to activities view if we're not already there
                if (currentLevel !== 'activities') {
                    if (typeof applyViewLevel === 'function') {
                        applyViewLevel('activities');
                    } else if (document.body && document.body.setAttribute) {
                        document.body.setAttribute('data-view-level', 'activities');
                    }
                }
                
                // Also ensure the parent moment is expanded
                const momentEl = subEl.closest('.moment-group');
                if (momentEl) {
                    const momentBody = momentEl.querySelector('.moment-body');
                    if (momentBody && momentBody.classList.contains('collapsed')) {
                        momentBody.classList.remove('collapsed');
                        const toggleBtn = momentEl.querySelector('button[data-action="toggle-moment"]');
                        if (toggleBtn) {
                            toggleBtn.setAttribute('aria-expanded', 'true');
                            const icon = toggleBtn.querySelector('.rotate-icon');
                            if (icon) icon.style.transform = 'rotate(180deg)';
                        }
                    }
                }
            } catch(_){ __ldSilentErr(_); }

            try { updateStats(); } catch(_){ __ldSilentErr(_); }
            
            // CRITICAL FIX: Scroll to the new activity and highlight it
            try {
                // Force a small delay to ensure view change is applied
                setTimeout(() => {
                    if (newStep && typeof newStep.scrollIntoView === 'function') {
                        newStep.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        newStep.classList.add('newly-created-activity');
                        setTimeout(() => {
                            if (newStep) newStep.classList.remove('newly-created-activity');
                        }, 2000);
                    }
                }, 150);
            } catch(_){ __ldSilentErr(_); }
        }
        /* END_SUBMOMENT_HELPERS_V1 */




        function deleteMoment(btn) {
            historyCaptureNow();
            // Direct deletion (no confirmation). Kept for internal calls.
            const moment = btn.closest('.moment-group');
            if (!moment) return;
            const activityGroup = moment.closest('.activity-group');
            moment.remove();
            ensureDefaultMoment(activityGroup);
            updateMomentIndexes(activityGroup);
            syncSoloMomentUI(activityGroup);
            updateStats();
        }

        function trashMoment(evtOrBtn, maybeBtn) {
            const evt = (evtOrBtn && typeof evtOrBtn === 'object' && 'preventDefault' in evtOrBtn) ? evtOrBtn : null;
            const btn = evt ? maybeBtn : evtOrBtn;

            if (!btn) return;
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }

            const moment = btn.closest('.moment-group');
            if (!moment) return;

            const activityGroup = moment.closest('.activity-group');

            const modal = document.getElementById('custom-confirm-modal');
            const msg = document.getElementById('custom-confirm-msg');

            // Fallback: if modal is missing for any reason, delete directly.
            if (!modal || !msg) {
                moment.remove();
                ensureDefaultMoment(activityGroup);
                updateMomentIndexes(activityGroup);
                syncSoloMomentUI(activityGroup);
                updateStats();
                return;
            }

            msg.innerText = (translations[currentLang] && translations[currentLang].confirm_delete_moment) || 'Supprimer ce moment ?';

            __confirmAction = () => {
                historyCaptureNow();
                moment.remove();
                ensureDefaultMoment(activityGroup);
                updateMomentIndexes(activityGroup);
                syncSoloMomentUI(activityGroup);
                updateStats();
            };

            modal.classList.remove('hidden');
        }


        

        function getPanelDisplay(el) {
            if (!el) return 'block';
            if (el.dataset && el.dataset.display) return el.dataset.display;
            if (el.classList.contains('flex')) return 'flex';
            if (el.classList.contains('grid')) return 'grid';
            return 'block';
        }

        function togglePanel(panelId) {
            const content = document.getElementById(panelId);
            const icon = document.getElementById(panelId + '-icon');

            if (!content) return;

            if (content.classList.contains('open')) {
                content.classList.remove('open');
                if (icon) icon.classList.remove('open');
                setTimeout(() => content.style.display = 'none', 300); 
            } else {
                content.style.display = getPanelDisplay(content); 
                setTimeout(() => {
                    content.classList.add('open');
                    if (icon) icon.classList.add('open');
                    setTimeout(updateTimelineHScroll, 0);
                }, 10);
            }
        }

        // --- Added: Analysis charts tabs (competences / aims / outcomes) ---
        function selectAnalysisTab(key) {
            const wrap = document.getElementById('analysis-tabs-wrap');
            if (!wrap) return;
            const buttons = wrap.querySelectorAll('[data-analysis-tab]');
            const panes = wrap.querySelectorAll('[data-analysis-pane]');

            // Folded-by-default: if no key, nothing is selected and no pane is shown.
            if (!key) {
                buttons.forEach(b => {
                    b.classList.remove('is-active');
                    b.setAttribute('aria-selected', 'false');
                });
                panes.forEach(p => p.classList.remove('is-active'));
                return;
            }

            buttons.forEach(b => {
                const active = b.getAttribute('data-analysis-tab') === key;
                b.classList.toggle('is-active', active);
                b.setAttribute('aria-selected', active ? 'true' : 'false');
            });
            panes.forEach(p => {
                const active = p.getAttribute('data-analysis-pane') === key;
                p.classList.toggle('is-active', active);
                if (active) {
                    try {
                        p.querySelectorAll('.panel-content').forEach(pc => {
                            pc.style.display = '';
                            pc.classList.add('open');
                        });
                    } catch(_){ __ldSilentErr(_); }
                }
            });
            try { localStorage.setItem('analysis_tab', key); } catch (e) {}
            try {
                if (typeof requestUpdateCharts === 'function') requestUpdateCharts();
                else if (typeof updateCharts === 'function') updateCharts();
            } catch(_){ __ldSilentErr(_); }
        }

        function bindAnalysisTabs() {
            const wrap = document.getElementById('analysis-tabs-wrap');
            if (!wrap) return;
            const buttons = wrap.querySelectorAll('[data-analysis-tab]');

            const handler = (e) => {
                const btn = e.target && e.target.closest ? e.target.closest('[data-analysis-tab]') : null;
                if (!btn) return;
                try { e.preventDefault(); } catch(_){ __ldSilentErr(_); }
                try { e.stopPropagation(); } catch(_){ __ldSilentErr(_); }
                selectAnalysisTab(btn.getAttribute('data-analysis-tab'));
            };

            // Capture early to avoid other global handlers hijacking the click.
            wrap.addEventListener('pointerdown', handler, true);
            wrap.addEventListener('mousedown', handler, true);
            wrap.addEventListener('click', handler, true);

            // Fallback: direct listeners on buttons for safety.
            buttons.forEach((btn) => {
                btn.addEventListener('click', handler);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            bindAnalysisTabs();

            const wrap = document.getElementById('analysis-tabs-wrap');
            const getSavedTab = () => {
                let saved = null;
                try { saved = localStorage.getItem('analysis_tab'); } catch(_){ __ldSilentErr(_); }
                return saved;
            };

            // Start with no selection unless the panel is already open.
            if (wrap && wrap.open) {
                selectAnalysisTab(getSavedTab() || 'modalites');
            } else {
                selectAnalysisTab(null);
            }

            // When the panel is opened later, restore the last tab (or default).
            if (wrap) {
                wrap.addEventListener('toggle', () => {
                    if (!wrap.open) return;
                    const hasActive = !!wrap.querySelector('.analysis-tab-btn.is-active');
                    if (hasActive) return;
                    selectAnalysisTab(getSavedTab() || 'modalites');
                });
            }
        });


        function toggleTimelineDetails() {
            const content = document.getElementById('timeline-details');
            const icon = document.getElementById('timeline-details-icon');
            if (!content) return;

            if (content.classList.contains('open')) {
                content.classList.remove('open');
                if (icon) icon.classList.remove('open');
                setTimeout(() => content.style.display = 'none', 250);
            } else {
                content.style.display = getPanelDisplay(content);
                setTimeout(() => {
                    content.classList.add('open');
                    if (icon) icon.classList.add('open');
                    setTimeout(updateTimelineHScroll, 0);
                }, 10);
            }
        }

        function toggleAllActivities() {
            const bodies = document.querySelectorAll('.activity-body');
            const icons = document.querySelectorAll('.activity-group .rotate-icon');
            const mainBtnIcon = document.getElementById('icon-toggle-all-main');
            const mainBtnText = document.getElementById('text-toggle-all-main');
            const headerBtnIcon = document.getElementById('icon-toggle-all');
            
            let anyOpen = false;
            bodies.forEach(b => {
                if (!b.classList.contains('collapsed')) anyOpen = true;
            });

            bodies.forEach(b => {
                if (anyOpen) {
                    b.classList.add('collapsed');
                } else {
                    b.classList.remove('collapsed');
                }
            });

            icons.forEach(icon => {
                if (anyOpen) {
                    icon.style.transform = 'rotate(0deg)';
                } else {
                    icon.style.transform = 'rotate(180deg)';
                }
            });

            
            const iconText = anyOpen ? 'unfold_more' : 'unfold_less';
            const labelKey = anyOpen ? 'btn_expand_all' : 'btn_collapse_all';

            if(mainBtnIcon) mainBtnIcon.innerText = iconText;
            if(mainBtnText) {
                mainBtnText.innerText = translations[currentLang][labelKey];
                mainBtnText.setAttribute('data-i18n', labelKey);
            }

            // Update tooltip and aria-label dynamically for better accessibility
            const tooltipText = anyOpen
              ? (translations[currentLang].tooltip_expand_all || 'Déplier tous les modules')
              : (translations[currentLang].tooltip_collapse_all || 'Replier tous les modules');

            if (mainBtnIcon && mainBtnIcon.parentElement) {
              mainBtnIcon.parentElement.setAttribute('title', tooltipText);
              mainBtnIcon.parentElement.setAttribute('aria-label', tooltipText);
            }

            if(headerBtnIcon) headerBtnIcon.innerText = iconText;
        }

        // Force all modules to be collapsed (used after loading a saved file).
        function collapseAllActivitiesForced() {
            const bodies = document.querySelectorAll('.activity-body');
            const icons = document.querySelectorAll('.activity-group .rotate-icon');
            const mainBtnIcon = document.getElementById('icon-toggle-all-main');
            const mainBtnText = document.getElementById('text-toggle-all-main');
            const headerBtnIcon = document.getElementById('icon-toggle-all');

            bodies.forEach(b => b.classList.add('collapsed'));
            icons.forEach(icon => { icon.style.transform = 'rotate(0deg)'; });

            // Set UI affordances to "expand all"
            if (mainBtnIcon) mainBtnIcon.innerText = 'unfold_more';
            if (headerBtnIcon) headerBtnIcon.innerText = 'unfold_more';
            if (mainBtnText) {
                mainBtnText.innerText = translations[currentLang]['btn_expand_all'];
                mainBtnText.setAttribute('data-i18n', 'btn_expand_all');
            }
        }

        // Collapse all expandable UI sections after loading a file.
        function collapseAllUiAfterLoad() {
            try { collapseAllActivitiesForced(); } catch(_){ __ldSilentErr(_); }

            try {
                document.querySelectorAll('.moment-body').forEach(b => b.classList.add('collapsed'));
                document.querySelectorAll('.step-body').forEach(b => b.classList.add('collapsed'));
            } catch(_){ __ldSilentErr(_); }

            try {
                document.querySelectorAll('details[open]').forEach(d => d.removeAttribute('open'));
            } catch(_){ __ldSilentErr(_); }

            try {
                document.querySelectorAll('.rotate-icon.open').forEach(i => i.classList.remove('open'));
            } catch(_){ __ldSilentErr(_); }

            try {
                document.querySelectorAll('.panel-content').forEach(p => {
                    if (p.classList.contains('activity-body') || p.classList.contains('step-body') || p.classList.contains('moment-body')) return;
                    if (p.closest && p.closest('#analysis-tabs-wrap')) return;
                    p.classList.remove('open');
                    p.style.display = 'none';
                });
            } catch(_){ __ldSilentErr(_); }

            try { if (typeof selectAnalysisTab === 'function') selectAnalysisTab(null); } catch(_){ __ldSilentErr(_); }

            try {
                document.querySelectorAll('button[data-action="toggle-panel"][data-panel]').forEach(btn => {
                    if (typeof updateAriaForPanel === 'function') updateAriaForPanel(btn.dataset.panel);
                });
                document.querySelectorAll('button[data-action="toggle-module"]').forEach(btn => {
                    if (typeof updateAriaForModule === 'function') updateAriaForModule(btn);
                });
                document.querySelectorAll('button[data-action="toggle-moment"]').forEach(btn => {
                    if (typeof updateAriaForMoment === 'function') updateAriaForMoment(btn);
                });
                document.querySelectorAll('button[data-action="toggle-step"]').forEach(btn => {
                    if (typeof updateAriaForStep === 'function') updateAriaForStep(btn);
                });
            } catch(_){ __ldSilentErr(_); }
        }

        function toggleLearningTypes() {
            document.body.classList.toggle('hide-types');
            const icon = document.getElementById('icon-toggle-types');
            if (document.body.classList.contains('hide-types')) {
                icon.innerText = 'visibility_off';
            } else {
                icon.innerText = 'visibility';
            }
        }

        // Durées cibles : masquées par défaut (affichables via le bouton "Cibles").
// Implémentation robuste : on porte l'état sur <html> (et <body> par compatibilité) pour garantir l'état dès le premier paint.

function setTargetDurationsHidden(hidden) {
    const isHidden = !!hidden;

    // État porté sur <html> pour un masquage immédiat (et sur <body> pour compatibilité)
    document.documentElement.classList.toggle('hide-target-durations', isHidden);
    document.body.classList.toggle('hide-target-durations', isHidden);

    const btn = document.getElementById('btn-toggle-target-durations');
    const icon = document.getElementById('icon-toggle-target-durations');

    // aria-pressed: "on" = cibles visibles
    if (btn) btn.setAttribute('aria-pressed', isHidden ? 'false' : 'true');
    if (icon) icon.innerText = isHidden ? 'visibility_off' : 'visibility';

    if (btn) {
        btn.title = isHidden ? 'Afficher les durées cibles' : 'Masquer les durées cibles';
        btn.setAttribute('aria-label', btn.title);
    }
}

function toggleTargetDurations() {
    const currentlyHidden =
        document.documentElement.classList.contains('hide-target-durations') ||
        document.body.classList.contains('hide-target-durations');
    setTargetDurationsHidden(!currentlyHidden); // si masqué -> afficher ; si visible -> masquer
}

// Forcer l'état par défaut à chaque chargement : masqué.
document.addEventListener('DOMContentLoaded', () => {
    setTargetDurationsHidden(true);
});
function toggleActivity(btn) {
            const activityGroup = btn.closest('.activity-group');
            if (!activityGroup) return;
            const body = activityGroup.querySelector('.activity-body');
            const icon = btn.querySelector('.rotate-icon');
            if (!body) return;

            if (body.classList.contains('collapsed')) {
                // Expand module body + all moments
                body.classList.remove('collapsed');
                if (icon) icon.style.transform = 'rotate(180deg)';

                activityGroup.querySelectorAll('.moment-body').forEach(mb => {
                    mb.classList.remove('collapsed');
                });
                activityGroup.querySelectorAll('button[data-action="toggle-moment"]').forEach(b => {
                    b.setAttribute('aria-expanded', 'true');
                    const mi = b.querySelector('.rotate-icon');
                    if (mi) mi.style.transform = 'rotate(180deg)';
                });
                activityGroup.querySelectorAll('.submoment-body').forEach(sb => {
                    sb.classList.remove('collapsed');
                });
                activityGroup.querySelectorAll('button[data-action="toggle-submoment"]').forEach(b => {
                    b.setAttribute('aria-expanded', 'true');
                    const si = b.querySelector('.rotate-icon');
                    if (si) si.style.transform = 'rotate(180deg)';
                });
            } else {
                // Collapse module body + all moments + all steps
                body.classList.add('collapsed');
                if (icon) icon.style.transform = 'rotate(0deg)';

                activityGroup.querySelectorAll('.moment-body').forEach(mb => {
                    mb.classList.add('collapsed');
                });
                activityGroup.querySelectorAll('button[data-action="toggle-moment"]').forEach(b => {
                    b.setAttribute('aria-expanded', 'false');
                    const mi = b.querySelector('.rotate-icon');
                    if (mi) mi.style.transform = 'rotate(0deg)';
                });
                activityGroup.querySelectorAll('.submoment-body').forEach(sb => {
                    sb.classList.add('collapsed');
                });
                activityGroup.querySelectorAll('button[data-action="toggle-submoment"]').forEach(b => {
                    b.setAttribute('aria-expanded', 'false');
                    const si = b.querySelector('.rotate-icon');
                    if (si) si.style.transform = 'rotate(0deg)';
                });
                activityGroup.querySelectorAll('.step-body').forEach(sb => {
                    sb.classList.add('collapsed');
                });
                activityGroup.querySelectorAll('button[data-action="toggle-step"]').forEach(b => {
                    const si = b.querySelector('.rotate-icon');
                    if (si) si.style.transform = 'rotate(0deg)';
                });
            }
        }
        function toggleMoment(btn) {
            const momentGroup = btn.closest('.moment-group');
            const body = momentGroup.querySelector('.moment-body');
            const icon = btn.querySelector('.rotate-icon');

            if (!body) return;

            if (body.classList.contains('collapsed')) {
                body.classList.remove('collapsed');
                if (icon) icon.style.transform = 'rotate(180deg)';
                btn.setAttribute('aria-expanded', 'true');
            } else {
                body.classList.add('collapsed');
                if (icon) icon.style.transform = 'rotate(0deg)';
                btn.setAttribute('aria-expanded', 'false');
            }
        }

        function toggleSubmoment(btn) {
            const submomentCard = btn.closest('.submoment-card');
            const body = submomentCard ? submomentCard.querySelector('.submoment-body') : null;
            const icon = btn.querySelector('.rotate-icon');

            if (!body) return;

            if (body.classList.contains('collapsed')) {
                body.classList.remove('collapsed');
                if (icon) icon.style.transform = 'rotate(180deg)';
                btn.setAttribute('aria-expanded', 'true');
            } else {
                body.classList.add('collapsed');
                if (icon) icon.style.transform = 'rotate(0deg)';
                btn.setAttribute('aria-expanded', 'false');
            }
        }

        function toggleSubmomentNotes(btn) {
            const submomentCard = btn.closest('.submoment-card');
            if (!submomentCard) return;
            const body = submomentCard.querySelector('.submoment-body');
            if (body && body.classList.contains('collapsed')) {
                body.classList.remove('collapsed');
                const toggleBtn = submomentCard.querySelector('button[data-action="toggle-submoment"]');
                const icon = toggleBtn ? toggleBtn.querySelector('.rotate-icon') : null;
                if (icon) icon.style.transform = 'rotate(180deg)';
                if (toggleBtn) toggleBtn.setAttribute('aria-expanded', 'true');
            }
            const wrap = submomentCard.querySelector('.submoment-notes-wrap');
            if (!wrap) return;

            const willOpen = wrap.classList.contains('hidden');
            wrap.classList.toggle('hidden', !willOpen);
            btn.setAttribute('aria-expanded', willOpen ? 'true' : 'false');
        }


function toggleMomentDescription(btn) {
            const momentGroup = btn.closest('.moment-group');
            if (!momentGroup) return;
            const wrap = momentGroup.querySelector('.moment-description-wrap');
            if (!wrap) return;

            const isHidden = wrap.classList.contains('hidden');
            if (isHidden) {
                wrap.classList.remove('hidden');
                btn.setAttribute('aria-expanded', 'true');
            } else {
                wrap.classList.add('hidden');
                btn.setAttribute('aria-expanded', 'false');
            }
        }

        

        // --- Added: Timeline ↔ Editor synced navigation ---
        function flashHighlight(el) {
            if (!el) return;
            el.classList.add('temp-highlight');
            setTimeout(() => el.classList.remove('temp-highlight'), 1600);
        }

        function scrollToEditor(moduleIndex, stepIndex = null) {
            const modules = Array.from(document.querySelectorAll('.activity-group'));
            const moduleEl = modules[moduleIndex];
            if (!moduleEl) return;

            // Ensure module is expanded
            const moduleBody = moduleEl.querySelector('.activity-body');
            if (moduleBody && moduleBody.classList.contains('collapsed')) {
                moduleBody.classList.remove('collapsed');
            }

            let targetEl = moduleEl;

            if (stepIndex !== null && stepIndex !== undefined) {
                const steps = Array.from(__ldFilterStepNodeList(moduleEl.querySelectorAll('.step-card')));
                const stepEl = steps[stepIndex];
                if (stepEl) {
                    targetEl = stepEl;

                    // Ensure the parent moment is expanded (if applicable)
                    const momentGroup = stepEl.closest('.moment-group');
                    const momentBody = momentGroup ? momentGroup.querySelector('.moment-body') : null;
                    if (momentBody && momentBody.classList.contains('collapsed')) {
                        momentBody.classList.remove('collapsed');
                    }
                }
            }

            targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            flashHighlight(targetEl);
        }

        // --- Added: Focus mode (per module) ---
        function updateFocusButtons() {
            const t = translations[currentLang] || translations.fr;
            const focusTitle = t.title_focus_module || 'Mode focus';
            const exitTitle = t.title_exit_focus || 'Quitter le mode focus';

            document.querySelectorAll('button[data-action="focus-module"]').forEach(btn => {
                const icon = btn.querySelector('.focus-toggle-icon');
                const moduleEl = btn.closest('.activity-group');
                const active = document.body.classList.contains('focus-mode') && moduleEl && moduleEl.classList.contains('focus-active');

                if (icon) icon.textContent = active ? 'close_fullscreen' : 'center_focus_strong';
                btn.title = active ? exitTitle : focusTitle;
                btn.setAttribute('aria-pressed', active ? 'true' : 'false');
            });
        }

        function exitFocusMode() {
            document.body.classList.remove('focus-mode');
            document.querySelectorAll('.activity-group').forEach(el => el.classList.remove('focus-active'));
            try { updateAllModuleCompetenceSummaries(); } catch (e) { console.error('updateAllModuleCompetenceSummaries failed', e); }
            try { updateAllModuleLearningTargetsSummaries(); } catch (e) { console.error('updateAllModuleLearningTargetsSummaries failed', e); }

            updateFocusButtons();
}

        function toggleFocusModule(btn) {
            const moduleEl = btn.closest('.activity-group');
            if (!moduleEl) return;

            const isActive = document.body.classList.contains('focus-mode') && moduleEl.classList.contains('focus-active');

            if (isActive) {
                exitFocusMode();
                return;
            }

            document.body.classList.add('focus-mode');
            document.querySelectorAll('.activity-group').forEach(el => el.classList.remove('focus-active'));
            moduleEl.classList.add('focus-active');

            moduleEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
            flashHighlight(moduleEl);
            updateFocusButtons();
        }

        // ESC exits focus mode
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.body.classList.contains('focus-mode')) {
                exitFocusMode();
            }
        });


        function toggleStep(btn) {
            const stepCard = btn.closest('.step-card');
            if (!stepCard) return;
            const body = stepCard.querySelector('.step-body');
            const icon = btn.querySelector('.rotate-icon');
            if (!body) return;

            if (body.classList.contains('collapsed')) {
                // Expand step body + all right-column sections
                body.classList.remove('collapsed');
                if (icon) icon.style.transform = 'rotate(180deg)';

                const hasTabs = !!stepCard.querySelector('.step-tabs');

                // Default tab when expanding: Description (not Flow)
                if (hasTabs && typeof window.__setStepTab === 'function') {
                    try { window.__setStepTab(stepCard, 'description', { focus: false }); } catch(_){ __ldSilentErr(_); }
                }

                const activePanel = hasTabs ? (stepCard.querySelector('.step-tabpanel:not([hidden])') || stepCard) : stepCard;
                activePanel.querySelectorAll('details.step-right-section').forEach(s => { s.open = true; });
                activePanel.querySelectorAll('details.step-right-group').forEach(g => { g.open = true; });
            } else {
                // Collapse step body + all right-column sections
                body.classList.add('collapsed');
                if (icon) icon.style.transform = 'rotate(0deg)';

                stepCard.querySelectorAll('details.step-right-section').forEach(s => { s.open = false; });
                stepCard.querySelectorAll('details.step-right-group').forEach(g => { g.open = false; });
            }
        }
        


        function toggleDescription(btn) {
            try {
                const group = btn.closest('.activity-group');
                if (!group) return;

                // Ensure module body is visible
                const body = group.querySelector('.activity-body');
                if (body && body.classList.contains('collapsed')) {
                    body.classList.remove('collapsed');
                    const toggleBtn = group.querySelector('button[data-action="toggle-module"]');
                    const icon = toggleBtn ? toggleBtn.querySelector('.rotate-icon') : null;
                    if (icon) icon.style.transform = 'rotate(180deg)';
                }

                const det = group.querySelector('details.module-description-summary');
                if (det) {
                    det.open = !det.open;
                    btn.classList.toggle('text-indigo-600', det.open);
                    btn.classList.toggle('text-slate-400', !det.open);
                }
            } catch (err) {
                console.error('toggleDescription failed', err);
            }
        }


function renderBloomOptions(selectElement, selectedValue = "") {
            const t = translations[currentLang] || translations.fr;
            const placeholder = t.bloom_placeholder || 'Catégorie...';

            const keys = Object.keys(ACTIVE_TAXONOMY || {});
            let options = `<option value="" disabled ${!selectedValue ? 'selected' : ''}>${escapeHtml(placeholder)}</option>`;

            keys.forEach(level => {
                const label = ACTIVE_TAXONOMY_TRANSLATIONS[level] || t['bloom_' + level] || level;
                options += `<option value="${escapeHtml(String(level))}" ${String(selectedValue) === String(level) ? 'selected' : ''}>${escapeHtml(String(label))}</option>`;
            });

            selectElement.innerHTML = options;

            // Si aucune taxonomie n'est chargée, on désactive les sélecteurs
            const noTaxonomy = keys.length === 0;
            selectElement.disabled = noTaxonomy;
            if (noTaxonomy) {
                selectElement.classList.add('opacity-60', 'cursor-not-allowed');
            } else {
                selectElement.classList.remove('opacity-60', 'cursor-not-allowed');
            }
        }

        function renderBloomSubOptions(subSelectElement, level, selectedValue = "") {
            const t = translations[currentLang] || translations.fr;
            const placeholder = t.bloom_sub_placeholder || 'Sous-cat...';

            // Toujours afficher le menu "Sous-catégorie" : s'il n'y a pas de catégorie sélectionnée
            // ou si la taxonomie n'est pas chargée, on le désactive et on laisse uniquement le placeholder.
            if (!level || !ACTIVE_TAXONOMY || !ACTIVE_TAXONOMY[level]) {
                subSelectElement.classList.remove('hidden');
                subSelectElement.innerHTML = `<option value="" disabled selected>${escapeHtml(placeholder)}</option>`;
                subSelectElement.disabled = true;
                subSelectElement.classList.add('opacity-60', 'cursor-not-allowed');
                return;
            }

            subSelectElement.classList.remove('hidden');
            subSelectElement.disabled = false;
            subSelectElement.classList.remove('opacity-60', 'cursor-not-allowed');
            let options = `<option value="" disabled ${!selectedValue ? 'selected' : ''}>${escapeHtml(placeholder)}</option>`;

            (ACTIVE_TAXONOMY[level] || []).forEach(sub => {
                const label = ACTIVE_TAXONOMY_TRANSLATIONS[sub] || t['bloom_sub_' + sub] || sub;
                options += `<option value="${escapeHtml(String(sub))}" ${selectedValue === sub ? 'selected' : ''}>${escapeHtml(String(label))}</option>`;
            });

            subSelectElement.innerHTML = options;
        }

function updateOutcomeBloom(levelSelect) {
            const subSelect = levelSelect.nextElementSibling;
            renderBloomSubOptions(subSelect, levelSelect.value);
        }

        // Mise à jour automatique du menu "Sous-catégorie" dans l'en-tête lors du changement de catégorie
        document.addEventListener('change', (e) => {
            const target = e && e.target;
            if (!target) return;
            if (target.id === 'new-bloom-level') {
                try { updateOutcomeBloom(target); } catch (err) {}
            }
        });

        
        function addOutcome(data = null) {
            let text = '';
            let level = '';
            let sub = '';

            const input = document.getElementById('new-outcome-input');
            const headerLevel = document.getElementById('new-bloom-level');
            const headerSub = document.getElementById('new-bloom-sub');

            if (data) {
                if (typeof data === 'string') {
                    text = data;
                } else {
                    text = data.text;
                    level = data.level || '';
                    sub = data.sub || '';
                }
            } else {
                text = input.value.trim();
                level = headerLevel.value;
                sub = headerSub.value;
            }

            if (!text) return;

            const list = document.getElementById('outcomes-list');
            if (!list) {
                // outcomes-list section removed; fall back to outcomes-text list.
                try { addOutcomesTextItem({ category: level, subcategory: sub, text: text }); } catch(_){ __ldSilentErr(_); }
                return;
            }
            const t = translations[currentLang];
            
            const li = document.createElement('li');
            li.className = "flex items-start sm:items-center justify-between bg-slate-50 px-1 py-1 rounded border border-slate-100 group gap-1";
            li.setAttribute("data-i18n-title", "title_remove_outcome");
            li.title = t.title_remove_outcome;
            
            
            const dragHandle = document.createElement('div');
            dragHandle.className = "drag-handle-outcome drag-handle text-slate-300 hover:text-slate-500 cursor-grab mt-1 sm:mt-0";
            // Safer than innerHTML: build icon node
            const dhIcon = document.createElement('span');
            dhIcon.className = "material-icons-round text-base";
            dhIcon.textContent = "drag_indicator";
            dragHandle.appendChild(dhIcon);

            
            const levelSelect = document.createElement('select');
            levelSelect.className = "outcome-bloom-level text-[9px] uppercase font-bold text-slate-500 border border-slate-200 rounded py-0.5 px-0.5 bg-white focus:ring-1 focus:ring-indigo-500 outline-none w-20";
            levelSelect.onchange = function() { updateOutcomeBloom(this); };
            renderBloomOptions(levelSelect, level);

            const subSelect = document.createElement('select');
            subSelect.className = "outcome-bloom-sub text-[9px] text-slate-500 border border-slate-200 rounded py-0.5 px-0.5 bg-white focus:ring-1 focus:ring-indigo-500 outline-none w-20";
            renderBloomSubOptions(subSelect, level, sub); 

            const span = document.createElement('span');
            span.className = "text-xs text-slate-700 outcome-text flex-1 min-w-[150px] break-words";
            span.innerText = text;

            const btn = document.createElement('button');
            btn.onclick = function() { this.closest('li').remove(); checkOutcomesEmpty(); };
            btn.className = "text-slate-300 hover:text-red-500 transition-colors opacity-0 group-hover:opacity-100 pointer-events-none group-hover:pointer-events-auto";
            // Safer than innerHTML: build icon node
            const closeIcon = document.createElement('span');
            closeIcon.className = "material-icons-round text-sm";
            closeIcon.textContent = "close";
            btn.appendChild(closeIcon);

            const contentContainer = document.createElement('div');
            contentContainer.className = "flex flex-col sm:flex-row gap-1 flex-1 items-start sm:items-center w-full";

            const selectContainer = document.createElement('div');
            selectContainer.className = "flex gap-1 shrink-0";
            selectContainer.appendChild(levelSelect);
            selectContainer.appendChild(subSelect);

            contentContainer.appendChild(selectContainer);
            contentContainer.appendChild(span);

            li.appendChild(dragHandle);
            li.appendChild(contentContainer);
            li.appendChild(btn);
            
            list.appendChild(li);

            if (!data) {
                input.value = '';
                headerLevel.value = "";
                renderBloomSubOptions(headerSub, ""); 
            }
            checkOutcomesEmpty();
        }

        function checkOutcomesEmpty() {
            const list = document.getElementById('outcomes-list');
            const emptyText = document.getElementById('no-outcomes-text');
            if (!list || !emptyText) return;
            if (list.children.length === 0) {
                emptyText.classList.remove('hidden');
            } else {
                emptyText.classList.add('hidden');
            }
        }

                


        function notifyCompetencesUpdated() {
            try { document.dispatchEvent(new CustomEvent('competencesUpdated')); } catch(_){ __ldSilentErr(_); }
        }

        function _normaliseCompetenceItem(raw) {
            if (raw == null) return null;

            // Accept formats:
            // - string: either plain item, or exported format "Cat / Sub — Item" / "Cat — Item"
            // - object: {id, label} or {categorie, sousCategorie, item} (or variants)
            const ensureId = (prefix) => (typeof _genId === 'function' ? _genId(prefix) : (prefix + '_' + Date.now()));

            if (typeof raw === 'string') {
                const s = String(raw).trim();
                if (!s) return null;
                const parsed = (typeof _parseCatSubItemLine === 'function') ? _parseCatSubItemLine(s) : { categorie: '', sousCategorie: '', item: s };
                return {
                    id: ensureId('comp'),
                    label: String(parsed.item || '').trim(),
                    categorie: String(parsed.categorie || '').trim(),
                    sousCategorie: String(parsed.sousCategorie || '').trim()
                };
            }

            if (typeof raw === 'object') {
                const id = String(raw.id ?? raw.key ?? raw.code ?? '').trim() || ensureId(String(raw.isTransversal) ? 'compT' : 'comp');

                // Prefer explicit structured fields
                const cat = String(raw.categorie ?? raw.category ?? raw.cat ?? '').trim();
                const sub = String(raw.sousCategorie ?? raw.subcategory ?? raw.subcat ?? '').trim();
                const item = String(raw.item ?? raw.text ?? raw.nom ?? raw.title ?? '').trim();

                if (item) {
                    return { id, label: item, categorie: cat, sousCategorie: sub };
                }

                // Fallback to label and attempt parsing the export format
                const labelRaw = String(raw.label ?? raw.libelle ?? '').trim();
                if (!labelRaw) return null;
                const parsed = (typeof _parseCatSubItemLine === 'function') ? _parseCatSubItemLine(labelRaw) : { categorie: '', sousCategorie: '', item: labelRaw };

                return {
                    id,
                    label: String(parsed.item || labelRaw).trim(),
                    categorie: cat || String(parsed.categorie || '').trim(),
                    sousCategorie: sub || String(parsed.sousCategorie || '').trim()
                };
            }

            return null;
        }


        function addCompetence(data = null) {
            let norm = null;

            if (!data) {
                const inputMain = document.getElementById('new-competence-input');
                const catIn = document.getElementById('new-competence-cat-input');
                const subIn = document.getElementById('new-competence-subcat-input');
                const item = String(inputMain ? inputMain.value : '').trim();
                if (!item) return;
                norm = {
                    id: (typeof _genId === 'function' ? _genId('comp') : ('comp_' + Date.now())),
                    label: item,
                    categorie: String(catIn ? catIn.value : '').trim(),
                    sousCategorie: String(subIn ? subIn.value : '').trim()
                };
            } else {
                norm = _normaliseCompetenceItem(data);
                if (!norm) return;
            }

            const list = document.getElementById('competences-list');
            if (!list) return;

            const cat = String(norm.categorie || '').trim();
            const sub = String(norm.sousCategorie || '').trim();
            const label = String(norm.label || '').trim();
            if (!label) return;

            // Deduplicate by cat/sub/label
            const key = `${cat.toLowerCase()}|${sub.toLowerCase()}|${label.toLowerCase()}`;
            const exists = Array.from(list.querySelectorAll('li')).some(li => {
                const c = (li.querySelector('.competence-cat-input')?.value || li.dataset.cat || '').trim().toLowerCase();
                const s = (li.querySelector('.competence-subcat-input')?.value || li.dataset.subcat || '').trim().toLowerCase();
                const t = (li.querySelector('.competence-text')?.value || '').trim().toLowerCase();
                return `${c}|${s}|${t}` === key;
            });
            if (exists && !data) {
                const inputMain = document.getElementById('new-competence-input');
                if (inputMain) { inputMain.value = ''; inputMain.focus(); }
                const catIn = document.getElementById('new-competence-cat-input');
                const subIn = document.getElementById('new-competence-subcat-input');
                if (catIn) catIn.value = '';
                if (subIn) subIn.value = '';
                return;
            }

            const li = document.createElement('li');
            li.className = "flex items-center justify-between bg-slate-50 px-1 py-1 rounded border border-slate-100 group gap-1";
            li.dataset.id = String(norm.id || '').trim() || (typeof _genId === 'function' ? _genId('comp') : ('comp_' + Date.now()));
            li.dataset.cat = cat;
            li.dataset.subcat = sub;

            const left = document.createElement('div');
            left.className = "flex items-center gap-1 flex-1 min-w-0";

            const dragHandle = document.createElement('div');
            dragHandle.className = "drag-handle-competence drag-handle text-slate-300 hover:text-slate-500 cursor-grab";
            const dhIcon = document.createElement('span');
            dhIcon.className = "material-icons-round text-sm";
            dhIcon.textContent = "drag_indicator";
            dragHandle.appendChild(dhIcon);

            const catInput = document.createElement('input');
            catInput.type = 'text';
            catInput.value = cat;
            catInput.placeholder = 'Catégorie…';
            catInput.className = 'competence-cat-input w-28 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            catInput.addEventListener('input', () => {
                li.dataset.cat = String(catInput.value || '').trim();
                notifyCompetencesUpdated();
            });

            const subInput = document.createElement('input');
            subInput.type = 'text';
            subInput.value = sub;
            subInput.placeholder = 'Sous-catégorie…';
            subInput.className = 'competence-subcat-input w-28 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            subInput.addEventListener('input', () => {
                li.dataset.subcat = String(subInput.value || '').trim();
                notifyCompetencesUpdated();
            });

            const input = document.createElement('input');
            input.type = 'text';
            input.value = label;
            input.className = "competence-text flex-1 min-w-[120px] px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white";
            input.addEventListener('input', () => {
                li.dataset.item = String(input.value || '').trim();
                notifyCompetencesUpdated();
            });

            left.appendChild(dragHandle);
            left.appendChild(catInput);
            left.appendChild(subInput);
            left.appendChild(input);

            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = "text-slate-300 hover:text-red-500 px-1 rounded";
            btn.title = "Supprimer";
            const icon = document.createElement('span');
            icon.className = "material-icons-round text-sm";
            icon.textContent = "delete";
            btn.appendChild(icon);
            btn.addEventListener('click', () => {
                li.remove();
                checkCompetencesEmpty();
                notifyCompetencesUpdated();
            });

            li.appendChild(left);
            li.appendChild(btn);
            list.appendChild(li);

            if (!data) {
                const inputMain = document.getElementById('new-competence-input');
                const catIn = document.getElementById('new-competence-cat-input');
                const subIn = document.getElementById('new-competence-subcat-input');
                if (inputMain) inputMain.value = '';
                if (catIn) catIn.value = '';
                if (subIn) subIn.value = '';
            }

            checkCompetencesEmpty();
            notifyCompetencesUpdated();
        }


        function checkCompetencesEmpty() {
            const list = document.getElementById('competences-list');
            const emptyText = document.getElementById('no-competences-text');
            if (!list || !emptyText) return;
            if (list.children.length === 0) {
                emptyText.classList.remove('hidden');
            } else {
                emptyText.classList.add('hidden');
            }
        }

        function getCompetencesFromUI() {
            const list = document.getElementById('competences-list');
            if (!list) return [];
            const competences = [];
            list.querySelectorAll('li').forEach(li => {
                const id = li.dataset.id || (typeof _genId === 'function' ? _genId('comp') : ('comp_' + Date.now()));
                const label = (li.querySelector('.competence-text')?.value || '').trim();
                if (!label) return;
                const cat = (li.querySelector('.competence-cat-input')?.value || li.dataset.cat || li.getAttribute('data-cat') || '').trim();
                const sub = (li.querySelector('.competence-subcat-input')?.value || li.dataset.subcat || li.getAttribute('data-subcat') || '').trim();
                competences.push({ id, label, categorie: cat, sousCategorie: sub });
            });
            return competences;
        }


        
        function addCompetenceTransversal(data = null) {
            let norm = null;

            if (!data) {
                const inputMain = document.getElementById('new-competence-transversal-input');
                const catIn = document.getElementById('new-competence-trans-cat-input');
                const subIn = document.getElementById('new-competence-trans-subcat-input');
                const item = String(inputMain ? inputMain.value : '').trim();
                if (!item) return;
                norm = {
                    id: (typeof _genId === 'function' ? _genId('compT') : ('compT_' + Date.now())),
                    label: item,
                    categorie: String(catIn ? catIn.value : '').trim(),
                    sousCategorie: String(subIn ? subIn.value : '').trim()
                };
            } else {
                norm = _normaliseCompetenceItem(Object.assign({}, (typeof data === 'object' ? data : {}), { isTransversal: true }));
                if (!norm) return;
                if (!norm.id) norm.id = (typeof _genId === 'function' ? _genId('compT') : ('compT_' + Date.now()));
            }

            const list = document.getElementById('competences-transversales-list');
            if (!list) return;

            const cat = String(norm.categorie || '').trim();
            const sub = String(norm.sousCategorie || '').trim();
            const label = String(norm.label || '').trim();
            if (!label) return;

            const key = `${cat.toLowerCase()}|${sub.toLowerCase()}|${label.toLowerCase()}`;
            const exists = Array.from(list.querySelectorAll('li')).some(li => {
                const c = (li.querySelector('.competence-cat-input')?.value || li.dataset.cat || '').trim().toLowerCase();
                const s = (li.querySelector('.competence-subcat-input')?.value || li.dataset.subcat || '').trim().toLowerCase();
                const t = (li.querySelector('.competence-text')?.value || '').trim().toLowerCase();
                return `${c}|${s}|${t}` === key;
            });
            if (exists && !data) {
                const inputMain = document.getElementById('new-competence-transversal-input');
                if (inputMain) { inputMain.value = ''; inputMain.focus(); }
                const catIn = document.getElementById('new-competence-trans-cat-input');
                const subIn = document.getElementById('new-competence-trans-subcat-input');
                if (catIn) catIn.value = '';
                if (subIn) subIn.value = '';
                return;
            }

            const li = document.createElement('li');
            li.className = "flex items-center justify-between bg-slate-50 px-1 py-1 rounded border border-slate-100 group gap-1";
            li.dataset.id = String(norm.id || '').trim() || (typeof _genId === 'function' ? _genId('compT') : ('compT_' + Date.now()));
            li.dataset.cat = cat;
            li.dataset.subcat = sub;

            const left = document.createElement('div');
            left.className = "flex items-center gap-1 flex-1 min-w-0";

            const dragHandle = document.createElement('div');
            dragHandle.className = "drag-handle-competence-trans drag-handle text-slate-300 hover:text-slate-500 cursor-grab";
            const dhIcon = document.createElement('span');
            dhIcon.className = "material-icons-round text-sm";
            dhIcon.textContent = "drag_indicator";
            dragHandle.appendChild(dhIcon);

            const catInput = document.createElement('input');
            catInput.type = 'text';
            catInput.value = cat;
            catInput.placeholder = 'Catégorie…';
            catInput.className = 'competence-cat-input w-28 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            catInput.addEventListener('input', () => {
                li.dataset.cat = String(catInput.value || '').trim();
                notifyCompetencesUpdated();
            });

            const subInput = document.createElement('input');
            subInput.type = 'text';
            subInput.value = sub;
            subInput.placeholder = 'Sous-catégorie…';
            subInput.className = 'competence-subcat-input w-28 px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white';
            subInput.addEventListener('input', () => {
                li.dataset.subcat = String(subInput.value || '').trim();
                notifyCompetencesUpdated();
            });

            const input = document.createElement('input');
            input.type = 'text';
            input.value = label;
            input.className = "competence-text flex-1 min-w-[120px] px-2 py-1 border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none text-xs bg-white";
            input.addEventListener('input', () => {
                li.dataset.item = String(input.value || '').trim();
                notifyCompetencesUpdated();
            });

            left.appendChild(dragHandle);
            left.appendChild(catInput);
            left.appendChild(subInput);
            left.appendChild(input);

            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = "text-slate-300 hover:text-red-500 px-1 rounded";
            btn.title = "Supprimer";
            const icon = document.createElement('span');
            icon.className = "material-icons-round text-sm";
            icon.textContent = "delete";
            btn.appendChild(icon);
            btn.addEventListener('click', () => {
                li.remove();
                checkCompetencesTransversalesEmpty();
                notifyCompetencesUpdated();
            });

            li.appendChild(left);
            li.appendChild(btn);
            list.appendChild(li);

            if (!data) {
                const inputMain = document.getElementById('new-competence-transversal-input');
                const catIn = document.getElementById('new-competence-trans-cat-input');
                const subIn = document.getElementById('new-competence-trans-subcat-input');
                if (inputMain) inputMain.value = '';
                if (catIn) catIn.value = '';
                if (subIn) subIn.value = '';
            }

            checkCompetencesTransversalesEmpty();
            notifyCompetencesUpdated();
        }


        function checkCompetencesTransversalesEmpty() {
            const list = document.getElementById('competences-transversales-list');
            const emptyText = document.getElementById('no-competences-transversales-text');
            if (!list || !emptyText) return;
            if (list.children.length === 0) {
                emptyText.classList.remove('hidden');
            } else {
                emptyText.classList.add('hidden');
            }
        }

        
        function getCompetencesTransversalesFromUI() {
            const list = document.getElementById('competences-transversales-list');
            if (!list) return [];
            const competences = [];
            list.querySelectorAll('li').forEach(li => {
                const id = li.dataset.id || (typeof _genId === 'function' ? _genId('compT') : ('compT_' + Date.now()));
                const label = (li.querySelector('.competence-text')?.value || '').trim();
                if (!label) return;
                const cat = (li.querySelector('.competence-cat-input')?.value || li.dataset.cat || li.getAttribute('data-cat') || '').trim();
                const sub = (li.querySelector('.competence-subcat-input')?.value || li.dataset.subcat || li.getAttribute('data-subcat') || '').trim();
                competences.push({ id, label, categorie: cat, sousCategorie: sub });
            });
            return competences;
        }


        // --- Competences system init (defensive) ---
        // Ensures step checkboxes/selects are populated even if the key-params wizard hides the catalogue steps.
        function initCompetencesSystemDefensive(){
            try {
                if (typeof checkCompetencesEmpty === 'function') checkCompetencesEmpty();
                if (typeof checkCompetencesTransversalesEmpty === 'function') checkCompetencesTransversalesEmpty();
            } catch (_e) {}

            // Populate all step selectors/checkboxes once at start (covers existing projects on load).
            try {
                if (typeof refreshAllStepCompetenceOptions === 'function') {
                    refreshAllStepCompetenceOptions();
                    try { if (typeof refreshAllModuleTargetCompetenceOptions === 'function') refreshAllModuleTargetCompetenceOptions(); } catch (_e) {}
                } else {
                    try { if (typeof refreshAllModuleTargetCompetenceOptions === 'function') refreshAllModuleTargetCompetenceOptions(); } catch (_e) {}
                    // Fallback: dispatch event handled elsewhere
                    try { document.dispatchEvent(new CustomEvent('competencesUpdated')); } catch (_e) {}
                }
            } catch (_e) {}

            // Keep step options synced when catalogue lists change (add/delete/reorder).
            const bindObserver = (listId) => {
                try {
                    const el = document.getElementById(listId);
                    if (!el || el.__competencesObserverBound) return;
                    const mo = new MutationObserver(() => {
                        try { document.dispatchEvent(new CustomEvent('competencesUpdated')); } catch (_e) {}
                        try { if (typeof updateStatsDebounced === 'function') updateStatsDebounced(); } catch (_e) {}
                    });
                    mo.observe(el, { childList: true, subtree: false });
                    el.__competencesObserverBound = true
                } catch (_e) {}
            };

            bindObserver('competences-list');
            bindObserver('competences-transversales-list');

            // Add-on: pressing Enter in the competence input adds it (no behavioural change for clicks).
            try {
                const a = document.getElementById('new-competence-input');
                if (a && !a.__enterBound) {
                    a.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') { e.preventDefault(); try { if (typeof safeAddCompetence === 'function') safeAddCompetence(); } catch(_e){} }
                    });
                    a.__enterBound = true;
                }
            } catch (_e) {}
            try {
                const b = document.getElementById('new-competence-transversal-input');
                if (b && !b.__enterBound) {
                    b.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') { e.preventDefault(); try { if (typeof safeAddCompetenceTransversal === 'function') safeAddCompetenceTransversal(); } catch(_e){} }
                    });
                    b.__enterBound = true;
                }
            } catch (_e) {}
        }

        
        // --- Checkbox UI for competence selection (keeps hidden <select multiple> as data source) ---
        function _renderStepCompetenceCheckboxesFromSelect(stepEl, selectEl, containerSelector, checkboxClass, emptyText, renderOpts) {
            if (!stepEl || !selectEl) return;
            const box = stepEl.querySelector(containerSelector);
            if (!box) return;
            box.innerHTML = '';

            const ro = (renderOpts && typeof renderOpts === 'object') ? renderOpts : {};
            const selectedOnly = !!ro.selectedOnly;
            const disableAll = !!ro.disabled;

            const opts = Array.from(selectEl.options || []).filter(o => !(o.disabled && !o.value));
            const usable = opts.filter(o => String(o.value || '').trim());
            const toRender = selectedOnly ? usable.filter(o => !!o.selected) : usable;

            if (!toRender.length) {
                const div = document.createElement('div');
                div.className = 'text-slate-400 italic';
                div.textContent = emptyText || (selectedOnly ? 'Aucune compétence sélectionnée.' : 'Aucune compétence disponible.');
                box.appendChild(div);
                return;
            }

            toRender.forEach(o => {
                const id = String(o.value || '').trim();
                if (!id) return;
                const label = (o.textContent || '').trim() || id;

                const lab = document.createElement('label');
                lab.className = 'flex items-start gap-2 ' + (disableAll ? 'cursor-default' : 'cursor-pointer');

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'mt-[2px] ' + checkboxClass;
                cb.value = id;
                cb.checked = !!o.selected;
                if (disableAll) cb.disabled = true;

                const sp = document.createElement('span');
                sp.className = 'leading-snug';
                sp.textContent = label;

                lab.appendChild(cb);
                lab.appendChild(sp);
                box.appendChild(lab);
            });
        }

        function _syncHiddenSelectFromCompetenceCheckbox(cbEl) {
            if (!cbEl) return;
            const stepEl = cbEl.closest('.step-card');
            if (!stepEl) return;

            const isTransversal = cbEl.classList.contains('step-competence-cb-transversal');
            const sel = stepEl.querySelector(isTransversal ? '.step-competences-transversales-select' : '.step-competences-select');
            if (!sel) return;

            const id = String(cbEl.value || '').trim();
            if (!id) return;

            let opt = Array.from(sel.options || []).find(o => String(o.value || '').trim() == id);
            if (!opt) {
                opt = document.createElement('option');
                opt.value = id;
                opt.textContent = '[Compétence inconnue] ' + id;
                sel.appendChild(opt);
            }
            opt.selected = !!cbEl.checked;

            // Trigger the existing delegated change handlers (charts, autosave, etc.)
            try { sel.dispatchEvent(new Event('change', { bubbles: true })); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl.closest('.activity-group'); if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
        }

        // Delegated checkbox change handler (keeps the rest of the app unchanged)
        document.addEventListener('change', function (e) {
            const t = e.target;
            if (!t) return;
            if (t.matches('input.step-competence-cb-sujet, input.step-competence-cb-transversal')) {
                _syncHiddenSelectFromCompetenceCheckbox(t);
            }
            else if (t.matches('input.module-competence-cb-sujet, input.module-competence-cb-transversal')) {
                _syncHiddenSelectFromModuleCompetenceCheckbox(t);
            }
        }, true);

// --- Step-level transversal competence selection -------------------
        function populateStepCompetencesTransversalesSelect(stepEl, selectedIds = null) {
            if (!stepEl) return;
            const sel = stepEl.querySelector('.step-competences-transversales-select');
            if (!sel) return;

            const catalogue = (typeof getCompetencesTransversalesFromUI === 'function') ? getCompetencesTransversalesFromUI() : [];
            const currentSelected = selectedIds ? _normaliseStepCompetenceIds(selectedIds) : _normaliseStepCompetenceIds(Array.from(sel.selectedOptions || []).map(o => o.value));

            sel.innerHTML = '';
            if (!catalogue || catalogue.length === 0) {
                if (currentSelected && currentSelected.length) {
                    currentSelected.forEach(id => {
                        if (!id) return;
                        const optU = document.createElement('option');
                        optU.value = id;
                        optU.textContent = '[Compétence inconnue] ' + id;
                        optU.selected = true;
                        sel.appendChild(optU);
                    });
                }
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Aucune compétence définie (ajoutez-en dans les paramètres)';
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepCompetenceCheckboxesFromSelect(stepEl, sel, '.step-competences-transversales-checkboxes', 'step-competence-cb-transversal'); } catch(_){ __ldSilentErr(_); }
                return;
            }

            const knownIds = new Set();
            catalogue.forEach(c => {
                const id = String(c.id || '').trim();
                const label = String(c.label || '').trim();
                if (!id) return;
                knownIds.add(id);
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = label || id;
                opt.selected = currentSelected.includes(id);
                sel.appendChild(opt);
            });

            currentSelected.forEach(id => {
                if (!id || knownIds.has(id)) return;
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = '[Compétence inconnue] ' + id;
                opt.selected = true;
                sel.appendChild(opt);
            });
        
            try { _renderStepCompetenceCheckboxesFromSelect(stepEl, sel, '.step-competences-transversales-checkboxes', 'step-competence-cb-transversal'); } catch(_){ __ldSilentErr(_); }
}

        function getSelectedStepCompetencesTransversalesIds(stepEl) {
            const sel = stepEl ? stepEl.querySelector('.step-competences-transversales-select') : null;
            if (!sel) return [];
            return Array.from(sel.selectedOptions || [])
                .map(o => String(o.value || '').trim())
                .filter(v => v);
        }
        // --- Step-level competence selection ---------------------------------
        function _normaliseStepCompetenceIds(raw) {
            if (!raw) return [];
            if (Array.isArray(raw)) return raw.map(String).map(s => s.trim()).filter(Boolean);
            if (typeof raw === 'string') {
                // Accept CSV / semicolon separated strings from legacy exports
                return raw.split(/[;,\n\r]+/).map(s => s.trim()).filter(Boolean);
            }
            return [];
        }

        function populateStepCompetencesSelect(stepEl, selectedIds = null) {
            if (!stepEl) return;
            const sel = stepEl.querySelector('.step-competences-select');
            if (!sel) return;

            const catalogue = (typeof getCompetencesFromUI === 'function') ? getCompetencesFromUI() : [];
            const currentSelected = selectedIds ? _normaliseStepCompetenceIds(selectedIds) : _normaliseStepCompetenceIds(Array.from(sel.selectedOptions || []).map(o => o.value));

            // Rebuild options
            sel.innerHTML = '';
            if (!catalogue || catalogue.length === 0) {
                // Preserve any existing selections, even if the catalogue is currently empty
                if (currentSelected && currentSelected.length) {
                    currentSelected.forEach(id => {
                        if (!id) return;
                        const optU = document.createElement('option');
                        optU.value = id;
                        optU.textContent = '[Compétence inconnue] ' + id;
                        optU.selected = true;
                        sel.appendChild(optU);
                    });
                }
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Aucune compétence définie (ajoutez-en dans les paramètres)';
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepCompetenceCheckboxesFromSelect(stepEl, sel, '.step-competences-checkboxes', 'step-competence-cb-sujet'); } catch(_){ __ldSilentErr(_); }
                return;
            }

            const knownIds = new Set();
            catalogue.forEach(c => {
                const id = String(c.id || '').trim();
                const label = String(c.label || '').trim();
                if (!id) return;
                knownIds.add(id);
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = label || id;
                opt.selected = currentSelected.includes(id);
                sel.appendChild(opt);
            });

            // Preserve unknown selected ids (do not drop data silently)
            currentSelected.forEach(id => {
                if (!id || knownIds.has(id)) return;
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = '[Compétence inconnue] ' + id;
                opt.selected = true;
                sel.appendChild(opt);
            });
        
            try { _renderStepCompetenceCheckboxesFromSelect(stepEl, sel, '.step-competences-checkboxes', 'step-competence-cb-sujet'); } catch(_){ __ldSilentErr(_); }
}

        function refreshAllStepCompetenceOptions() {
            __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stepEl => {
                populateStepCompetencesSelect(stepEl, null);
                populateStepCompetencesTransversalesSelect(stepEl, null);
            });
        }

        function getSelectedStepCompetenceIds(stepEl) {
            const sel = stepEl ? stepEl.querySelector('.step-competences-select') : null;
            if (!sel) return [];
            // Ignore the "no competence" placeholder (value '')
            return Array.from(sel.selectedOptions || [])
                .map(o => String(o.value || '').trim())
                .filter(v => v);
        }

        // Refresh all step selectors whenever the competence catalogue changes
        document.addEventListener('competencesUpdated', function () {
            try { refreshAllStepCompetenceOptions(); } catch(_){ __ldSilentErr(_); }
            try { refreshAllModuleTargetCompetenceOptions(); } catch(_){ __ldSilentErr(_); }
        });


        // --- Step-level objectives (aims) and targeted learning outcomes ---
        function _renderStepTextCheckboxesFromSelect(stepEl, selectEl, containerSelector, checkboxClass, emptyText, renderOpts) {
            if (!stepEl || !selectEl) return;
            const box = stepEl.querySelector(containerSelector);
            if (!box) return;
            box.innerHTML = '';

            const ro = (renderOpts && typeof renderOpts === 'object') ? renderOpts : {};
            const selectedOnly = !!ro.selectedOnly;
            const disableAll = !!ro.disabled;

            const opts = Array.from(selectEl.options || []).filter(o => !(o.disabled && !o.value));
            const usable = opts.filter(o => String(o.value || '').trim());

            // If we are in selected-only mode, only render selected options
            const toRender = selectedOnly ? usable.filter(o => !!o.selected) : usable;

            if (!toRender.length) {
                const div = document.createElement('div');
                div.className = 'text-slate-400 italic';
                div.textContent = emptyText || (selectedOnly ? 'Aucun élément sélectionné.' : 'Aucun élément disponible.');
                box.appendChild(div);
                return;
            }

            toRender.forEach(o => {
                const id = String(o.value || '').trim();
                if (!id) return;
                const label = (o.textContent || '').trim() || id;

                const lab = document.createElement('label');
                lab.className = 'flex items-start gap-2 ' + (disableAll ? 'cursor-default' : 'cursor-pointer');

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'mt-[2px] ' + checkboxClass;
                cb.value = id;
                cb.checked = !!o.selected;
                if (disableAll) cb.disabled = true;

                const sp = document.createElement('span');
                sp.className = 'leading-snug';
                sp.textContent = label;

                lab.appendChild(cb);
                lab.appendChild(sp);
                box.appendChild(lab);
            });
        }

        function _syncHiddenSelectFromTextCheckbox(cbEl, selectSelector) {
            if (!cbEl) return;
            const stepEl = cbEl.closest('.step-card');
            if (!stepEl) return;
            const sel = stepEl.querySelector(selectSelector);
            if (!sel) return;

            const val = String(cbEl.value || '').trim();
            if (!val) return;

            let opt = Array.from(sel.options || []).find(o => String(o.value || '').trim() === val);
            if (!opt) {
                opt = document.createElement('option');
                opt.value = val;
                opt.textContent = val;
                sel.appendChild(opt);
            }
            opt.selected = !!cbEl.checked;
            try { sel.dispatchEvent(new Event('change', { bubbles: true })); } catch(_){ __ldSilentErr(_); }
            try { const modEl = stepEl.closest('.activity-group'); if (modEl) syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
        }

        function populateStepAimsSelect(stepEl, selected = null) {
            if (!stepEl) return;
            const sel = stepEl.querySelector('.step-aims-select');
            if (!sel) return;

            const options = (typeof getGlobalLearningAimsOptions === 'function') ? (getGlobalLearningAimsOptions() || []) : [];
            const currentSelected = selected ? _parseTextList(Array.isArray(selected) ? selected.join('\n') : String(selected)) : Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);

            sel.innerHTML = '';
            if (!options.length) {
                (currentSelected || []).forEach(v => {
                    if (!v) return;
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.textContent = v;
                    opt.selected = true;
                    sel.appendChild(opt);
                });
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Aucun objectif défini (ajoutez-en dans les paramètres)';
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepTextCheckboxesFromSelect(stepEl, sel, '.step-aims-checkboxes', 'step-aim-cb', 'Aucun objectif disponible.'); } catch(_){ __ldSilentErr(_); }
                return;
            }

            const seen = new Set();
            options.forEach(label => {
                const v = String(label || '').trim();
                if (!v) return;
                const k = v.toLowerCase();
                if (seen.has(k)) return;
                seen.add(k);
                const opt = document.createElement('option');
                opt.value = v;
                opt.textContent = v;
                opt.selected = currentSelected.includes(v);
                sel.appendChild(opt);
            });

            (currentSelected || []).forEach(v => {
                const vv = String(v || '').trim();
                if (!vv) return;
                const k = vv.toLowerCase();
                if (seen.has(k)) return;
                const opt = document.createElement('option');
                opt.value = vv;
                opt.textContent = vv;
                opt.selected = true;
                sel.appendChild(opt);
            });

            try { _renderStepTextCheckboxesFromSelect(stepEl, sel, '.step-aims-checkboxes', 'step-aim-cb', 'Aucun objectif disponible.'); } catch(_){ __ldSilentErr(_); }
        }

        function populateStepOutcomesSelect(stepEl, selected = null) {
            if (!stepEl) return;
            const sel = stepEl.querySelector('.step-outcomes-select');
            if (!sel) return;

            const options = (typeof getGlobalLearningOutcomesOptions === 'function') ? (getGlobalLearningOutcomesOptions() || []) : [];
            const currentSelected = selected ? _parseTextList(Array.isArray(selected) ? selected.join('\n') : String(selected)) : Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);

            sel.innerHTML = '';
            if (!options.length) {
                (currentSelected || []).forEach(v => {
                    if (!v) return;
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.textContent = v;
                    opt.selected = true;
                    sel.appendChild(opt);
                });
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Aucun résultat défini (ajoutez-en dans les paramètres)';
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepTextCheckboxesFromSelect(stepEl, sel, '.step-outcomes-checkboxes', 'step-outcome-cb', 'Aucun résultat disponible.'); } catch(_){ __ldSilentErr(_); }
                return;
            }

            const seen = new Set();
            options.forEach(label => {
                const v = String(label || '').trim();
                if (!v) return;
                const k = v.toLowerCase();
                if (seen.has(k)) return;
                seen.add(k);
                const opt = document.createElement('option');
                opt.value = v;
                opt.textContent = v;
                opt.selected = currentSelected.includes(v);
                sel.appendChild(opt);
            });

            (currentSelected || []).forEach(v => {
                const vv = String(v || '').trim();
                if (!vv) return;
                const k = vv.toLowerCase();
                if (seen.has(k)) return;
                const opt = document.createElement('option');
                opt.value = vv;
                opt.textContent = vv;
                opt.selected = true;
                sel.appendChild(opt);
            });

            try { _renderStepTextCheckboxesFromSelect(stepEl, sel, '.step-outcomes-checkboxes', 'step-outcome-cb', 'Aucun résultat disponible.'); } catch(_){ __ldSilentErr(_); }
        }

        function getSelectedStepAims(stepEl) {
            const sel = stepEl ? stepEl.querySelector('.step-aims-select') : null;
            if (!sel) return [];
            return Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);
        }

        function getSelectedStepOutcomes(stepEl) {
            const sel = stepEl ? stepEl.querySelector('.step-outcomes-select') : null;
            if (!sel) return [];
            return Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);
        }

        function refreshAllStepAimsOptions() {
            __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stepEl => {
                try { populateStepAimsSelect(stepEl, null); } catch(_){ __ldSilentErr(_); }
            });
        }

        

        // --- Step-level tools/materials selection (same checkbox+creation system as Alignement) ---
        function getGlobalToolsMaterialsOptions() {
            const ta = document.getElementById('param-tools-materials');
            const raw = ta ? (ta.value || '') : '';
            let lines = [];
            try {
                if (typeof _parseTextList === 'function') {
                    lines = _parseTextList(raw);
                } else {
                    lines = String(raw || '').split(/\r\n|\r|\n/).map(s => s.trim()).filter(Boolean);
                }
            } catch (_) {
                lines = String(raw || '').split(/\r\n|\r|\n/).map(s => s.trim()).filter(Boolean);
            }
            const seen = new Set();
            const out = [];
            (lines || []).forEach(v0 => {
                const v = String(v0 || '').trim();
                if (!v) return;
                const k = v.toLowerCase();
                if (seen.has(k)) return;
                seen.add(k);
                out.push(v);
            });
            return out;
        }

        function populateStepToolsMaterialsSelect(stepEl, selected = null) {
            if (!stepEl) return;
            const sel = stepEl.querySelector('.step-tools-materials-select');
            if (!sel) return;

            const options = (typeof getGlobalToolsMaterialsOptions === 'function') ? (getGlobalToolsMaterialsOptions() || []) : [];
            const currentSelected = selected
                ? (Array.isArray(selected) ? selected.map(v => String(v || '').trim()).filter(Boolean) : _parseTextList(String(selected)))
                : Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);

            sel.innerHTML = '';
            if (!options.length) {
                (currentSelected || []).forEach(v => {
                    if (!v) return;
                    const opt = document.createElement('option');
                    opt.value = v;
                    opt.textContent = v;
                    opt.selected = true;
                    sel.appendChild(opt);
                });
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = "Aucun outil/matériel défini (ajoutez-en dans les paramètres)";
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepToolsMaterialsCheckboxesWithNotes(stepEl, sel, '.step-tools-materials-checkboxes', 'step-toolmat-cb', "Aucun outil/matériel disponible."); } catch(_){ __ldSilentErr(_); }
                try { __initStepToolsSelectedOnlyToggle(stepEl); applyStepToolsSelectedOnly(stepEl); updateStepHeaderChips(stepEl); } catch(_){ __ldSilentErr(_); }
                return;
            }

            const seen = new Set();
            options.forEach(label => {
                const v = String(label || '').trim();
                if (!v) return;
                const k = v.toLowerCase();
                if (seen.has(k)) return;
                seen.add(k);
                const opt = document.createElement('option');
                opt.value = v;
                opt.textContent = v;
                opt.selected = (currentSelected || []).includes(v);
                sel.appendChild(opt);
            });

            (currentSelected || []).forEach(v => {
                const vv = String(v || '').trim();
                if (!vv) return;
                const k = vv.toLowerCase();
                if (seen.has(k)) return;
                const opt = document.createElement('option');
                opt.value = vv;
                opt.textContent = vv;
                opt.selected = true;
                sel.appendChild(opt);
            });

            try { _renderStepToolsMaterialsCheckboxesWithNotes(stepEl, sel, '.step-tools-materials-checkboxes', 'step-toolmat-cb', "Aucun outil/matériel disponible."); } catch(_){ __ldSilentErr(_); }
                try { __initStepToolsSelectedOnlyToggle(stepEl); applyStepToolsSelectedOnly(stepEl); updateStepHeaderChips(stepEl); } catch(_){ __ldSilentErr(_); }
        }

        function getSelectedStepToolsMaterials(stepEl) {
            const sel = stepEl ? stepEl.querySelector('.step-tools-materials-select') : null;
            if (!sel) return [];
            return Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);
        }

        function refreshAllStepToolsMaterialsOptions() {
            __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stepEl => {
                try { populateStepToolsMaterialsSelect(stepEl, null); } catch(_){ __ldSilentErr(_); }
            });
        }

        // --- Tools/materials notes (per activity) ---
        function __normaliseToolsMaterialsNotes(raw) {
            if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return {};
            const out = {};
            try {
                Object.keys(raw).forEach(k => {
                    const kk = String(k || '').trim();
                    if (!kk) return;
                    const vv = raw[k];
                    out[kk] = (vv == null) ? '' : String(vv);
                });
            } catch(_){ __ldSilentErr(_); }
            return out;
        }

        function __getStepToolMatNotesMap(stepEl) {
            if (!stepEl) return {};
            let raw = null;
            try { raw = stepEl.dataset ? stepEl.dataset.tmNotes : null; } catch (_) { raw = null; }
            if (!raw) return {};
            try {
                const parsed = JSON.parse(raw);
                return __normaliseToolsMaterialsNotes(parsed);
            } catch (_) {
                return {};
            }
        }

        function __setStepToolMatNotesMap(stepEl, mapObj) {
            if (!stepEl) return;
            const m = __normaliseToolsMaterialsNotes(mapObj);
            try { stepEl.dataset.tmNotes = JSON.stringify(m); } catch(_){ __ldSilentErr(_); }
        }

        function __toOneLineNote(note) {
            const s = (note == null) ? '' : String(note);
            return s.replace(/\r\n|\r|\n/g, ' / ').replace(/\s+/g, ' ').trim();
        }

        function getSelectedStepToolsMaterialsNotes(stepEl) {
            const selected = (typeof getSelectedStepToolsMaterials === 'function') ? (getSelectedStepToolsMaterials(stepEl) || []) : [];
            const map = __getStepToolMatNotesMap(stepEl);
            const out = {};
            (selected || []).forEach(k0 => {
                const k = String(k0 || '').trim();
                if (!k) return;
                const v = (map && Object.prototype.hasOwnProperty.call(map, k)) ? map[k] : '';
                const vv = (v == null) ? '' : String(v);
                const t = vv.trim();
                if (t) out[k] = vv; // keep raw (may contain newlines)
            });
            return out;
        }

        function formatSelectedStepToolsMaterialsWithNotes(stepEl) {
            const selected = (typeof getSelectedStepToolsMaterials === 'function') ? (getSelectedStepToolsMaterials(stepEl) || []) : [];
            const map = __getStepToolMatNotesMap(stepEl);
            const parts = [];
            (selected || []).forEach(k0 => {
                const k = String(k0 || '').trim();
                if (!k) return;
                const raw = (map && Object.prototype.hasOwnProperty.call(map, k)) ? map[k] : '';
                const note = (raw == null) ? '' : String(raw).trim();
                if (note) parts.push(k + ' — ' + __toOneLineNote(note));
                else parts.push(k);
            });
            return parts;
        }

        
        // --- Long text fields: compact preview + expand/collapse ---
        function __isLongTextareaCandidate(ta) {
            if (!ta) return false;
            // Exclude tool/material note textareas (already contextual + compact)
            if (ta.classList && ta.classList.contains('step-toolmat-note')) return false;
            // Exclude hidden/system textareas
            if (ta.classList && ta.classList.contains('hidden')) return false;
            if (ta.type && ta.type.toLowerCase() === 'hidden') return false;
            return true;
        }

        function __toggleCompactTextarea(ta, btn) {
            if (!ta) return;
            const state = ta.dataset.taState || 'compact';
            if (state === 'expanded') {
                ta.dataset.taState = 'compact';
                ta.classList.remove('ld-ta-expanded');
                ta.classList.add('ld-ta-compact');
                if (btn) btn.textContent = 'Développer';
            } else {
                ta.dataset.taState = 'expanded';
                ta.classList.remove('ld-ta-compact');
                ta.classList.add('ld-ta-expanded');
                if (btn) btn.textContent = 'Réduire';
                try { ta.focus(); } catch(_){ __ldSilentErr(_); }
            }
        }

        function setupCompactTextareas(scopeEl) {
            const scope = scopeEl || document;
            const selector = [
                'textarea.activity-description',
                'textarea.moment-description',
                'textarea.step-input-objective',
                'textarea.step-input-tasks',
                'textarea.step-input-trainer-tasks',
                'textarea.step-input-notes',
                'textarea.step-input-eval-followup',
                'textarea#ctx-objective'
            ].join(',');

            const list = scope.querySelectorAll(selector);
            list.forEach(ta => {
                if (!__isLongTextareaCandidate(ta)) return;
                if (ta.dataset && ta.dataset.taCompactInit === '1') return;
                ta.dataset.taCompactInit = '1';

                // Default compact
                ta.dataset.taState = 'compact';
                ta.classList.add('ld-ta-compact');
                ta.classList.remove('ld-ta-expanded');

                // Create toggle bar and button
                const bar = document.createElement('div');
                bar.className = 'mt-1 flex justify-end no-print';
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'text-[11px] px-2 py-1 border border-slate-200 rounded-md bg-white hover:bg-slate-50 text-slate-600';
                btn.textContent = 'Développer';
                btn.addEventListener('click', function() { __toggleCompactTextarea(ta, btn); });
                bar.appendChild(btn);

                // Insert just after textarea
                ta.insertAdjacentElement('afterend', bar);

                // Convenience: expand on focus if user starts editing (optional, non-destructive)
                ta.addEventListener('focus', function() {
                    // Do not auto-expand on simple tabbing if already expanded; keep compact by default.
                });
            });
        }

        (function(){
            function _initLongTextCompact() {
                try { setupCompactTextareas(document); } catch(_){ __ldSilentErr(_); }
            }
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', _initLongTextCompact, { once: true });
            } else {
                _initLongTextCompact();
            }
        })();


        function _renderStepToolsMaterialsCheckboxesWithNotes(stepEl, selectEl, containerSelector, checkboxClass, emptyText) {
            if (!stepEl || !selectEl) return;
            const box = stepEl.querySelector(containerSelector);
            if (!box) return;
            box.innerHTML = '';

            const opts = Array.from(selectEl.options || []).filter(o => !(o.disabled && !o.value));
            const usable = opts.filter(o => String(o.value || '').trim());
            if (!usable.length) {
                const div = document.createElement('div');
                div.className = 'text-slate-400 italic';
                div.textContent = emptyText || 'Aucun outil/matériel disponible.';
                box.appendChild(div);
                return;
            }

            const notesMap = __getStepToolMatNotesMap(stepEl);

            usable.forEach((o, idx) => {
                const label = String(o.value || '').trim();
                if (!label) return;

                const row = document.createElement('div');
                row.className = 'p-1 rounded border border-slate-200 bg-white/60';
                row.dataset.tmRow = '1';
                row.dataset.tool = label;

                const lab = document.createElement('label');
                lab.className = 'flex items-start gap-2 cursor-pointer select-none';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'mt-0.5 ' + (checkboxClass || '');
                cb.value = label;
                cb.checked = !!o.selected;

                const sp = document.createElement('span');
                sp.className = 'leading-snug';
                sp.textContent = label;

                lab.appendChild(cb);
                lab.appendChild(sp);
                row.appendChild(lab);

                const noteId = 'tm_note_' + (Date.now().toString(36)) + '_' + idx + '_' + Math.floor(Math.random() * 1e6).toString(36);
                cb.dataset.noteId = noteId;

                const ta = document.createElement('textarea');
                ta.id = noteId;
                ta.className = 'step-toolmat-note w-full px-2 py-1 text-[11px] border border-slate-200 rounded focus:ring-1 focus:ring-indigo-500 outline-none resize-y bg-white mt-1';
                ta.rows = 2;
                ta.placeholder = 'Remarque (optionnel) — ex. consignes, paramètres, variante';
                ta.dataset.tool = label;
                const v = (notesMap && Object.prototype.hasOwnProperty.call(notesMap, label)) ? notesMap[label] : '';
                ta.value = (v == null) ? '' : String(v);

                if (!cb.checked) {
                    ta.classList.add('hidden');
                    ta.disabled = true;
                }

                // Toggle visibility on check/uncheck (in addition to global sync handler)
                cb.addEventListener('change', () => {
                    try {
                        if (cb.checked) {
                            ta.disabled = false;
                            ta.classList.remove('hidden');
                        } else {
                            ta.disabled = true;
                            ta.classList.add('hidden');
                        }
                    } catch(_){ __ldSilentErr(_); }
                });

                row.appendChild(ta);
                box.appendChild(row);
            });
        }

function refreshAllStepOutcomesOptions() {
            __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stepEl => {
                try { populateStepOutcomesSelect(stepEl, null); } catch(_){ __ldSilentErr(_); }
            });
        }

        

        // --- Module-level aims/outcomes selection (same checkbox+creation system as Alignement) ---
        function populateModuleAimsSelect(moduleEl, selected = null) {
            if (!moduleEl) return;
            const sel = moduleEl.querySelector('.module-aims-select');
            if (!sel) return;

            const options = (typeof getGlobalLearningAimsOptions === 'function') ? (getGlobalLearningAimsOptions() || []) : [];
            const currentSelected = selected ? _parseTextList(Array.isArray(selected) ? selected.join('\n') : String(selected)) : (getModuleSelectedAims(moduleEl) || []);

            sel.innerHTML = '';
            const seen = new Set();

            if (!options.length) {
                (currentSelected || []).forEach(v => {
                    const vv = String(v || '').trim();
                    if (!vv) return;
                    const opt = document.createElement('option');
                    opt.value = vv;
                    opt.textContent = vv;
                    opt.selected = true;
                    sel.appendChild(opt);
                });
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Aucun objectif défini (ajoutez-en dans les paramètres)';
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepTextCheckboxesFromSelect(moduleEl, sel, '.module-aims-checkboxes', 'module-aim-cb', 'Aucun objectif sélectionné.', { selectedOnly: true, disabled: true }); } catch(_){ __ldSilentErr(_); }
                return;
            }

            options.forEach(label => {
                const v = String(label || '').trim();
                if (!v) return;
                const k = v.toLowerCase();
                if (seen.has(k)) return;
                seen.add(k);
                const opt = document.createElement('option');
                opt.value = v;
                opt.textContent = v;
                opt.selected = (currentSelected || []).includes(v);
                sel.appendChild(opt);
            });

            (currentSelected || []).forEach(v => {
                const vv = String(v || '').trim();
                if (!vv) return;
                const k = vv.toLowerCase();
                if (seen.has(k)) return;
                const opt = document.createElement('option');
                opt.value = vv;
                opt.textContent = vv;
                opt.selected = true;
                sel.appendChild(opt);
            });

            try { _renderStepTextCheckboxesFromSelect(moduleEl, sel, '.module-aims-checkboxes', 'module-aim-cb', 'Aucun objectif sélectionné.', { selectedOnly: true, disabled: true }); } catch(_){ __ldSilentErr(_); }
        }

        function populateModuleOutcomesSelect(moduleEl, selected = null) {
            if (!moduleEl) return;
            const sel = moduleEl.querySelector('.module-outcomes-select');
            if (!sel) return;

            const options = (typeof getGlobalLearningOutcomesOptions === 'function') ? (getGlobalLearningOutcomesOptions() || []) : [];
            const currentSelected = selected ? _parseTextList(Array.isArray(selected) ? selected.join('\n') : String(selected)) : (getModuleSelectedOutcomes(moduleEl) || []);

            sel.innerHTML = '';
            const seen = new Set();

            if (!options.length) {
                (currentSelected || []).forEach(v => {
                    const vv = String(v || '').trim();
                    if (!vv) return;
                    const opt = document.createElement('option');
                    opt.value = vv;
                    opt.textContent = vv;
                    opt.selected = true;
                    sel.appendChild(opt);
                });
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Aucun résultat défini (ajoutez-en dans les paramètres)';
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepTextCheckboxesFromSelect(moduleEl, sel, '.module-outcomes-checkboxes', 'module-outcome-cb', 'Aucun résultat sélectionné.', { selectedOnly: true, disabled: true }); } catch(_){ __ldSilentErr(_); }
                return;
            }

            options.forEach(label => {
                const v = String(label || '').trim();
                if (!v) return;
                const k = v.toLowerCase();
                if (seen.has(k)) return;
                seen.add(k);
                const opt = document.createElement('option');
                opt.value = v;
                opt.textContent = v;
                opt.selected = (currentSelected || []).includes(v);
                sel.appendChild(opt);
            });

            (currentSelected || []).forEach(v => {
                const vv = String(v || '').trim();
                if (!vv) return;
                const k = vv.toLowerCase();
                if (seen.has(k)) return;
                const opt = document.createElement('option');
                opt.value = vv;
                opt.textContent = vv;
                opt.selected = true;
                sel.appendChild(opt);
            });

            try { _renderStepTextCheckboxesFromSelect(moduleEl, sel, '.module-outcomes-checkboxes', 'module-outcome-cb', 'Aucun résultat sélectionné.', { selectedOnly: true, disabled: true }); } catch(_){ __ldSilentErr(_); }
        }

        

        // --- Auto-derive module-level selections from activity selections (union of steps) ---
        function __kpwizGetSelectedValuesFromSelect(sel) {
            if (!sel) return [];
            return Array.from(sel.selectedOptions || []).map(o => String(o.value || o.textContent || '').trim()).filter(Boolean);
        }

        function __kpwizDeriveModuleTargetsFromSteps(moduleEl) {
            const aimsSet = new Set();
            const outSet = new Set();
            const subjSet = new Set();
            const transvSet = new Set();
            if (!moduleEl) return { aims: [], outcomes: [], competencesSujet: [], competencesTransv: [] };

            __ldFilterStepNodeList(moduleEl.querySelectorAll('.step-card')).forEach(stepEl => {
                // Aims
                let aims = [];
                try {
                    if (typeof getSelectedStepAims === 'function') aims = getSelectedStepAims(stepEl) || [];
                } catch(_){ __ldSilentErr(_); }
                if (!aims || !aims.length) {
                    aims = __kpwizGetSelectedValuesFromSelect(stepEl.querySelector('.step-aims-select'));
                }
                (aims || []).forEach(v => { const vv = String(v || '').trim(); if (vv) aimsSet.add(vv); });

                // Outcomes (targeted learning outcomes)
                let outs = [];
                try {
                    if (typeof getSelectedStepOutcomes === 'function') outs = getSelectedStepOutcomes(stepEl) || [];
                } catch(_){ __ldSilentErr(_); }
                if (!outs || !outs.length) {
                    outs = __kpwizGetSelectedValuesFromSelect(stepEl.querySelector('.step-outcomes-select'));
                }
                (outs || []).forEach(v => { const vv = String(v || '').trim(); if (vv) outSet.add(vv); });

                // Competences (subject + transversal)
                __kpwizGetSelectedValuesFromSelect(stepEl.querySelector('.step-competences-select')).forEach(id => { if (id) subjSet.add(id); });
                __kpwizGetSelectedValuesFromSelect(stepEl.querySelector('.step-competences-transversales-select')).forEach(id => { if (id) transvSet.add(id); });
            });

            return {
                aims: Array.from(aimsSet),
                outcomes: Array.from(outSet),
                competencesSujet: Array.from(subjSet),
                competencesTransv: Array.from(transvSet)
            };
        }

        
        function __kpwizApplyModuleDerivedReadOnly(moduleEl){
            try {
                const blocks = moduleEl ? moduleEl.querySelectorAll('details[data-readonly="true"]') : [];
                (blocks||[]).forEach(det=>{
                    det.querySelectorAll('input[type="checkbox"], select, textarea').forEach(el=>{
                        // Only disable selection widgets; keep the module description textarea editable.
                        if (el && el.matches && el.matches('textarea.activity-description')) return;
                        el.disabled = true;
                    });
                });
            } catch (e) {
                console.warn('Module read-only apply failed', e);
            }
        }

function syncModuleTargetsFromActivities(moduleEl) {
            if (!moduleEl) return;
            const d = __kpwizDeriveModuleTargetsFromSteps(moduleEl);

            // Aims
            try { setModuleSelectedAims(moduleEl, d.aims); } catch(_){ __ldSilentErr(_); }
            try { populateModuleAimsSelect(moduleEl, d.aims); } catch(_){ __ldSilentErr(_); }
            try { updateModuleAimsSummary(moduleEl); } catch(_){ __ldSilentErr(_); }

            // Outcomes
            try { setModuleSelectedOutcomes(moduleEl, d.outcomes); } catch(_){ __ldSilentErr(_); }
            try { populateModuleOutcomesSelect(moduleEl, d.outcomes); } catch(_){ __ldSilentErr(_); }
            try { updateModuleOutcomesSummary(moduleEl); } catch(_){ __ldSilentErr(_); }

            // Competences
            try { populateModuleTargetCompetencesSujetSelect(moduleEl, d.competencesSujet); } catch(_){ __ldSilentErr(_); }
            try { populateModuleTargetCompetencesTransvSelect(moduleEl, d.competencesTransv); } catch(_){ __ldSilentErr(_); }
            try { updateModuleTargetCompetencesSummary(moduleEl); } catch(_){ __ldSilentErr(_); }
        
            try { __kpwizApplyModuleDerivedReadOnly(moduleEl); } catch(_){ __ldSilentErr(_); }
}
function refreshAllModuleAimsOptions() {
            document.querySelectorAll('.activity-group').forEach(modEl => {
                try { syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
            });
        }

        function refreshAllModuleOutcomesOptions() {
            document.querySelectorAll('.activity-group').forEach(modEl => {
                try { syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
            });
        }

        document.addEventListener('DOMContentLoaded', function(){
            try { document.querySelectorAll('.activity-group').forEach(modEl => syncModuleTargetsFromActivities(modEl)); } catch(_){ __ldSilentErr(_); }
        });
        document.addEventListener('DOMContentLoaded', function(){
            try { document.querySelectorAll('.activity-group').forEach(modEl => __kpwizApplyModuleDerivedReadOnly(modEl)); } catch(_){ __ldSilentErr(_); }
        });

        function _syncHiddenSelectFromModuleTextCheckbox(cbEl, selectSelector, setFn, updateFn) {
            if (!cbEl) return;
            const moduleEl = cbEl.closest('.activity-group');
            if (!moduleEl) return;
            const sel = moduleEl.querySelector(selectSelector);
            if (!sel) return;

            const val = String(cbEl.value || '').trim();
            if (!val) return;

            let opt = Array.from(sel.options || []).find(o => String(o.value || '').trim() === val);
            if (!opt) {
                opt = document.createElement('option');
                opt.value = val;
                opt.textContent = val;
                sel.appendChild(opt);
            }
            opt.selected = !!cbEl.checked;

            const picked = Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);
            try { setFn(moduleEl, picked); } catch(_){ __ldSilentErr(_); }
            try { updateFn(moduleEl); } catch(_){ __ldSilentErr(_); }
            try { updateStatsDebounced(); } catch(_){ __ldSilentErr(_); }
        }

        function __kpwizSelectAimInModule(moduleEl, aimLine) {
            if (!moduleEl || !aimLine) return;
            const sel = moduleEl.querySelector('.module-aims-select');
            if (!sel) return;
            let opt = Array.from(sel.options || []).find(o => String(o.value || '').trim() === String(aimLine).trim());
            if (!opt) {
                opt = document.createElement('option');
                opt.value = aimLine;
                opt.textContent = aimLine;
                sel.appendChild(opt);
            }
            opt.selected = true;
            try { populateModuleAimsSelect(moduleEl, Array.from(sel.selectedOptions).map(o => o.value)); } catch(_){ __ldSilentErr(_); }
            try { setModuleSelectedAims(moduleEl, Array.from(sel.selectedOptions).map(o => o.value)); } catch(_){ __ldSilentErr(_); }
            try { updateModuleAimsSummary(moduleEl); } catch(_){ __ldSilentErr(_); }
        }

        function __kpwizSelectOutcomeInModule(moduleEl, outLine) {
            if (!moduleEl || !outLine) return;
            const sel = moduleEl.querySelector('.module-outcomes-select');
            if (!sel) return;
            let opt = Array.from(sel.options || []).find(o => String(o.value || '').trim() === String(outLine).trim());
            if (!opt) {
                opt = document.createElement('option');
                opt.value = outLine;
                opt.textContent = outLine;
                sel.appendChild(opt);
            }
            opt.selected = true;
            try { populateModuleOutcomesSelect(moduleEl, Array.from(sel.selectedOptions).map(o => o.value)); } catch(_){ __ldSilentErr(_); }
            try { setModuleSelectedOutcomes(moduleEl, Array.from(sel.selectedOptions).map(o => o.value)); } catch(_){ __ldSilentErr(_); }
            try { updateModuleOutcomesSummary(moduleEl); } catch(_){ __ldSilentErr(_); }
        }

        function __kpwizSelectCompetenceInModule(moduleEl, id, isTransversal) {
            if (!moduleEl || !id) return;
            const sel = moduleEl.querySelector(isTransversal ? '.module-target-competences-transv-select' : '.module-target-competences-sujet-select');
            if (!sel) return;
            let opt = sel.querySelector('option[value="' + CSS.escape(String(id)) + '"]');
            if (!opt) {
                opt = document.createElement('option');
                opt.value = String(id);
                opt.textContent = String(id);
                sel.appendChild(opt);
            }
            opt.selected = true;
            try {
                if (isTransversal) populateModuleTargetCompetencesTransvSelect(moduleEl);
                else populateModuleTargetCompetencesSujetSelect(moduleEl);
            } catch(_){ __ldSilentErr(_); }
        }

        function addModuleAimManual(btn) {
            const moduleEl = btn ? btn.closest('.activity-group') : null;
            const payload = (typeof __kpwizPromptAddItem === 'function') ? __kpwizPromptAddItem('aim') : null;
            if (!payload) return;
            try {
                addAimItem(payload);
                syncAimsTextareaFromList();
                refreshAllStepAimsOptions();
            } catch (e) {
                console.error('Module quick add aim failed', e);
                return;
            }
            const aimLine = __kpwizFormatCatSubItemLine(payload.categorie, payload.sousCategorie, payload.item);
            try { refreshAllModuleAimsOptions(); } catch(_){ __ldSilentErr(_); }
            try { __kpwizSelectAimInModule(moduleEl, aimLine); } catch(_){ __ldSilentErr(_); }
        }

        function addModuleOutcomeManual(btn) {
            const moduleEl = btn ? btn.closest('.activity-group') : null;
            const payload = (typeof __kpwizPromptAddItem === 'function') ? __kpwizPromptAddItem('outcome') : null;
            if (!payload) return;
            try {
                addOutcomesTextItem(payload);
                syncOutcomesTextTextareaFromList();
                refreshAllStepOutcomesOptions();
            } catch (e) {
                console.error('Module quick add outcome failed', e);
                return;
            }
            const outLine = __kpwizFormatCatSubItemLine(payload.categorie, payload.sousCategorie, payload.item);
            try { refreshAllModuleOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
            try { __kpwizSelectOutcomeInModule(moduleEl, outLine); } catch(_){ __ldSilentErr(_); }
        }

        function addModuleCompetenceManual(btn) {
            const moduleEl = btn ? btn.closest('.activity-group') : null;
            const choice = window.prompt('Que souhaitez-vous ajouter ?\n1 = Compétence (sujet)\n2 = Compétence (transversale)', '1');
            if (choice == null) return;
            const c = String(choice || '').trim();
            if (c !== '1' && c !== '2') return;

            const payload = (typeof __kpwizPromptAddItem === 'function') ? __kpwizPromptAddItem(c === '2' ? 'competence_transv' : 'competence_sujet') : null;
            if (!payload) return;

            const id = (typeof _genId === 'function') ? _genId(c === '2' ? 'compT' : 'comp') : ((c === '2' ? 'compT_' : 'comp_') + Date.now());
            try {
                if (c === '2') addCompetenceTransversal({ id: id, label: payload.label });
                else addCompetence({ id: id, label: payload.label });
            } catch (e) {
                console.error('Module quick add competence failed', e);
                return;
            }

            try { refreshAllStepCompetenceOptions(); } catch(_){ __ldSilentErr(_); }
            try { refreshAllModuleTargetCompetenceOptions(); } catch(_){ __ldSilentErr(_); }
            try { __kpwizSelectCompetenceInModule(moduleEl, id, c === '2'); } catch(_){ __ldSilentErr(_); }
        }
(function initAimsOutcomesChangeHooks(){
            document.addEventListener('input', function(e){
                const t = e.target;
                if (!t) return;
                if (t.id === 'param-aims') {
                    try { refreshAllStepAimsOptions(); } catch(_){ __ldSilentErr(_); }
                            try { refreshAllModuleAimsOptions(); } catch(_){ __ldSilentErr(_); }
                    try { refreshAllModuleAimsOptions(); } catch(_){ __ldSilentErr(_); }
                }
                if (t.id === 'param-outcomes-text') {
                    try { refreshAllStepOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                            try { refreshAllModuleOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                    try { refreshAllModuleOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                }
            }, true);

            document.addEventListener('DOMContentLoaded', function(){
                try {
                    const list = document.getElementById('outcomes-list');
                    if (list) {
                        const obs = new MutationObserver(function(){
                            try { refreshAllStepOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                            try { refreshAllModuleOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                    try { refreshAllModuleOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                        });
                        obs.observe(list, { childList: true, subtree: true });
                    }
                    const tlist = document.getElementById('outcomes-text-list');
                    if (tlist) {
                        const obs2 = new MutationObserver(function(){
                            try { refreshAllStepOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                            try { refreshAllModuleOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                    try { refreshAllModuleOutcomesOptions(); } catch(_){ __ldSilentErr(_); }
                        });
                        obs2.observe(tlist, { childList: true, subtree: true });
                    }
                    const alist = document.getElementById('aims-list');
                    if (alist) {
                        const obs3 = new MutationObserver(function(){
                            try { refreshAllStepAimsOptions(); } catch(_){ __ldSilentErr(_); }
                            try { refreshAllModuleAimsOptions(); } catch(_){ __ldSilentErr(_); }
                    try { refreshAllModuleAimsOptions(); } catch(_){ __ldSilentErr(_); }
                        });
                                            const tmlist = document.getElementById('tools-materials-list');
                    if (tmlist) {
                        const obsTM = new MutationObserver(function(){
                            try { refreshAllStepToolsMaterialsOptions(); } catch(_){ __ldSilentErr(_); }
                        });
                        obsTM.observe(tmlist, { childList: true, subtree: true });
                    }
obs3.observe(alist, { childList: true, subtree: true });
                    }
                } catch (e) { console.warn('Aims/Outcomes observers init failed', e); }
            });
        })();

        document.addEventListener('change', function(e){
            const t = e.target;
            if (!t) return;
            if (t.matches('input.step-aim-cb')) {
                _syncHiddenSelectFromTextCheckbox(t, '.step-aims-select');
            }
            if (t.matches('input.step-outcome-cb')) {
                _syncHiddenSelectFromTextCheckbox(t, '.step-outcomes-select');
            }
            if (t.matches('input.step-toolmat-cb')) {
                _syncHiddenSelectFromTextCheckbox(t, '.step-tools-materials-select');
                try { const stepEl = t.closest('.step-card'); if (stepEl) { applyStepToolsSelectedOnly(stepEl); updateStepHeaderChips(stepEl); } } catch(_){ __ldSilentErr(_); }
                try {
                    const sid = t.dataset ? t.dataset.noteId : null;
                    const stepEl = t.closest('.step-card');
                    const ta = (sid && stepEl) ? stepEl.querySelector('#' + sid) : null;
                    if (ta) {
                        if (t.checked) { ta.disabled = false; ta.classList.remove('hidden'); }
                        else { ta.disabled = true; ta.classList.add('hidden'); }
                    }
                } catch(_){ __ldSilentErr(_); }
            }
            if (t.matches('input.module-aim-cb')) {
                _syncHiddenSelectFromModuleTextCheckbox(t, '.module-aims-select', setModuleSelectedAims, updateModuleAimsSummary);
            }
            if (t.matches('input.module-outcome-cb')) {
                _syncHiddenSelectFromModuleTextCheckbox(t, '.module-outcomes-select', setModuleSelectedOutcomes, updateModuleOutcomesSummary);
            }
        }, true);

        function __kpwizOpenKeyParamsStep3Outcomes() {
            const panel = document.getElementById('key-params-panel');
            const icon = document.getElementById('key-params-panel-icon');
            if (panel) {
                const disp = (panel.style && panel.style.display) ? panel.style.display : '';
                const computed = (typeof getComputedStyle === 'function') ? getComputedStyle(panel).display : disp;
                if (disp === 'none' || computed === 'none') {
                    panel.style.display = 'block';
                }
            }
            if (icon) icon.style.transform = 'rotate(180deg)';

            const stepBtn = document.querySelector('#kpwiz-bar [data-kpwiz-step="3"]');
            if (stepBtn) {
                try { stepBtn.click(); } catch(_){ __ldSilentErr(_); }
            } else {
                const step3 = document.getElementById('kpwiz-step-3');
                if (step3) step3.classList.remove('hidden');
            }

            const outList = document.getElementById('outcomes-text-list') || document.getElementById('outcomes-list');
            const outDetails = outList ? outList.closest('details') : null;
            if (outDetails) outDetails.open = true;

            const target = outDetails || document.getElementById('kpwiz-step-3') || panel;
            if (target && target.scrollIntoView) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            const input = document.getElementById('new-outcomes-text-item-input');
            if (input) {
                try { input.focus(); } catch(_){ __ldSilentErr(_); }
            }
        }

        function openOutcomesFromStep(btn) {
            // Keep origin info for easy return, but create the item immediately.
            try {
                const origin = (typeof __kpwizGetOriginFromStepBtn === 'function') ? __kpwizGetOriginFromStepBtn(btn) : null;
                window.__kpwizAimsOrigin = origin;
                if (typeof __kpwizShowAimsOriginBar === 'function') __kpwizShowAimsOriginBar(origin);
            } catch(_){ __ldSilentErr(_); }

            const stepEl = btn ? btn.closest('.step-card') : null;
            const payload = __kpwizPromptAddItem('outcome');
            if (!payload) return;

            try {
                addOutcomesTextItem(payload);
                syncOutcomesTextTextareaFromList();
                refreshAllStepOutcomesOptions();
            } catch (e) {
                console.error('Quick add outcome failed', e);
                return;
            }

            const outLine = __kpwizFormatCatSubItemLine(payload.categorie, payload.sousCategorie, payload.item);
            try { __kpwizSelectOutcomeInStep(stepEl, outLine); } catch(_){ __ldSilentErr(_); }
        }

        // Expose outcomes navigation helper globally for the ActionRescue capturing handler
        window.openOutcomesFromStep = openOutcomesFromStep;


        // --- Module-level targeted competences (manual selection) ----------
        function getSelectedModuleTargetCompetencesSujetIds(moduleEl) {
            if (!moduleEl) return [];
            const sel = moduleEl.querySelector('.module-target-competences-sujet-select');
            if (!sel) return [];
            return Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);
        }

        function getSelectedModuleTargetCompetencesTransvIds(moduleEl) {
            if (!moduleEl) return [];
            const sel = moduleEl.querySelector('.module-target-competences-transv-select');
            if (!sel) return [];
            return Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);
        }

        function updateModuleTargetCompetencesSummary(moduleEl) {
            if (!moduleEl) return;
            const sCount = moduleEl.querySelector('.module-target-competences-count-sujet');
            const tCount = moduleEl.querySelector('.module-target-competences-count-transv');
            if (sCount) sCount.textContent = String(getSelectedModuleTargetCompetencesSujetIds(moduleEl).length);
            if (tCount) tCount.textContent = String(getSelectedModuleTargetCompetencesTransvIds(moduleEl).length);
        }

        function populateModuleTargetCompetencesSujetSelect(moduleEl, selectedIds = null) {
            if (!moduleEl) return;
            const sel = moduleEl.querySelector('.module-target-competences-sujet-select');
            if (!sel) return;

            const catalogue = (typeof getCompetencesFromUI === 'function') ? getCompetencesFromUI() : [];
            const currentSelected = selectedIds ? _normaliseStepCompetenceIds(selectedIds) : _normaliseStepCompetenceIds(Array.from(sel.selectedOptions || []).map(o => o.value));

            sel.innerHTML = '';
            if (!catalogue || catalogue.length === 0) {
                if (currentSelected && currentSelected.length) {
                    currentSelected.forEach(id => {
                        if (!id) return;
                        const optU = document.createElement('option');
                        optU.value = id;
                        optU.textContent = '[Compétence inconnue] ' + id;
                        optU.selected = true;
                        sel.appendChild(optU);
                    });
                }
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Aucune compétence définie (ajoutez-en dans les paramètres)';
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepCompetenceCheckboxesFromSelect(moduleEl, sel, '.module-target-competences-sujet-checkboxes', 'module-competence-cb-sujet', 'Aucune compétence sélectionnée.', { selectedOnly: true, disabled: true }); } catch(_){ __ldSilentErr(_); }
                updateModuleTargetCompetencesSummary(moduleEl);
                return;
            }

            const knownIds = new Set();
            catalogue.forEach(c => {
                const id = String(c.id || '').trim();
                const label = String(c.label || '').trim();
                if (!id) return;
                knownIds.add(id);
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = label || id;
                opt.selected = currentSelected.includes(id);
                sel.appendChild(opt);
            });

            currentSelected.forEach(id => {
                if (!id || knownIds.has(id)) return;
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = '[Compétence inconnue] ' + id;
                opt.selected = true;
                sel.appendChild(opt);
            });

            try { _renderStepCompetenceCheckboxesFromSelect(moduleEl, sel, '.module-target-competences-sujet-checkboxes', 'module-competence-cb-sujet', 'Aucune compétence sélectionnée.', { selectedOnly: true, disabled: true }); } catch(_){ __ldSilentErr(_); }
            updateModuleTargetCompetencesSummary(moduleEl);
        }

        function populateModuleTargetCompetencesTransvSelect(moduleEl, selectedIds = null) {
            if (!moduleEl) return;
            const sel = moduleEl.querySelector('.module-target-competences-transv-select');
            if (!sel) return;

            const catalogue = (typeof getCompetencesTransversalesFromUI === 'function') ? getCompetencesTransversalesFromUI() : [];
            const currentSelected = selectedIds ? _normaliseStepCompetenceIds(selectedIds) : _normaliseStepCompetenceIds(Array.from(sel.selectedOptions || []).map(o => o.value));

            sel.innerHTML = '';
            if (!catalogue || catalogue.length === 0) {
                if (currentSelected && currentSelected.length) {
                    currentSelected.forEach(id => {
                        if (!id) return;
                        const optU = document.createElement('option');
                        optU.value = id;
                        optU.textContent = '[Compétence inconnue] ' + id;
                        optU.selected = true;
                        sel.appendChild(optU);
                    });
                }
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Aucune compétence définie (ajoutez-en dans les paramètres)';
                opt.disabled = true;
                if (!currentSelected || !currentSelected.length) opt.selected = true;
                sel.appendChild(opt);
                try { _renderStepCompetenceCheckboxesFromSelect(moduleEl, sel, '.module-target-competences-transv-checkboxes', 'module-competence-cb-transversal', 'Aucune compétence sélectionnée.', { selectedOnly: true, disabled: true }); } catch(_){ __ldSilentErr(_); }
                updateModuleTargetCompetencesSummary(moduleEl);
                return;
            }

            const knownIds = new Set();
            catalogue.forEach(c => {
                const id = String(c.id || '').trim();
                const label = String(c.label || '').trim();
                if (!id) return;
                knownIds.add(id);
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = label || id;
                opt.selected = currentSelected.includes(id);
                sel.appendChild(opt);
            });

            currentSelected.forEach(id => {
                if (!id || knownIds.has(id)) return;
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = '[Compétence inconnue] ' + id;
                opt.selected = true;
                sel.appendChild(opt);
            });

            try { _renderStepCompetenceCheckboxesFromSelect(moduleEl, sel, '.module-target-competences-transv-checkboxes', 'module-competence-cb-transversal', 'Aucune compétence sélectionnée.', { selectedOnly: true, disabled: true }); } catch(_){ __ldSilentErr(_); }
            updateModuleTargetCompetencesSummary(moduleEl);
        }

        function refreshAllModuleTargetCompetenceOptions() {
            document.querySelectorAll('.activity-group').forEach(modEl => {
                try { syncModuleTargetsFromActivities(modEl); } catch(_){ __ldSilentErr(_); }
            });
        }

        function _syncHiddenSelectFromModuleCompetenceCheckbox(cbEl) {
            if (!cbEl) return;
            const moduleEl = cbEl.closest('.activity-group');
            if (!moduleEl) return;

            const isTransversal = cbEl.classList.contains('module-competence-cb-transversal');
            const sel = moduleEl.querySelector(isTransversal ? '.module-target-competences-transv-select' : '.module-target-competences-sujet-select');
            if (!sel) return;

            const id = String(cbEl.value || '').trim();
            if (!id) return;

            let opt = sel.querySelector('option[value="' + CSS.escape(id) + '"]');
            if (!opt) {
                opt = document.createElement('option');
                opt.value = id;
                opt.textContent = '[Compétence inconnue] ' + id;
                sel.appendChild(opt);
            }
            opt.selected = !!cbEl.checked;

            try { sel.dispatchEvent(new Event('change', { bubbles: true })); } catch(_){ __ldSilentErr(_); }
            try { updateModuleTargetCompetencesSummary(moduleEl); } catch(_){ __ldSilentErr(_); }
        }

        // --- Module-level competence summary (per module card) --------------
        function _createModuleCompetenceChip(label) {
            const chip = document.createElement('span');
            chip.className = 'inline-flex items-center px-2 py-0.5 rounded-full bg-slate-100 border border-slate-200 text-[10px] text-slate-700';
            chip.textContent = label;
            return chip;
        }

        function updateModuleCompetenceSummary(moduleEl) {
            if (!moduleEl) return;
            const summary = moduleEl.querySelector('.module-competence-summary');
            if (!summary) return;

            const sujetBox = summary.querySelector('.module-competences-sujet-chips');
            const transvBox = summary.querySelector('.module-competences-transv-chips');
            const countSujetEl = summary.querySelector('.module-competences-count-sujet');
            const countTransvEl = summary.querySelector('.module-competences-count-transv');
            if (!sujetBox || !transvBox) return;

            const sujetCatalogue = (typeof getCompetencesFromUI === 'function') ? (getCompetencesFromUI() || []) : [];
            const transvCatalogue = (typeof getCompetencesTransversalesFromUI === 'function') ? (getCompetencesTransversalesFromUI() || []) : [];
            const sujetMap = new Map(sujetCatalogue.map(c => [String(c?.id || '').trim(), String(c?.label || c?.id || '').trim()]));
            const transvMap = new Map(transvCatalogue.map(c => [String(c?.id || '').trim(), String(c?.label || c?.id || '').trim()]));

            const sujetIds = new Set();
            const transvIds = new Set();

            __ldFilterStepNodeList(moduleEl.querySelectorAll('.step-card')).forEach(stepEl => {
                try {
                    const s = (typeof getSelectedStepCompetenceIds === 'function') ? getSelectedStepCompetenceIds(stepEl) : [];
                    (s || []).forEach(id => { if (id) sujetIds.add(String(id).trim()); });
                } catch(_){ __ldSilentErr(_); }
                try {
                    const t = (typeof getSelectedStepCompetencesTransversalesIds === 'function') ? getSelectedStepCompetencesTransversalesIds(stepEl) : [];
                    (t || []).forEach(id => { if (id) transvIds.add(String(id).trim()); });
                } catch(_){ __ldSilentErr(_); }
            });

            // Order by catalogue first, then unknowns
            const sujetOrdered = [];
            sujetCatalogue.forEach(c => {
                const id = String(c?.id || '').trim();
                if (id && sujetIds.has(id)) sujetOrdered.push({ id, label: String(c?.label || id).trim() || id });
            });
            sujetIds.forEach(id => {
                if (!id) return;
                if (sujetOrdered.some(x => x.id == id)) return;
                sujetOrdered.push({ id, label: (sujetMap.get(id) || ('[Compétence inconnue] ' + id)) });
            });

            const transvOrdered = [];
            transvCatalogue.forEach(c => {
                const id = String(c?.id || '').trim();
                if (id && transvIds.has(id)) transvOrdered.push({ id, label: String(c?.label || id).trim() || id });
            });
            transvIds.forEach(id => {
                if (!id) return;
                if (transvOrdered.some(x => x.id == id)) return;
                transvOrdered.push({ id, label: (transvMap.get(id) || ('[Compétence inconnue] ' + id)) });
            });

            // Render
            sujetBox.innerHTML = '';
            transvBox.innerHTML = '';

            if (countSujetEl) countSujetEl.textContent = String(sujetOrdered.length);
            if (countTransvEl) countTransvEl.textContent = String(transvOrdered.length);

            if (!sujetOrdered.length) {
                const empty = document.createElement('span');
                empty.className = 'text-[11px] text-slate-400 italic';
                empty.textContent = 'Aucune';
                sujetBox.appendChild(empty);
            } else {
                sujetOrdered.forEach(x => sujetBox.appendChild(_createModuleCompetenceChip(x.label)));
            }

            if (!transvOrdered.length) {
                const empty = document.createElement('span');
                empty.className = 'text-[11px] text-slate-400 italic';
                empty.textContent = 'Aucune';
                transvBox.appendChild(empty);
            } else {
                transvOrdered.forEach(x => transvBox.appendChild(_createModuleCompetenceChip(x.label)));
            }
        }

        function updateAllModuleCompetenceSummaries() {
            document.querySelectorAll('.activity-group').forEach(modEl => {
                try { updateModuleCompetenceSummary(modEl); } catch (e) { console.error('Module competence summary failed', e); }
            });
        }


        

        // --- Module-level learning objectives & outcomes selections --------
        const __MODULE_AIMS_KEY = 'moduleAims';
        const __MODULE_OUTCOMES_KEY = 'moduleOutcomes';

        function _parseJsonArraySafe(str) {
            if (!str) return [];
            try {
                const arr = JSON.parse(str);
                return Array.isArray(arr) ? arr.map(v => String(v)) : [];
            } catch (_) {
                return [];
            }
        }

        function _serialiseJsonArray(arr) {
            try { return JSON.stringify(Array.isArray(arr) ? arr : []); } catch (_) { return '[]'; }
        }

        function _cleanTextListLine(line) {
            const s = String(line || '').trim();
            if (!s) return '';
            // Remove common bullet prefixes
            return s.replace(/^[-•\u2022\u25CF\u25AA\u25AB\u25A0\u25A1\u25E6\u2043\u2219]+\s*/, '').trim();
        }

        function _parseTextList(text) {
            const raw = String(text || '').split(/\r?\n/);
            const out = [];
            const seen = new Set();
            for (const line of raw) {
                const cleaned = _cleanTextListLine(line);
                if (!cleaned) continue;
                const key = cleaned.toLowerCase();
                if (seen.has(key)) continue;
                seen.add(key);
                out.push(cleaned);
            }
            return out;
        }

        function getGlobalLearningAimsOptions() {
            const aimsText = document.getElementById('param-aims')?.value || '';
            return _parseTextList(aimsText);
        }

        function getGlobalLearningOutcomesOptions() {
            const out = [];
            const seen = new Set();

            // From free text
            const freeText = document.getElementById('param-outcomes-text')?.value || '';
            _parseTextList(freeText).forEach(t => {
                const k = t.toLowerCase();
                if (!seen.has(k)) { seen.add(k); out.push(t); }
            });

            // From structured Bloom outcomes list
            document.querySelectorAll('#outcomes-list li').forEach(li => {
                const txt = li.querySelector('.outcome-text')?.innerText || '';
                const cleaned = _cleanTextListLine(txt);
                if (!cleaned) return;
                const k = cleaned.toLowerCase();
                if (!seen.has(k)) { seen.add(k); out.push(cleaned); }
            });

            return out;
        }

        function getModuleSelectedAims(moduleEl) {
            if (!moduleEl) return [];
            return _parseJsonArraySafe(moduleEl.dataset[__MODULE_AIMS_KEY]);
        }

        function getModuleSelectedOutcomes(moduleEl) {
            if (!moduleEl) return [];
            return _parseJsonArraySafe(moduleEl.dataset[__MODULE_OUTCOMES_KEY]);
        }

        function setModuleSelectedAims(moduleEl, arr) {
            if (!moduleEl) return;
            moduleEl.dataset[__MODULE_AIMS_KEY] = _serialiseJsonArray(arr);
        }

        function setModuleSelectedOutcomes(moduleEl, arr) {
            if (!moduleEl) return;
            moduleEl.dataset[__MODULE_OUTCOMES_KEY] = _serialiseJsonArray(arr);
        }

        function updateModuleAimsSummary(moduleEl) {
            if (!moduleEl) return;
            const box = moduleEl.querySelector('.module-aims-chips');
            const countEl = moduleEl.querySelector('.module-aims-count');
            if (!box) return;
            const sel = getModuleSelectedAims(moduleEl);
            box.innerHTML = '';
            if (countEl) countEl.textContent = String(sel.length);
            if (!sel.length) {
                const empty = document.createElement('span');
                empty.className = 'text-[11px] text-slate-400 italic';
                empty.textContent = 'Aucun';
                box.appendChild(empty);
                return;
            }
            sel.forEach(label => box.appendChild(_createModuleCompetenceChip(label)));
        }

        function updateModuleOutcomesSummary(moduleEl) {
            if (!moduleEl) return;
            const box = moduleEl.querySelector('.module-outcomes-chips');
            const countEl = moduleEl.querySelector('.module-outcomes-count');
            if (!box) return;
            const sel = getModuleSelectedOutcomes(moduleEl);
            box.innerHTML = '';
            if (countEl) countEl.textContent = String(sel.length);
            if (!sel.length) {
                const empty = document.createElement('span');
                empty.className = 'text-[11px] text-slate-400 italic';
                empty.textContent = 'Aucun';
                box.appendChild(empty);
                return;
            }
            sel.forEach(label => box.appendChild(_createModuleCompetenceChip(label)));
        }

        function updateAllModuleLearningTargetsSummaries() {
            document.querySelectorAll('.activity-group').forEach(modEl => {
                try { updateModuleAimsSummary(modEl); } catch (e) { console.error('Module aims summary failed', e); }
                try { updateModuleOutcomesSummary(modEl); } catch (e) { console.error('Module outcomes summary failed', e); }
            });
        }

        // --- Modal for module objectives/outcomes selection -----------------
        (function initModuleSelectionModal(){
            const modal = document.getElementById('module-selection-modal');
            const titleEl = document.getElementById('module-selection-modal-title');
            const bodyEl = document.getElementById('module-selection-modal-body');
            const btnCancel = document.getElementById('module-selection-modal-cancel');
            const btnApply = document.getElementById('module-selection-modal-apply');
            if (!modal || !titleEl || !bodyEl || !btnCancel || !btnApply) return;

            let __ctx = null; // { moduleEl, mode, options }

            const close = () => {
                modal.classList.add('hidden');
                bodyEl.innerHTML = '';
                __ctx = null;
            };

            btnCancel.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                close();
            });

            btnApply.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!__ctx || !__ctx.moduleEl) { close(); return; }
                const checks = Array.from(bodyEl.querySelectorAll('input[type="checkbox"][data-opt]'));
                const picked = checks.filter(c => c.checked).map(c => String(c.getAttribute('data-opt')));

                if (__ctx.mode === 'aims') {
                    setModuleSelectedAims(__ctx.moduleEl, picked);
                    updateModuleAimsSummary(__ctx.moduleEl);
                } else if (__ctx.mode === 'outcomes') {
                    setModuleSelectedOutcomes(__ctx.moduleEl, picked);
                    updateModuleOutcomesSummary(__ctx.moduleEl);
                }
                try { updateStatsDebounced(); } catch(_){ __ldSilentErr(_); }
                close();
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    e.preventDefault();
                    e.stopPropagation();
                    close();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
                    close();
                }
            });

            window.openModuleSelectionFor = function openModuleSelectionFor(moduleEl, mode) {
                if (!moduleEl) return;
                const opts = (mode === 'aims') ? getGlobalLearningAimsOptions() : getGlobalLearningOutcomesOptions();
                const selected = (mode === 'aims') ? new Set(getModuleSelectedAims(moduleEl)) : new Set(getModuleSelectedOutcomes(moduleEl));

                const t = translations[currentLang] || translations.fr || {};
                const title = (mode === 'aims')
                    ? (t.label_aims || "Objectifs d'apprentissage (ce qu'on va enseigner)")
                    : (t.label_outcomes || "Résultats d'apprentissage");

                titleEl.textContent = title;

                if (!opts.length) {
                    bodyEl.innerHTML = '<div class="text-xs text-slate-500 italic">Aucune option disponible. Renseignez d\'abord la liste dans « Informations et paramètres de la formation ».</div>';
                } else {
                    const wrap = document.createElement('div');
                    wrap.className = 'max-h-72 overflow-auto border border-slate-200 rounded p-2 bg-slate-50 space-y-1';

                    opts.forEach((opt, idx) => {
                        const id = `modsel_${mode}_${idx}_${Math.random().toString(16).slice(2)}`;
                        const row = document.createElement('label');
                        row.className = 'flex items-start gap-2 p-1 rounded hover:bg-white cursor-pointer';
                        row.setAttribute('for', id);

                        const cb = document.createElement('input');
                        cb.type = 'checkbox';
                        cb.id = id;
                        cb.className = 'mt-0.5';
                        cb.setAttribute('data-opt', opt);
                        cb.checked = selected.has(opt);

                        const sp = document.createElement('span');
                        sp.className = 'text-xs text-slate-700 leading-snug';
                        sp.textContent = opt;

                        row.appendChild(cb);
                        row.appendChild(sp);
                        wrap.appendChild(row);
                    });

                    bodyEl.innerHTML = '';
                    bodyEl.appendChild(wrap);
                }

                __ctx = { moduleEl, mode, options: opts };
                modal.classList.remove('hidden');
            };
        })();

        function __ldSerializeStepFromEl(stepEl) {
            return {
                                ignored: (typeof __ldIsSelfIgnored === 'function') ? __ldIsSelfIgnored(stepEl) : false,

                                titre: stepEl.querySelector('.step-input-title').value,
                                type: stepEl.querySelector('.learning-type-select').value,
                                duree: stepEl.querySelector('.duration-input').value,
                                unite: stepEl.querySelector('.duration-unit').value,
                                duration: stepEl.querySelector('.duration-input').value,
                                unit: stepEl.querySelector('.duration-unit').value,
                                status: getStepStatus(stepEl),
                                etat: getStepStatus(stepEl),
                                regroupement: stepEl.querySelector('.step-group-mode').value,
                                nombreGroupes: stepEl.querySelector('.step-group-count').value,
                                tailleGroupe: stepEl.querySelector('.step-group-size').value,
                                detailsRegroupement: (stepEl.querySelector('.step-group-details-notes')?.value || ''),
                                formateur: stepEl.querySelector('.trainer-select').value,
                                lieu: stepEl.querySelector('.place-select').value,
                                temps: stepEl.querySelector('.time-select').value,
                                                                evaluation: (stepEl.querySelector('.evaluation-select')?.value || 'Aucune'),
objectifActivite: stepEl.querySelector('.step-input-objective').value,
                                aFaire: stepEl.querySelector('.step-input-tasks').value,
                                aFaireFormateur: stepEl.querySelector('.step-input-trainer-tasks').value,
                                notes: stepEl.querySelector('.step-input-notes').value,
                                liensReferences: (stepEl.querySelector('.step-input-linksrefs')?.value || ''),
                                linksReferences: (stepEl.querySelector('.step-input-linksrefs')?.value || ''),
                                evaluationSuivi: (stepEl.querySelector('.step-input-eval-followup')?.value || ''),
                                competences: getSelectedStepCompetenceIds(stepEl),
                                competencesSujet: getSelectedStepCompetenceIds(stepEl),
                                competencesTransversales: getSelectedStepCompetencesTransversalesIds(stepEl),
                                objectifsCibles: (typeof getSelectedStepAims === 'function') ? getSelectedStepAims(stepEl) : [],
                                resultatsApprentissageCibles: (typeof getSelectedStepOutcomes === 'function') ? getSelectedStepOutcomes(stepEl) : [],
                                outilsMaterielCibles: (typeof getSelectedStepToolsMaterials === 'function') ? getSelectedStepToolsMaterials(stepEl) : []
                            ,
                                outilsMaterielNotes: (typeof getSelectedStepToolsMaterialsNotes === 'function') ? getSelectedStepToolsMaterialsNotes(stepEl) : {}
            };
        }

function buildExportProjectData() {
            // Build a complete, portable representation of the current design (used for file save and autosave)
            const outcomes = [];
            document.querySelectorAll('#outcomes-list li').forEach(li => {
                outcomes.push({
                    texte: li.querySelector('.outcome-text').innerText,
                    niveau: li.querySelector('.outcome-bloom-level').value,
                    sousNiveau: li.querySelector('.outcome-bloom-sub').value
                });
            });

            const exportProject = {
                version: "1.8",
                schemaVersion: 2,
                exportedAt: new Date().toISOString(),
                i18n: (function(){
                    const packs = {};
                    if (loadedLangCode && loadedLangPackRaw && typeof loadedLangPackRaw === 'object') packs[loadedLangCode] = loadedLangPackRaw;
                    return { defaultLang: DEFAULT_LANG, currentLang: currentLang, packs };
                })(),
                parametres: {
                    nom: (document.getElementById('param-name')?.value),
                    theme: (document.getElementById('param-topic') ? document.getElementById('param-topic').value : ''),
                    auteurs: (document.getElementById('param-authors')?.value),
                    formateurs: (document.getElementById('param-trainers')?.value),
                    niveau: document.getElementById('param-level')?.value || 'unspecified',
                    publicCible: document.getElementById('param-target-audience')?.value || '',
                    prerequis: document.getElementById('param-prerequisites')?.value || '',
                    outilsMateriel: document.getElementById('param-tools-materials')?.value || '',
                    outilsMaterielItems: (typeof getToolsMaterialsItemsFromUI === 'function') ? getToolsMaterialsItemsFromUI() : [],
                    outilsMaterielNotes: document.getElementById('param-tools-materials-notes')?.value || '',
                    modalite: document.getElementById('param-mode').value,
                    tailleCohorte: (document.getElementById('global-class-size')?.value),
                    dureeApprentissageValeur: (document.getElementById('param-learning-val')?.value),
                    dureeApprentissageUnite: document.getElementById('param-learning-unit').value,
                    dureeConcueValeur: (document.getElementById('param-designed-val')?.value),
                    dureeConcueUnite: (document.getElementById('param-designed-unit')?.value || document.getElementById('param-learning-unit')?.value || ''),
                    toleranceRelativePct: (document.getElementById('param-duration-tol-rel')?.value),
                    objectifs: document.getElementById('param-aims').value,
                    objectifsItems: (typeof getAimsItemsFromUI === 'function') ? getAimsItemsFromUI() : [],
                    resultatsTexte: document.getElementById('param-outcomes-text')?.value || "",
                    resultatsTexteItems: (typeof getOutcomesTextItemsFromUI === 'function') ? getOutcomesTextItemsFromUI() : [],
                    resultats: outcomes,
                    competences: getCompetencesFromUI(),
                    competencesTransversales: getCompetencesTransversalesFromUI(),
                    description: document.getElementById('param-description').value
                },
                modules: []
            };

            document.querySelectorAll('.activity-group').forEach(actEl => {
                const moduleData = {
                    titre: actEl.querySelector('.activity-title').value,
                    description: actEl.querySelector('.activity-description').value,
                    notes: (actEl.querySelector('.module-notes')?.value || ''),
                    dureeCible: actEl.querySelector('.activity-target-time').value,
                    uniteDureeCible: actEl.querySelector('.activity-target-unit')?.value || "60",
                        objectifsApprentissageModule: getModuleSelectedAims(actEl),
                        resultatsApprentissageModule: getModuleSelectedOutcomes(actEl),
                        competencesModuleSujet: getSelectedModuleTargetCompetencesSujetIds(actEl),
                        competencesModuleTransversales: getSelectedModuleTargetCompetencesTransvIds(actEl),
                    moments: [],
                    activites: []
                };

                const momentsRoot = actEl.querySelector('.activity-moments-container');
                const momentEls = momentsRoot ? Array.from(momentsRoot.querySelectorAll('.moment-group')) : [];

                if (momentEls && momentEls.length) {
                    momentEls.forEach(momentEl => {
                        const momentData = {
                            ignored: (typeof __ldIsSelfIgnored === 'function') ? __ldIsSelfIgnored(momentEl) : false,
                            titre: momentEl.querySelector('.moment-title')?.value || "",
                            description: momentEl.querySelector('.moment-description')?.value || "",
                            dureeCible: momentEl.querySelector('.moment-target-time')?.value,
                            uniteDureeCible: momentEl.querySelector('.moment-target-unit')?.value || getDefaultDurationUnitSecs(),
                            activites: []
                        };
                        momentEl.querySelectorAll('.activity-steps-container .step-card').forEach(stepEl => {
                            const stepObj = __ldSerializeStepFromEl(stepEl);
                            momentData.activites.push(stepObj);
                            moduleData.activites.push({ ...stepObj });
                        });
                        // Sub-moments (optional, preserves structure)
                        try {
                            const smEls = momentEl.querySelectorAll('.submoments-container .submoment-card');
                            if (smEls && smEls.length) {
                                momentData.sousMoments = [];
                                momentData.subMoments = [];
                                smEls.forEach(smEl => {
                                    const smTitleVal = smEl.querySelector('.submoment-title')?.value || "";
                                    const smTargetTime = smEl.querySelector('.submoment-target-time')?.value || "";
                                    const smTargetUnit = smEl.querySelector('.submoment-target-unit')?.value || getDefaultDurationUnitSecs();
                                    const smLegacy = {
                                        ignored: (typeof __ldIsSelfIgnored === 'function') ? __ldIsSelfIgnored(smEl) : false,
                                        titre: smTitleVal,
                                        description: "",
                                        dureeCible: smTargetTime,
                                        uniteDureeCible: smTargetUnit,
                                        activites: []
                                    };
                                    const smCanon = {
                                        ignored: (typeof __ldIsSelfIgnored === 'function') ? __ldIsSelfIgnored(smEl) : false,
                                        title: smTitleVal,
                                        description: "",
                                        targetTime: smTargetTime,
                                        targetUnit: String(smTargetUnit),
                                        steps: []
                                    };
                                    __ldQueryAllDesignedStepCards(smEl).forEach(stepEl => {
                                        const stepObj = __ldSerializeStepFromEl(stepEl);
                                        smLegacy.activites.push(stepObj);
                                        smCanon.steps.push({ ...stepObj });
                                    });
                                    momentData.sousMoments.push(smLegacy);
                                    momentData.subMoments.push(smCanon);
                                });
                            }
                        } catch(_){ __ldSilentErr(_); }
moduleData.moments.push(momentData);
                    });
                } else {
                    Array.from(actEl.querySelectorAll('.step-card') || []).forEach(stepEl => {
                        moduleData.activites.push(__ldSerializeStepFromEl(stepEl));
                    });
                }

                exportProject.modules.push(moduleData);
            });

            return exportProject;
        }

function saveProject() {
            let exportProject = buildExportProjectData();
            const __normSave = normaliseAndRepairProject(exportProject);
            if (__normSave && __normSave.ok) {
                if (__normSave.warnings && __normSave.warnings.length) console.warn('Save normalisation warnings:', __normSave.warnings);
                exportProject = __normSave.data;
            }

            const blob = new Blob([JSON.stringify(exportProject, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;

            const filename = window.__ldBuildExportFilename('json');
            a.download = filename;

            a.click();
            URL.revokeObjectURL(url);
        }
        window.triggerFileLoad = function triggerFileLoad() {
            // Guard against double-trigger (inline onclick + JS-bound listener can both fire).
            // Prevents the OS file picker from opening twice.
            if (window.__loadFileDialogLock) return;
            window.__loadFileDialogLock = true;

            const input = document.getElementById('load-file-input');
            if (!input) { window.__loadFileDialogLock = false; return; }

            // Reset the input so selecting the same file twice still triggers "change".
            try { input.value = ''; } catch(_){ __ldSilentErr(_); }

            // Use rAF to ensure this is still within the user-gesture call stack.
            requestAnimationFrame(() => {
                try { input.click(); } catch (_) { window.__loadFileDialogLock = false; }
            });

            // Failsafe unlock (in case the user cancels the picker and no "change" fires in some browsers)
            setTimeout(() => { window.__loadFileDialogLock = false; }, 1200);
        }

        // Ensure the Load button remains functional even if inline handlers fail.
        document.addEventListener('DOMContentLoaded', function () {
            try {
                const label = document.querySelector('[data-i18n="btn_load"]');
                const buttonEl = label ? label.closest('button') : null;
                if (buttonEl && !buttonEl.__loadBound) {
                    buttonEl.addEventListener('click', window.triggerFileLoad);
                    buttonEl.__loadBound = true;
                }
            } catch (e) {
                console.error('[LoadButtonBindError]', e);
            }
        });

        // -------------------------------
        // Interface language pack (i18n)
        // -------------------------------

        window.triggerLanguagePackLoad = window.triggerLanguagePackLoad || function triggerLanguagePackLoad() {
            if (window.__langPackDialogLock) return;
            window.__langPackDialogLock = true;

            const input = document.getElementById('lang-pack-input');
            if (!input) { window.__langPackDialogLock = false; return; }

            try { input.value = ''; } catch(_){ __ldSilentErr(_); }

            requestAnimationFrame(() => {
                try { input.click(); } catch (_) { window.__langPackDialogLock = false; }
            });

            setTimeout(() => { window.__langPackDialogLock = false; }, 1200);
        };

        window.loadLanguagePack = window.loadLanguagePack || function loadLanguagePack(event) {
            try {
                const file = event?.target?.files?.[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const json = JSON.parse(e.target.result);
                        handleLanguagePackObject(json, file?.name || '');
                    } catch (err) {
                        console.error(err);
                        showAlert('Erreur', "Impossible de charger ce pack de langue. Vérifiez qu’il s’agit bien d’un fichier JSON valide.");
                    } finally {
                        try { event.target.value = ''; } catch(_){ __ldSilentErr(_); }
                    }
                };
                reader.onerror = function () {
                    try { showAlert('Erreur', 'Lecture du fichier impossible.'); } catch(_){ __ldSilentErr(_); }
                    try { event.target.value = ''; } catch(_){ __ldSilentErr(_); }
                };

                reader.readAsText(file);
            } finally {
                window.__langPackDialogLock = false;
            }
        };

        function handleUiLanguageChange(selectEl) {
            try {
                const code = selectEl?.value || DEFAULT_LANG;
                setCurrentLang(code);
            } catch (e) {
                console.error('[UiLanguageChangeError]', e);
            }
        }


function collectI18nKeys() {
    const keys = new Set();

    document.querySelectorAll('[data-i18n]').forEach(el => {
        const k = el.getAttribute('data-i18n');
        if (k) keys.add(k);
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const k = el.getAttribute('data-i18n-placeholder');
        if (k) keys.add(k);
    });
    document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const k = el.getAttribute('data-i18n-title');
        if (k) keys.add(k);
    });

    try {
        const base = translations?.[DEFAULT_LANG] || {};
        Object.keys(base).forEach(k => keys.add(k));
    } catch(_){ __ldSilentErr(_); }

    return Array.from(keys).sort();
}

function exportLanguagePackTemplate() {
    try {
        const keys = collectI18nKeys();
        const base = translations?.[DEFAULT_LANG] || {};
        const dict = {};
        keys.forEach(k => { dict[k] = (base[k] != null) ? String(base[k]) : ""; });

        const template = {
            lang: "xx",
            translations: dict,
            meta: {
                defaultLang: DEFAULT_LANG,
                generatedAt: new Date().toISOString(),
                schema: 1
            }
        };

        const blob = new Blob([JSON.stringify(template, null, 2)], { type: "application/json;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const stamp = new Date().toISOString().slice(0, 10);
        a.href = url;
        a.download = `modele_pack_langue_${stamp}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    } catch (e) {
        console.error('[ExportLanguageTemplateError]', e);
        showAlert('Erreur', "Impossible d’exporter le modèle de pack de langue.");
    }
}
window.exportLanguagePackTemplate = exportLanguagePackTemplate;

// --- i18n audit tool (detect missing keys & uncovered static text) ---
(function initI18nAuditTool(){
    function _get(id){ return document.getElementById(id); }

    function isVisible(el) {
        if (!el) return false;
        const cs = window.getComputedStyle(el);
        if (!cs || cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0') return false;
        return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
    }

    function elementHint(el) {
        if (!el) return '';
        const id = el.id ? `#${el.id}` : '';
        const cls = (el.classList && el.classList.length) ? '.' + Array.from(el.classList).slice(0,2).join('.') : '';
        const i18n = el.getAttribute && (el.getAttribute('data-i18n') || el.getAttribute('data-i18n-title') || el.getAttribute('data-i18n-placeholder')) || '';
        const tag = (el.tagName || '').toLowerCase();
        return [tag + id + cls, i18n ? `(key:${i18n})` : ''].filter(Boolean).join(' ');
    }

    function collectUsedKeys() {
        const keys = new Set();
        document.querySelectorAll('[data-i18n]').forEach(el => { const k = el.getAttribute('data-i18n'); if (k) keys.add(k); });
        document.querySelectorAll('[data-i18n-title]').forEach(el => { const k = el.getAttribute('data-i18n-title'); if (k) keys.add(k); });
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => { const k = el.getAttribute('data-i18n-placeholder'); if (k) keys.add(k); });
        document.querySelectorAll('[data-i18n-html]').forEach(el => { const k = el.getAttribute('data-i18n-html'); if (k) keys.add(k); });
        return Array.from(keys).filter(Boolean).sort();
    }

    function scanUncoveredStaticText(limitSample) {
        const limit = Number.isFinite(limitSample) ? limitSample : 60;
        const selector = 'h1,h2,h3,h4,h5,h6,label,button,span,p,div,summary,a,option,li';
        const all = Array.from(document.querySelectorAll(selector));
        let total = 0;
        const sample = [];

        for (const el of all) {
            if (!isVisible(el)) continue;
            if (el.closest('script,style,template')) continue;
            if (el.closest('#i18n-audit-modal')) continue;
            if (el.closest('[data-i18n-audit-ignore="1"]')) continue;

            const hasKey = el.hasAttribute('data-i18n') || el.hasAttribute('data-i18n-title') || el.hasAttribute('data-i18n-placeholder') || el.hasAttribute('data-i18n-html');
            if (hasKey) continue;

            // Ignore pure icon containers
            if (el.classList && (el.classList.contains('material-icons') || el.classList.contains('material-icons-round'))) continue;

            const direct = Array.from(el.childNodes || []).filter(n => n && n.nodeType === Node.TEXT_NODE).map(n => n.textContent || '').join(' ');
            const txt = (direct || '').replace(/\s+/g, ' ').trim();
            if (!txt) continue;

            // Skip pure numeric/short status tokens
            if (!/[A-Za-zÀ-ÿ]/.test(txt)) continue;

            total++;
            if (sample.length < limit) {
                sample.push(`- ${txt.slice(0, 140)}  [${elementHint(el)}]`);
            }
        }

        return { total, sample };
    }

    function ensureAuditReport() {
        const usedKeys = collectUsedKeys();
        const frBase = (typeof translations === 'object' && translations && translations[DEFAULT_LANG]) ? translations[DEFAULT_LANG] : {};
        const packRaw = (typeof loadedLangPackRaw === 'object' && loadedLangPackRaw && currentLang === loadedLangCode) ? loadedLangPackRaw : null;

        const missingInFr = usedKeys.filter(k => !(k in frBase));
        const missingInPack = packRaw ? usedKeys.filter(k => !(k in packRaw)) : [];

        const uncovered = scanUncoveredStaticText(70);

        const report = {
            generatedAt: new Date().toISOString(),
            currentLang: currentLang,
            defaultLang: DEFAULT_LANG,
            loadedLangCode: loadedLangCode,
            usedKeysCount: usedKeys.length,
            missingInFr,
            missingInPack,
            uncoveredStaticTextCount: uncovered.total,
            uncoveredStaticTextSample: uncovered.sample
        };

        window.__lastI18nAuditReport = report;
        return report;
    }

    window.runI18nAudit = function runI18nAudit() {
        try {
            const report = ensureAuditReport();

            const set = (id, value) => { const el = _get(id); if (el) el.textContent = String(value); };
            const setPre = (id, txt) => { const el = _get(id); if (el) el.textContent = txt || '—'; };

            set('i18n-audit-used', report.usedKeysCount);
            set('i18n-audit-missing-pack-count', report.missingInPack.length);
            set('i18n-audit-missing-fr-count', report.missingInFr.length);
            set('i18n-audit-uncovered-count', report.uncoveredStaticTextCount);

            setPre('i18n-audit-missing-pack', report.missingInPack.length ? report.missingInPack.join('\n') : '—');
            setPre('i18n-audit-missing-fr', report.missingInFr.length ? report.missingInFr.join('\n') : '—');
            setPre('i18n-audit-uncovered', report.uncoveredStaticTextSample && report.uncoveredStaticTextSample.length ? report.uncoveredStaticTextSample.join('\n') : '—');
        } catch (e) {
            console.error('[I18nAuditError]', e);
            showAlert('Erreur', "Impossible d’exécuter la vérification i18n.");
        }
    };

    window.openI18nAudit = function openI18nAudit() {
        const modal = _get('i18n-audit-modal');
        if (!modal) return;
        try { window.runI18nAudit(); } catch(_){ __ldSilentErr(_); }
        modal.classList.remove('hidden');
    };

    window.closeI18nAudit = function closeI18nAudit() {
        const modal = _get('i18n-audit-modal');
        if (!modal) return;
        modal.classList.add('hidden');
    };

    window.downloadI18nAuditReport = function downloadI18nAuditReport() {
        try {
            const report = window.__lastI18nAuditReport || ensureAuditReport();
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const stamp = new Date().toISOString().slice(0, 10);
            a.href = url;
            a.download = `rapport_i18n_${stamp}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        } catch (e) {
            console.error('[I18nAuditDownloadError]', e);
            showAlert('Erreur', "Impossible de télécharger le rapport i18n.");
        }
    };

    // Modal close behaviours (click outside + Escape)
    document.addEventListener('DOMContentLoaded', () => {
            try { if (typeof initCompetencesSystemDefensive === 'function') initCompetencesSystemDefensive(); } catch (e) { console.warn('Competences init skipped:', e); }

        const modal = _get('i18n-audit-modal');
        if (!modal) return;

        modal.addEventListener('click', (e) => {
            if (e.target === modal) window.closeI18nAudit();
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !modal.classList.contains('hidden')) window.closeI18nAudit();
        });
    }, { once: true });
})();


// -------------------------------
// Schema versioning & migrations
// -------------------------------
const CURRENT_SCHEMA_VERSION = 2;

function detectSchemaVersion(p) {
    if (!p || typeof p !== 'object') return 0;
    if (typeof p.schemaVersion === 'number' && Number.isFinite(p.schemaVersion)) return p.schemaVersion;
    if (typeof p.schemaVersion === 'string') {
        const n = parseInt(p.schemaVersion, 10);
        if (Number.isFinite(n)) return n;
    }
    // Legacy exports used "version" (app version) and/or FR "parametres" without a schemaVersion.
    return 1;
}

function mapLegacyGroupMode(value) {
    if (value == null) return value;
    const s = String(value).trim().toLowerCase();
    if (!s) return value;

    // Canonical values
    if (s === 'class' || s === 'groups' || s === 'individual') return s;

    // Common FR labels / variants
    if (s.includes('classe') || s.includes('entier') || s.includes('groupe entier')) return 'class';
    if (s.includes('sous') || (s.includes('groupe') && !s.includes('entier'))) return 'groups';
    if (s.includes('individ')) return 'individual';

    // Common EN labels
    if (s.includes('whole') && s.includes('class')) return 'class';
    if (s.includes('sub') && s.includes('group')) return 'groups';

    return value;
}

function migrateProjectToCurrentSchema(project) {
    // Returns { project, migrated:boolean, from:number, to:number }
    const fromV = detectSchemaVersion(project);
    let p = project;

    if (!p || typeof p !== 'object') {
        return { project, migrated: false, from: fromV, to: CURRENT_SCHEMA_VERSION };
    }

    // Already current (or newer): just normalise the marker.
    if (fromV >= CURRENT_SCHEMA_VERSION) {
        if (p.schemaVersion !== CURRENT_SCHEMA_VERSION) {
            try { p.schemaVersion = CURRENT_SCHEMA_VERSION; } catch(_){ __ldSilentErr(_); }
        }
        return { project: p, migrated: false, from: fromV, to: CURRENT_SCHEMA_VERSION };
    }

    // Clone shallowly to avoid mutating the original payload object reference (safer for debugging).
    p = { ...p };

    // v1 -> v2: add schemaVersion and unify keyParams where possible.
    if (fromV <= 1) {
        // Promote FR "parametres" to canonical "keyParams" (without removing parametres to keep backward compatibility)
        if (!p.keyParams && p.parametres && typeof p.parametres === 'object') {
            const pr = p.parametres;
            const outcomes = Array.isArray(pr.resultats) ? pr.resultats.map(o => ({
                text: o?.texte ?? o?.text ?? '',
                level: o?.niveau ?? o?.level ?? '',
                sub: o?.sousNiveau ?? o?.sub ?? ''
            })) : [];
            p.keyParams = {
                name: pr.nom ?? '',
                topic: pr.theme ?? '',
                authors: pr.auteurs ?? '',
                level: pr.niveau ?? 'unspecified',
                targetAudience: pr.publicCible ?? '',
                prerequisites: pr.prerequis ?? '',
                mode: pr.modalite ?? '',
                cohortSize: pr.tailleCohorte ?? 30,
                learningTimeVal: pr.dureeApprentissageValeur ?? '',
                learningTimeUnit: pr.dureeApprentissageUnite ?? 'mins',
                designedTimeVal: pr.dureeConcueValeur ?? '',
                // designedTimeUnit intentionally synced with learning unit in UI
                durationToleranceRelPct: pr.toleranceRelativePct ?? '',
                aims: pr.objectifs ?? '',
                outcomesText: pr.resultatsTexte ?? '',
                toolsMaterials: pr.outilsMateriel ?? '',
                toolsMaterialsItems: Array.isArray(pr.outilsMaterielItems) ? pr.outilsMaterielItems : [],
                toolsMaterialsNotes: pr.outilsMaterielNotes ?? '',
                description: pr.description ?? '',
                competences: (Array.isArray(pr.competences) ? pr.competences : []),
                outcomes
            };
        }

        // Map legacy grouping values inside steps (both FR + EN keys)
        const visitSteps = (container) => {
            if (!container || typeof container !== 'object') return;
            const steps = Array.isArray(container.steps) ? container.steps
                : (Array.isArray(container.activites) ? container.activites
                    : (Array.isArray(container.activities) ? container.activities : null));
            if (!steps) return;
            steps.forEach(st => {
                if (!st || typeof st !== 'object') return;
                if (st.groupMode != null) st.groupMode = mapLegacyGroupMode(st.groupMode);
                if (st.regroupement != null) st.regroupement = mapLegacyGroupMode(st.regroupement);
            });
        };

        const modules = Array.isArray(p.activities) ? p.activities
            : (Array.isArray(p.modules) ? p.modules : null);

        if (modules) {
            modules.forEach(mod => {
                if (!mod || typeof mod !== 'object') return;
                // Steps directly under module
                visitSteps(mod);
                // Steps under moments
                const moments = Array.isArray(mod.moments) ? mod.moments : null;
                if (moments) moments.forEach(m => visitSteps(m));
            });
        }
    }

    p.schemaVersion = CURRENT_SCHEMA_VERSION;
    if (!p.exportedAt) p.exportedAt = new Date().toISOString();

    return { project: p, migrated: true, from: fromV, to: CURRENT_SCHEMA_VERSION };
}

        
/**
 * Fallback import path (minimal):
 * Rebuild a canonical project structure from heterogeneous exports (notably FR exports with `parametres` + `modules`).
 * Keeps the UI unchanged; only affects import robustness.
 */
function forceCanonicalImport(payload) {
    if (!payload || typeof payload !== "object") throw new Error("invalid_payload");
    const p0 = payload.project || payload.data || payload.conception || payload.learningDesign || payload;
    const warnings = [];
    const rawModules = Array.isArray(p0?.activities) ? p0.activities
        : (Array.isArray(p0?.modules) ? p0.modules
            : (Array.isArray(p0?.activites) ? p0.activites : []));
    const baseProject = (p0 && typeof p0 === "object") ? { ...p0 } : {};

    // Params
    const pr = (p0 && typeof p0 === "object" && p0.parametres && typeof p0.parametres === "object") ? p0.parametres : {};
    const keyParams = (p0 && typeof p0 === "object" && p0.keyParams && typeof p0.keyParams === "object") ? p0.keyParams : null;

    const outFromFR = Array.isArray(pr.resultats) ? pr.resultats.map(o => ({
        text: o?.texte ?? o?.text ?? "",
        level: o?.niveau ?? o?.level ?? "",
        sub: o?.sousNiveau ?? o?.sub ?? ""
    })) : [];

    const canonicalKeyParams = keyParams || {
        name: pr.nom ?? "",
        topic: pr.theme ?? "",
        authors: pr.auteurs ?? "",
        level: pr.niveau ?? "unspecified",
        targetAudience: pr.publicCible ?? "",
        prerequisites: pr.prerequis ?? "",
        mode: pr.modalite ?? "",
        cohortSize: pr.tailleCohorte ?? 30,
        learningTimeVal: pr.dureeApprentissageValeur ?? "",
        learningTimeUnit: pr.dureeApprentissageUnite ?? "mins",
        designedTimeVal: pr.dureeConcueValeur ?? "",
        aims: pr.objectifs ?? "",
        outcomesText: pr.resultatsTexte ?? "",
        description: pr.description ?? "",
        outcomes: outFromFR,
        competences: (Array.isArray(pr.competences) ? pr.competences : [])
    };

    // Helpers
    const asStr = (v) => (v == null ? "" : String(v));
    const asNumStr = (v) => {
        if (v == null || v === "") return "";
        const n = Number(String(v).replace(",", "."));
        return Number.isFinite(n) ? String(n) : "";
    };
    const normGroupMode = (v) => {
        const m = mapLegacyGroupMode(v);
        return (m === "class" || m === "groups" || m === "individual") ? m : "class";
    };

    const normStep = (s) => ({
        title: asStr(s?.title ?? s?.titre ?? ""),
        type: asStr(s?.type ?? "acquisition"),
        duration: asNumStr(s?.duration ?? s?.duree ?? ""),
        unit: asStr(s?.unit ?? s?.unite ?? ""),
        groupMode: normGroupMode(s?.groupMode ?? s?.regroupement ?? "class"),
        groupCount: asNumStr(s?.groupCount ?? s?.nombreGroupes ?? ""),
        groupSize: asNumStr(s?.groupSize ?? s?.tailleGroupe ?? ""),
        trainer: asStr(s?.trainer ?? s?.formateur ?? "present"),
        place: asStr(s?.place ?? s?.lieu ?? "situ"),
        time: asStr(s?.time ?? s?.temps ?? "sync"),
                evaluation: asStr(s?.evaluation ?? s?.evaluationType ?? s?.typeEvaluation ?? 'Aucune'),
objective: asStr(s?.objective ?? s?.objectifActivite ?? ""),
        tasks: asStr(s?.tasks ?? s?.aFaire ?? ""),
        trainerTasks: asStr(s?.trainerTasks ?? s?.aFaireFormateur ?? s?.trainer_actions ?? s?.trainerActions ?? ''),
        notes: asStr(s?.notes ?? ""),
        status: normaliseStepStatus(s?.status ?? s?.etat ?? s?.state ?? ''),
        evaluationSuivi: asStr(s?.evaluationSuivi ?? s?.evaluation ?? s?.suiviEvaluation ?? s?.followUp ?? s?.evalFollowUp ?? ''),
        detailsRegroupement: asStr(s?.detailsRegroupement ?? s?.groupDetails ?? ''),
        objectifsCibles: Array.isArray(s?.objectifsCibles) ? s.objectifsCibles : (Array.isArray(s?.aimsTargeted) ? s.aimsTargeted : []),
        resultatsApprentissageCibles: Array.isArray(s?.resultatsApprentissageCibles) ? s.resultatsApprentissageCibles : (Array.isArray(s?.outcomesTargeted) ? s.outcomesTargeted : []),
        outilsMaterielCibles: Array.isArray(s?.outilsMaterielCibles) ? s.outilsMaterielCibles : (Array.isArray(s?.toolsMaterialsTargeted) ? s.toolsMaterialsTargeted : []),
        outilsMaterielNotes: __normaliseToolsMaterialsNotes(s?.outilsMaterielNotes ?? s?.toolsMaterialsNotes ?? s?.toolsMaterialsNotesByItem ?? {})
    });

    const defaultMomentUnit = (document.getElementById("param-learning-unit")?.value || canonicalKeyParams.learningTimeUnit || "mins");

    const normMoment = (m) => {
                const smRaw = Array.isArray(m?.subMoments) ? m.subMoments : (Array.isArray(m?.sousMoments) ? m.sousMoments : []);
                const subMoments = Array.isArray(smRaw) ? smRaw.map((sm) => ({
                    title: asStr(sm?.title ?? sm?.titre ?? ''),
                    description: asStr(sm?.description ?? ''),
                    targetTime: asNumStr(sm?.targetTime ?? sm?.dureeCible ?? ''),
                    targetUnit: asStr(sm?.targetUnit ?? sm?.uniteDureeCible ?? defaultMomentUnit),
                    steps: Array.isArray(sm?.steps) ? sm.steps.map(normStep)
                        : (Array.isArray(sm?.activites) ? sm.activites.map(normStep) : [])
                })) : [];
                return ({
                    title: asStr(m?.title ?? m?.titre ?? ''),
                    description: asStr(m?.description ?? ''),
                    targetTime: asNumStr(m?.targetTime ?? m?.dureeCible ?? ''),
                    targetUnit: asStr(m?.targetUnit ?? m?.uniteDureeCible ?? defaultMomentUnit),
                    subMoments,
                    // Keep legacy mirror for compatibility (not required by renderer but useful for round-trips)
                    sousMoments: subMoments.map(sm => ({
                        titre: sm.title || '',
                        description: sm.description || '',
                        dureeCible: sm.targetTime || '',
                        uniteDureeCible: sm.targetUnit || '',
                        activites: (sm.steps || []).map(st => ({ ...st }))
                    })),
                    steps: Array.isArray(m?.steps) ? m.steps.map(normStep)
                        : (Array.isArray(m?.activites) ? m.activites.map(normStep) : [])
                });
            };

            const normModule = (a) => {
                const moments = Array.isArray(a?.moments) ? a.moments.map(normMoment) : [];
                const hasMoments = Array.isArray(moments) && moments.length > 0;
                return {
                    title: asStr(a?.title ?? a?.titre ?? ''),
                    description: asStr(a?.description ?? ''),
                    notes: asStr(a?.notes ?? a?.moduleNotes ?? a?.remarques ?? a?.observations ?? ''),
                    targetTime: asNumStr(a?.targetTime ?? a?.dureeCible ?? ''),
                    targetUnit: asStr(a?.targetUnit ?? a?.uniteDureeCible ?? '60'),
                    moments,
                    // Canonical choice: if moments exist, ignore module-level legacy 'activites/steps' to avoid duplicates.
                    steps: hasMoments ? [] : (Array.isArray(a?.steps) ? a.steps.map(normStep)
                        : (Array.isArray(a?.activites) ? a.activites.map(normStep) : []))
                };
            };

            const normalised = { ...baseProject, keyParams: canonicalKeyParams, parametres: pr };
            normalised.activities = rawModules.map(normModule);

            // Ensure key params shape exists (loadProjectFromObject handles both, but we keep consistent)
            if (!normalised.keyParams && !normalised.parametres) {
                normalised.keyParams = normalised.keyParams || {};
            }

            // If no modules, keep empty array to allow default module creation downstream
            if (!Array.isArray(normalised.activities)) normalised.activities = [];

            // Basic sanity: if any module has neither moments nor steps, keep as-is; renderer will create defaults
            return { ok: true, data: normalised, warnings };
        }

// ---------------------------------------
// Normalisation & validation (auto-repair)
// ---------------------------------------
function _genId(prefix="id") {
    // Prefer crypto for uniqueness; fallback to timestamp+random
    try {
        if (window.crypto && crypto.randomUUID) return `${prefix}_${crypto.randomUUID()}`;
    } catch (e) {}
    return `${prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
}
function _asText(v) {
    if (v == null) return "";
    return String(v);
}
function _trimText(v, maxLen) {
    let s = _asText(v).replace(/\r\n/g, "\n");
    // Normalise “undefined” / “null” artefacts that may appear in legacy exports
    if (s === "undefined" || s === "null") s = "";
    s = s.trim();
    if (typeof maxLen === "number" && maxLen > 0 && s.length > maxLen) s = s.slice(0, maxLen);
    return s;
}
function _asFiniteNumber(v, fallback=0) {
    const n = (typeof v === "number") ? v : Number(String(v).replace(",", "."));
    return Number.isFinite(n) ? n : fallback;
}
function _clampInt(v, min=0, max=Number.MAX_SAFE_INTEGER, fallback=0) {
    const n = Math.round(_asFiniteNumber(v, fallback));
    return Math.min(max, Math.max(min, n));
}
function _normaliseUnit(u, fallback="mins") {
    // Returns a canonical *key* (mins/hours/days/weeks/months) for project-level units.
    // Accepts legacy keys, French labels, and numeric seconds strings (e.g., "60").
    const raw = _trimText(u);
    if (!raw) return fallback;
    const v = raw.toLowerCase();

    // Numeric seconds → key
    const n = parseFloat(v);
    if (!isNaN(n) && isFinite(n)) {
        if (Math.abs(n - 60) < 0.0001) return "mins";
        if (Math.abs(n - 3600) < 0.0001) return "hours";
        if (Math.abs(n - 86400) < 0.0001) return "days";
        if (Math.abs(n - 604800) < 0.0001) return "weeks";
        if (Math.abs(n - 2592000) < 0.0001) return "months";
        return fallback;
    }

    if (["mins","min","m","minutes","minute"].includes(v)) return "mins";
    if (["hours","hour","h","heures","heure","hrs","hr"].includes(v)) return "hours";
    if (["days","day","d","jours","jour"].includes(v)) return "days";
    if (["weeks","week","w","semaines","semaine"].includes(v)) return "weeks";
    if (["months","month","mois"].includes(v)) return "months";
    return fallback;
}

function _normaliseUnitSecs(u, fallback="mins") {
    // Returns a canonical *seconds value as string* ("60", "3600", ...).
    // Accepts keys, labels, and numeric seconds. Uses mapUnitToSecs (app-level mapping).
    const raw = _trimText(u);
    const base = raw || fallback;
    try {
        const secs = mapUnitToSecs(base);
        if (!isNaN(secs) && isFinite(secs) && secs > 0) return String(secs);
    } catch(_){ __ldSilentErr(_); }
    return String(mapUnitToSecs("mins"));
}

function _normaliseNumberString(v, maxLen=30) {
    // Returns a safe numeric string, normalising comma decimals to dots.
    const raw = _trimText(v, maxLen);
    if (!raw) return "";
    const s = raw.replace(",", ".");
    const n = Number(s);
    if (!Number.isFinite(n)) return "";
    // Avoid scientific notation for typical UI values; keep a compact decimal representation.
    const out = (Math.abs(n - Math.round(n)) < 1e-9) ? String(Math.round(n)) : String(parseFloat(n.toFixed(6)));
    return out;
}

function normaliseAndRepairProject(project) {
    const warnings = [];
    if (!project || typeof project !== "object") {
        return { ok: false, warnings: ["Project is not an object."], data: { parametres: {}, activities: [] } };
    }

    // Support wrapper shapes but keep the internal structure
    project = project.project || project.data || project.conception || project.learningDesign || project;

    // Ensure param blocks exist (keep both if already present)
    if (!project.parametres || typeof project.parametres !== "object") project.parametres = {};
    if (!project.keyParams || typeof project.keyParams !== "object") project.keyParams = project.keyParams || {};

    const p = project.parametres;

    // Core text fields
    p.titre = _trimText(p.titre, 200);
    p.description = _trimText(p.description, 5000);
    p.objectifs = _trimText(p.objectifs, 5000);
    p.resultatsTexte = _trimText(p.resultatsTexte, 10000);

    // Outcomes list (keep shape)
    if (!Array.isArray(p.resultats)) p.resultats = [];
    p.resultats = p.resultats
        .filter(x => x && typeof x === "object")
        .map(x => ({
            id: x.id || _genId("outcome"),
            texte: _trimText(x.texte ?? x.text, 800),
            niveau: _trimText(x.niveau ?? x.level, 60),
            sousNiveau: _trimText(x.sousNiveau ?? x.sub, 60)
        }))
        .filter(x => x.texte.length > 0);

    // Competence catalogues (subject + transversal)
    const _normCompList = (arr, prefix) => {
        if (!Array.isArray(arr)) return [];
        const out = [];
        const seen = new Set();
        for (const raw of arr) {
            const norm = _normaliseCompetenceItem(raw);
            if (!norm) continue;
            let cid = String(norm.id || '').trim();
            if (!cid || seen.has(cid)) cid = _genId(prefix);
            seen.add(cid);
            out.push({ id: cid, label: _trimText(norm.label, 400) });
        }
        return out;
    };

    p.competences = _normCompList(p.competences, 'comp');
    p.competencesTransversales = _normCompList(p.competencesTransversales, 'compT');


    // Durations & units at project level
    p.dureeApprentissageUnite = _normaliseUnit(p.dureeApprentissageUnite, "mins");
p.dureeConcueUnite = _normaliseUnit(p.dureeConcueUnite ?? p.dureeApprentissageUnite, p.dureeApprentissageUnite);

// Also persist seconds equivalents to keep durations fully synchronised across exports/imports.
p.dureeApprentissageUniteSecs = _normaliseUnitSecs(p.dureeApprentissageUnite, "mins");
p.dureeConcueUniteSecs = _normaliseUnitSecs(p.dureeConcueUnite, p.dureeApprentissageUnite);

    // Keep original string fields, but ensure they are sane numeric strings
    const lt = _trimText(p.dureeApprentissageValeur, 20);
    const dt = _trimText(p.dureeConcueValeur, 20);
    if (lt && !Number.isFinite(Number(lt.replace(",", ".")))) {
        warnings.push("Invalid learning time value; cleared.");
        p.dureeApprentissageValeur = "";
    } else {
        p.dureeApprentissageValeur = lt;
    }
    if (dt && !Number.isFinite(Number(dt.replace(",", ".")))) {
        warnings.push("Invalid designed time value; cleared.");
        p.dureeConcueValeur = "";
    } else {
        p.dureeConcueValeur = dt;
    }

    // Activities (modules)
    if (!Array.isArray(project.activities)) project.activities = Array.isArray(project.modules) ? project.modules : [];
    if (!Array.isArray(project.activities)) project.activities = [];

    const seenIds = new Set();

    const ensureUniqueId = (obj, prefix) => {
        if (!obj || typeof obj !== "object") return;
        if (!obj.id) obj.id = _genId(prefix);
        while (seenIds.has(obj.id)) obj.id = _genId(prefix);
        seenIds.add(obj.id);
    };

    project.activities = project.activities
        .filter(mod => mod && typeof mod === "object")
        .map((mod, mi) => {
            ensureUniqueId(mod, "module");
            mod.title = _trimText(mod.title ?? mod.titre ?? `Module ${mi+1}`, 200);

            // Module target time (keep string if UI expects string)
            mod.targetTime = _normaliseNumberString(mod.targetTime ?? mod.tempsCible ?? mod.dureeCible ?? mod.targetTimeVal ?? "", 20);

// Module unit is stored as seconds (to match UI selects), while we also keep a derived key for clarity.
mod.targetUnit = _normaliseUnitSecs(mod.targetUnit ?? mod.uniteDureeCible ?? mod.uniteCible ?? mod.unite ?? p.dureeApprentissageUnite, p.dureeApprentissageUnite);
mod.targetUnitKey = _normaliseUnit(mod.targetUnit, p.dureeApprentissageUnite);

// Legacy mirrors (keep for round-trips across versions)
mod.dureeCible = _trimText(mod.dureeCible ?? mod.targetTime ?? "", 20);
mod.tempsCible = _trimText(mod.tempsCible ?? mod.targetTime ?? "", 20);
mod.uniteDureeCible = _trimText(mod.uniteDureeCible ?? mod.targetUnit ?? "", 30);
mod.uniteCible = _trimText(mod.uniteCible ?? mod.targetUnit ?? "", 30);

            // Moments
            if (!Array.isArray(mod.moments)) mod.moments = Array.isArray(mod.moments) ? mod.moments : [];
            if (!Array.isArray(mod.moments)) mod.moments = [];

            mod.moments = mod.moments
                .filter(m => m && typeof m === "object")
                .map((m, mj) => {
                    ensureUniqueId(m, "moment");
                    m.ignored = !!(m.ignored ?? m.ignore ?? m.isIgnored ?? m.ldIgnored);
                    m.title = _trimText(m.title ?? m.titre ?? `Moment ${mj+1}`, 200);
                    m.type = _trimText(m.type ?? "", 40);

                    // Moment target time & unit (synchronised with UI selects)
m.targetTime = _normaliseNumberString(m.targetTime ?? m.tempsCible ?? m.dureeCible ?? "", 20);
m.targetUnit = _normaliseUnitSecs(m.targetUnit ?? m.uniteDureeCible ?? m.uniteCible ?? mod.targetUnit ?? p.dureeApprentissageUnite, mod.targetUnit ?? p.dureeApprentissageUnite);
m.targetUnitKey = _normaliseUnit(m.targetUnit, p.dureeApprentissageUnite);

// Legacy mirrors (keep for round-trips)
m.dureeCible = _trimText(m.dureeCible ?? m.targetTime ?? "", 20);
m.tempsCible = _trimText(m.tempsCible ?? m.targetTime ?? "", 20);
m.uniteDureeCible = _trimText(m.uniteDureeCible ?? m.targetUnit ?? "", 30);
m.uniteCible = _trimText(m.uniteCible ?? m.targetUnit ?? "", 30);

// Moment duration in seconds (canonical)
if (m.targetTimeSec == null) {
    const n = _asFiniteNumber(m.targetTime, NaN);
    if (Number.isFinite(n)) {
        const unitSecs = _asFiniteNumber(m.targetUnit, 60);
        m.targetTimeSec = _clampInt(n * unitSecs, 0, 24*3600*365, 0);
    } else {
        m.targetTimeSec = 0;
    }
} else {
    m.targetTimeSec = _clampInt(m.targetTimeSec, 0, 24*3600*365, 0);
}

// Steps / activities inside moment
                    if (!Array.isArray(m.steps)) {
                        m.steps = Array.isArray(m.activites) ? m.activites : (Array.isArray(m.activities) ? m.activities : []);
                    }
                    if (!Array.isArray(m.steps)) m.steps = [];
                    // SUBMOMENTS_NORMALISE_V1
                    // Sub-moments inside moment (optional). Keep canonical shape on m.subMoments, accept legacy m.sousMoments.
                    try {
                        const rawSM = Array.isArray(m.subMoments) ? m.subMoments : (Array.isArray(m.sousMoments) ? m.sousMoments : []);
                        if (Array.isArray(rawSM) && rawSM.length) {
                            m.subMoments = rawSM
                                .filter(sm => sm && typeof sm === "object")
                                .map((sm, smi) => {
                                    ensureUniqueId(sm, "submoment");
                                    sm.ignored = !!(sm.ignored ?? sm.ignore ?? sm.isIgnored ?? sm.ldIgnored);
                                    sm.title = _trimText(sm.title ?? sm.titre ?? "", 200);
                                    sm.description = _trimText(sm.description ?? "", 5000);

                                    // Sub-moment target time & unit
                                    sm.targetTime = _normaliseNumberString(sm.targetTime ?? sm.dureeCible ?? sm.tempsCible ?? "", 20);
                                    sm.targetUnit = _normaliseUnitSecs(sm.targetUnit ?? sm.uniteDureeCible ?? sm.uniteCible ?? m.targetUnit ?? mod.targetUnit ?? p.dureeApprentissageUnite, m.targetUnit ?? mod.targetUnit ?? p.dureeApprentissageUnite);
                                    sm.targetUnitKey = _normaliseUnit(sm.targetUnit, p.dureeApprentissageUnite);
                                    // Legacy mirrors
                                    sm.dureeCible = _trimText(sm.dureeCible ?? sm.targetTime ?? "", 20);
                                    sm.uniteDureeCible = _trimText(sm.uniteDureeCible ?? sm.targetUnit ?? "", 30);

                                    // Steps within sub-moment
                                    if (!Array.isArray(sm.steps)) {
                                        sm.steps = Array.isArray(sm.activites) ? sm.activites : (Array.isArray(sm.activities) ? sm.activities : []);
                                    }
                                    if (!Array.isArray(sm.steps)) sm.steps = [];

                                    // If both legacy arrays exist, keep steps and drop alternates
                                    if (Array.isArray(sm.steps) && (Array.isArray(sm.activites) || Array.isArray(sm.activities))) {
                                        try { delete sm.activites; } catch(_){ __ldSilentErr(_); }
                                        try { delete sm.activities; } catch(_){ __ldSilentErr(_); }
                                    }

                                    // Normalise nested steps using the same pipeline as moment steps
                                    sm.steps = sm.steps
                                        .filter(s => s && typeof s === "object")
                                        .map((s, si) => {
                                            ensureUniqueId(s, "step");
                            s.ignored = !!(s.ignored ?? s.ignore ?? s.isIgnored ?? s.ldIgnored);
                                            s.ignored = !!(s.ignored ?? s.ignore ?? s.isIgnored ?? s.ldIgnored);
                                            s.title = _trimText(s.title ?? s.titre ?? `Activité ${si+1}`, 200);
                                            s.type = _trimText(s.type ?? "", 50);

                                            if (s.groupMode != null) s.groupMode = mapLegacyGroupMode(s.groupMode);
                                            if (s.regroupement != null) s.regroupement = mapLegacyGroupMode(s.regroupement);
                                            s.groupMode = _trimText(s.groupMode ?? s.regroupement ?? "class", 20) || "class";

                                            s.groupCount = _trimText(s.groupCount ?? s.nombreGroupes ?? "", 20);
                                            s.groupSize = _trimText(s.groupSize ?? s.tailleGroupe ?? "", 20);

                                            s.objective = _trimText(s.objective ?? s.objectifActivite ?? "", 5000);
                                            s.tasks = _trimText(s.tasks ?? s.aFaire ?? "", 8000);
                                            s.notes = _trimText(s.notes ?? "", 8000);
                                            s.trainer = _trimText(s.trainer ?? s.formateur ?? "", 200);
                                            s.place = _trimText(s.place ?? s.lieu ?? "", 200);
                                            s.time = _trimText(s.time ?? s.temps ?? "", 50);
                                            s.status = normaliseStepStatus(s.status ?? s.etat ?? s.state ?? "");

                                            const _normIds = (raw) => {
                                                if (!raw) return [];
                                                if (Array.isArray(raw)) return raw.map(String).map(s=>s.trim()).filter(Boolean);
                                                if (typeof raw === 'string') return raw.split(/[;,\n\r]+/).map(s=>s.trim()).filter(Boolean);
                                                return [];
                                            };
                                            s.competences = _normIds(s.competences ?? s.competenceIds ?? s.competencies ?? s.competencesCiblees ?? []);
                                            s.competencesSujet = Array.isArray(s.competences) ? s.competences.slice() : [];
                                            s.competencesTransversales = _normIds(s.competencesTransversales ?? s.competencesTransversalesIds ?? s.transversalCompetences ?? []);

                                            // Duration fields (synchronised: value + unit)
s.duration = _normaliseNumberString(s.duration ?? s.duree ?? "", 30);
s.unit = _normaliseUnitSecs(s.unit ?? s.unite ?? mod.targetUnit ?? p.dureeApprentissageUnite, p.dureeApprentissageUnite);
s.unitKey = _normaliseUnit(s.unit, p.dureeApprentissageUnite);

// Legacy mirrors
s.duree = s.duration;
s.unite = s.unit;

                                            // Keep any additional fields untouched
                                            return s;
                                        });

                                    return sm;
                                });

                            // Keep legacy mirror for maximum backward compatibility
                            m.sousMoments = m.subMoments.map(sm => ({
                                titre: sm.title || "",
                                description: sm.description || "",
                                dureeCible: sm.targetTime || sm.dureeCible || "",
                                uniteDureeCible: sm.targetUnit || sm.uniteDureeCible || "",
                                activites: (sm.steps || []).map(st => ({ ...st }))
                            }));
                        } else {
                            if (!Array.isArray(m.subMoments)) m.subMoments = [];
                        }
                    } catch (_) { if (!Array.isArray(m.subMoments)) m.subMoments = []; }
                    // END_SUBMOMENTS_NORMALISE_V1


                    // Canonical choice: if both legacy arrays exist, keep steps and drop alternates.
                    if (Array.isArray(m.steps) && (Array.isArray(m.activites) || Array.isArray(m.activities))) {
                        try { delete m.activites; } catch(_){ __ldSilentErr(_); }
                        try { delete m.activities; } catch(_){ __ldSilentErr(_); }
                    }

                    m.steps = m.steps
                        .filter(s => s && typeof s === "object")
                        .map((s, si) => {
                            ensureUniqueId(s, "step");
                            s.title = _trimText(s.title ?? s.titre ?? `Activité ${si+1}`, 200);
                            s.type = _trimText(s.type ?? "", 50);

                            // Grouping (canonical)
                            if (s.groupMode != null) s.groupMode = mapLegacyGroupMode(s.groupMode);
                            if (s.regroupement != null) s.regroupement = mapLegacyGroupMode(s.regroupement);
                            s.groupMode = _trimText(s.groupMode ?? s.regroupement ?? "class", 20) || "class";

                            // Numeric fields
                            s.groupCount = _trimText(s.groupCount ?? s.nombreGroupes ?? "", 20);
                            s.groupSize = _trimText(s.groupSize ?? s.tailleGroupe ?? "", 20);

                            // Text fields
                            s.objective = _trimText(s.objective ?? s.objectifActivite ?? "", 5000);
                            s.tasks = _trimText(s.tasks ?? s.aFaire ?? "", 8000);
                            s.notes = _trimText(s.notes ?? "", 8000);
                            s.trainer = _trimText(s.trainer ?? s.formateur ?? "", 200);
                            s.place = _trimText(s.place ?? s.lieu ?? "", 200);
                            s.time = _trimText(s.time ?? s.temps ?? "", 50);
                                            s.status = normaliseStepStatus(s.status ?? s.etat ?? s.state ?? "");

                            // Duration fields (synchronised: value + unit)
s.duration = _normaliseNumberString(s.duration ?? s.duree ?? "", 30);
s.unit = _normaliseUnitSecs(s.unit ?? s.unite ?? mod.targetUnit ?? p.dureeApprentissageUnite, p.dureeApprentissageUnite);
s.unitKey = _normaliseUnit(s.unit, p.dureeApprentissageUnite);

// Legacy mirrors
s.duree = s.duration;
s.unite = s.unit;

                            // Step-level competence selections (IDs)
                            const _normIds = (raw) => {
                                if (!raw) return [];
                                if (Array.isArray(raw)) return raw.map(String).map(s=>s.trim()).filter(Boolean);
                                if (typeof raw === 'string') return raw.split(/[;,\n\r]+/).map(s=>s.trim()).filter(Boolean);
                                return [];
                            };
                            s.competences = _normIds(s.competences ?? s.competencesSujet ?? s.competenceIds ?? s.competencies ?? s.competencesCiblees ?? []);
                            // Keep explicit subject field for clarity + backward compatibility
                            s.competencesSujet = Array.isArray(s.competences) ? s.competences.slice() : [];
                            s.competencesTransversales = _normIds(s.competencesTransversales ?? s.competences_transversales ?? s.transversalCompetences ?? s.competencesTransversalesIds ?? []);

                            return s;
                        });

                    return m;
                });

            // Canonical choice: if moments exist, ignore module-level legacy 'activites/activities' to avoid duplicates.
            if (Array.isArray(mod.moments) && mod.moments.length > 0) {
                try { delete mod.activites; } catch(_){ __ldSilentErr(_); }
                try { delete mod.activities; } catch(_){ __ldSilentErr(_); }
                try { delete mod.steps; } catch(_){ __ldSilentErr(_); }
            }

            return mod;
        });

    // Mirror a few key params into keyParams for compatibility, without overwriting non-empty values there
    const kp = project.keyParams;
    const mirror = (k, v) => {
        if (kp[k] == null || String(kp[k]).trim() === "") kp[k] = v;
    };
    mirror("title", p.titre);
    mirror("description", p.description);
    mirror("aims", p.objectifs);
    mirror("outcomesText", p.resultatsTexte);
    mirror("toolsMaterials", p.outilsMateriel);
    try { if (!kp.toolsMaterialsItems && Array.isArray(p.outilsMaterielItems)) kp.toolsMaterialsItems = p.outilsMaterielItems; } catch(_){ __ldSilentErr(_); }
    mirror("toolsMaterialsNotes", p.outilsMaterielNotes);
    mirror("learningTimeUnit", p.dureeApprentissageUnite);
    mirror("designedTimeUnit", p.dureeConcueUnite);
    mirror("learningTimeVal", p.dureeApprentissageValeur);
    mirror("designedTimeVal", p.dureeConcueValeur);
    mirror("durationToleranceRelPct", p.toleranceRelativePct);

    return { ok: true, warnings, data: project };
}

// Legacy helper alias expected by older loader paths
function validateAndNormaliseProjectPayload(project) {
    try {
        const migrated = migrateProjectToCurrentSchema(project);
        return normaliseAndRepairProject(migrated && migrated.project ? migrated.project : project);
    } catch (e) {
        return { ok: false, warnings: ["validation_exception"], data: null, error: e };
    }
}


        
        function loadProjectFromObject(project) {
                        // Keep a reference for recovery tooling (used only when an import fails)
            window.__lastImportParsedObject = project;
const __chartsSuspendFn = window.__setChartsSuspended;
            if (typeof __chartsSuspendFn === 'function') __chartsSuspendFn(true);
            try {
            // Support multiple saved-file shapes (legacy / FR / wrapper objects)
            if (project && typeof project === 'object') {
                project = project.project || project.data || project.conception || project.learningDesign || project;
            }

            // Primary path: validate + normalise using current loader
            let __checked = null;
            try {
                __checked = validateAndNormaliseProjectPayload(project);
            } catch (e) {
                console.error('Load validation error:', e);
                __checked = { ok: false, data: null, warnings: ['validation_exception'] };
            }

            // Fallback path (minimal, schema-agnostic): rebuild a canonical structure from FR exports
            if (!__checked || !__checked.ok) {
                try {
                    project = forceCanonicalImport(project);
                    __checked = { ok: true, data: project, warnings: ['fallback_canonical_import'] };
                } catch (e) {
                    console.error('Fallback import error:', e);

                    // Tolerant import fallback: if the payload still looks like a project, attempt a minimal repair
                    // instead of hard-failing. This preserves forward/backward compatibility when fields evolve.
                    try {
                        const __looksLikeProject = (obj) => {
                            if (!obj || typeof obj !== 'object') return false;
                            const root = obj.project || obj.data || obj.conception || obj.learningDesign || obj;
                            if (!root || typeof root !== 'object') return false;
                            return (
                                Array.isArray(root.activities) ||
                                Array.isArray(root.modules) ||
                                Array.isArray(root.activites) ||
                                root.parametres != null ||
                                root.keyParams != null ||
                                root.i18n != null ||
                                root.titre != null ||
                                root.title != null
                            );
                        };

                        if (__looksLikeProject(project)) {
                            const root = project.project || project.data || project.conception || project.learningDesign || project;

                            const minimal = {
                                parametres: (root.parametres && typeof root.parametres === 'object') ? root.parametres : {},
                                keyParams: (root.keyParams && typeof root.keyParams === 'object') ? root.keyParams : {},
                                activities: Array.isArray(root.activities) ? root.activities
                                    : (Array.isArray(root.modules) ? root.modules
                                    : (Array.isArray(root.activites) ? root.activites : [])),
                                i18n: root.i18n || root.languagePack || root.langPack || null
                            };

                            const __repaired = normaliseAndRepairProject(minimal);
                            __checked = { ok: true, data: (__repaired && __repaired.data) ? __repaired.data : minimal, warnings: ['tolerant_minimal_import'] };
                        } else {
                            const report = window.__ld_buildImportReport({ stage: "tolerant_reject", error: new Error("unrecognised_project_structure"), parsedObject: project });
                            window.__ld_showImportError(report);
                            return;
                        }
                    } catch (e2) {
                        console.error('Tolerant minimal import error:', e2);
                        const report = window.__ld_buildImportReport({ stage: "tolerant_reject", error: e2, parsedObject: project });
                        window.__ld_showImportError(report);
                        return;
                    }
                }
            }

            if (__checked.warnings && __checked.warnings.length) {
                console.warn('Project validation warnings:', __checked.warnings);
            }
            project = __checked.data;

            // Restore interface language pack from the saved project (if present)
            try {
                const i18n = project && typeof project === 'object' ? (project.i18n || project.languagePack || project.langPack || null) : null;
                if (i18n && typeof i18n === 'object') {
                    const packs = (i18n.packs && typeof i18n.packs === 'object') ? i18n.packs : (i18n.translations && typeof i18n.translations === 'object' ? { [i18n.lang || i18n.language || i18n.locale || 'xx']: i18n.translations } : null);
                    if (packs && typeof packs === 'object') {
                        const keys = Object.keys(packs);
                        if (keys.length) {
                            loadedLangCode = normaliseLangCode(keys[0]) || loadedLangCode;
                            loadedLangPackRaw = packs[keys[0]];
                            ensureLangExists(loadedLangCode, loadedLangPackRaw);
                        }
                    }
                    const wanted = normaliseLangCode(i18n.currentLang || i18n.lang || i18n.language || i18n.locale || '');
                    updateUiLanguageSelector();
                    if (wanted) setCurrentLang(wanted);
                }
            } catch (e) { console.warn('i18n restore skipped:', e); }

            // Auto-repair / deep normalisation (IDs, durations, empty fields)
            try {
                const __norm2 = normaliseAndRepairProject(project);
                if (__norm2 && __norm2.ok) {
                    if (__norm2.warnings && __norm2.warnings.length) console.warn('Normalisation warnings:', __norm2.warnings);
                    project = __norm2.data;
                } else {
                    console.warn('Normalisation failed; continuing with validated payload.');
                }
            } catch (e) {
                console.error('Normalisation exception; continuing with validated payload.', e);
            }
            const rootEl = document.getElementById('activities-root') || root;
            if (rootEl) rootEl.innerHTML = '';

            const __setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = (val ?? ''); };
            // __setHtml removed (XSS vector) — only used for clearing, now uses safe replaceChildren()
            const __clearEl = (id) => { const el = document.getElementById(id); if (el) el.replaceChildren(); };

            // Restore Key Params
            const __kp = (project && project.keyParams && typeof project.keyParams === 'object') ? project.keyParams : {};
            const __pr = (project && project.parametres && typeof project.parametres === 'object') ? project.parametres : {};
            {

                const __pick = (...vals) => {
                    for (const v of vals) {
                        if (v == null) continue;
                        const s = String(v).trim();
                        if (s !== '') return v;
                    }
                    return '';
                };

                // Support both canonical keyParams and FR parametres (including mixed exports where keyParams is partial)
                __setVal('param-name', __pick(__kp.name, __kp.title, __pr.nom, __pr.titre, ""));
                { const __el=document.getElementById('param-topic'); if(__el){ __el.value = __pick(__kp.topic, __pr.theme, ""); } }
                __setVal('param-authors', __pick(__kp.authors, __pr.auteurs, ""));
                __setVal('param-trainers', __pick(__kp.trainers, __pr.formateurs, ""));
                __setVal('param-level', __pick(__kp.level, __pr.niveau, 'unspecified') || 'unspecified');
                __setVal('param-target-audience', __pick(__kp.targetAudience, __pr.publicCible, ""));
                __setVal('param-prerequisites', __pick(__kp.prerequisites, __pr.prerequis, ""));
                __setVal('param-mode', __pick(__kp.mode, __pr.modalite, ""));
                __setVal('global-class-size', __pick(__kp.cohortSize, __pr.tailleCohorte, 30) || 30);
                __setVal('param-learning-val', __pick(__kp.learningTimeVal, __pr.dureeApprentissageValeur, ""));
                __setVal('param-learning-unit', __pick(__kp.learningTimeUnit, __pr.dureeApprentissageUnite, "mins") || "mins");
                __setVal('param-designed-val', __pick(__kp.designedTimeVal, __pr.dureeConcueValeur, ""));
                __setVal('param-duration-tol-rel', __pick(__kp.durationToleranceRelPct, __pr.toleranceRelativePct, "5"));
                // Designed Time Unit is now synced with Learning Time Unit
                __setVal('param-aims', __pick(__kp.aims, __pr.objectifs, ""));
                try {
                    const __ai = __pick(__kp.aimsItems, __pr.objectifsItems, null);
                    if (__ai && Array.isArray(__ai)) window.__kpwizAimsItemsFromLoad = __ai;
                } catch(_){ __ldSilentErr(_); }
                __setVal('param-outcomes-text', __pick(__kp.outcomesText, __pr.resultatsTexte, ""));
                __setVal('param-tools-materials', __pick(__kp.toolsMaterials, __pr.outilsMateriel, ""));
                __setVal('param-tools-materials-notes', __pick(__kp.toolsMaterialsNotes, __pr.outilsMaterielNotes, ""));
                try {
                    const __ti = __pick(__kp.toolsMaterialsItems, __pr.outilsMaterielItems, null);
                    if (__ti && Array.isArray(__ti)) window.__kpwizToolsMaterialsItemsFromLoad = __ti;
                } catch(_){ __ldSilentErr(_); }
                try {
                    const __oi = __pick(__kp.outcomesTextItems, __pr.resultatsTexteItems, null);
                    if (__oi && Array.isArray(__oi)) window.__kpwizOutcomesTextItemsFromLoad = __oi;
                } catch(_){ __ldSilentErr(_); }
                try { initAimsAndOutcomesTextListsFromTextareas(); } catch (e) { console.warn('aims/outcomes text lists init skipped', e); }
                __setVal('param-description', __pick(__kp.description, __pr.description, ""));

                // Restore Outcomes (canonical OR FR)
                __clearEl('outcomes-list');
                const __outs = (Array.isArray(__kp.outcomes) ? __kp.outcomes : (Array.isArray(__pr.resultats) ? __pr.resultats.map(o => ({
                    text: o?.texte ?? o?.text ?? '',
                    level: o?.niveau ?? o?.level ?? '',
                    sub: o?.sousNiveau ?? o?.sub ?? ''
                })) : []));
                if (__outs && Array.isArray(__outs)) {
                    __outs.forEach(out => addOutcome(out));
                }
                checkOutcomesEmpty();
            }

                // Restore Competences (keyParams OR parametres)
                try {
                    const __compsRaw = (Array.isArray(__kp.competences) ? __kp.competences : (Array.isArray(__pr.competences) ? __pr.competences : []));
                    __clearEl('competences-list');
                    if (__compsRaw && Array.isArray(__compsRaw)) {
                        __compsRaw.forEach(c => addCompetence(c));
                    }
                    checkCompetencesEmpty();
                } catch(_){ __ldSilentErr(_); }


                // Restore Transversal Competences (keyParams OR parametres)
                try {
                    const __compsTRaw = (Array.isArray(__kp.competencesTransversales) ? __kp.competencesTransversales : (Array.isArray(__pr.competencesTransversales) ? __pr.competencesTransversales : []));
                    __clearEl('competences-transversales-list');
                    if (__compsTRaw && Array.isArray(__compsTRaw)) {
                        __compsTRaw.forEach(c => addCompetenceTransversal(c));
                    }
                    checkCompetencesTransversalesEmpty();
                } catch(_){ __ldSilentErr(_); }


            const loadedActivitiesRaw = Array.isArray(project.activities)
                ? project.activities
                : (Array.isArray(project.modules)
                    ? project.modules
                    : (Array.isArray(project) ? project : []));

            const normaliseStep = (s) => ({
                ignored: !!(s?.ignored || s?.ignore || s?.isIgnored || s?.ldIgnored),
                title: s?.title ?? s?.titre ?? "",
                type: s?.type ?? "",
                duration: s?.duration ?? s?.duree ?? "",
                unit: s?.unit ?? s?.unite ?? "",
                groupMode: s?.groupMode ?? s?.regroupement ?? "Classe entière",
                groupCount: s?.groupCount ?? s?.nombreGroupes ?? "",
                groupSize: s?.groupSize ?? s?.tailleGroupe ?? "",
                groupDetails: s?.groupDetails ?? s?.detailsRegroupement ?? "",
                trainer: s?.trainer ?? s?.formateur ?? "",
                place: s?.place ?? s?.lieu ?? "",
                time: s?.time ?? s?.temps ?? "",
                evaluation: s?.evaluation ?? "",
                objective: s?.objective ?? s?.objectifActivite ?? "",
                tasks: s?.tasks ?? s?.aFaire ?? "",
                trainerTasks: s?.trainerTasks ?? s?.aFaireFormateur ?? "",
                notes: s?.notes ?? "",
                linksReferences: s?.linksReferences ?? s?.liensReferences ?? "",
                evaluationSuivi: s?.evaluationSuivi ?? "",
                status: normaliseStepStatus(s?.status ?? s?.etat ?? s?.state ?? ""),
                competences: _normaliseStepCompetenceIds(s?.competences ?? s?.competenceIds ?? s?.competencies ?? s?.competencesCiblees ?? ""),
                competencesTransversales: _normaliseStepCompetenceIds(s?.competencesTransversales ?? s?.competences_transversales ?? s?.transversalCompetences ?? s?.competencesTransversalesIds ?? ''),
                aimsTargets: s?.aimsTargets ?? s?.objectifsCibles ?? [],
                outcomesTargets: s?.outcomesTargets ?? s?.resultatsApprentissageCibles ?? [],
                toolsMaterialsTargets: s?.toolsMaterialsTargets ?? s?.outilsMaterielCibles ?? [],
                toolsMaterialsNotes: s?.toolsMaterialsNotes ?? s?.outilsMaterielNotes ?? {}
            });

            const normaliseMoment = (m) => ({
                ignored: !!(m?.ignored || m?.ignore || m?.isIgnored || m?.ldIgnored),
                title: m?.title ?? m?.titre ?? "",
                description: m?.description ?? "",
                targetTime: m?.targetTime ?? m?.dureeCible ?? "",
                targetUnit: m?.targetUnit ?? m?.uniteDureeCible ?? (document.getElementById('param-learning-unit')?.value || "mins"),
                subMoments: (function(){
                    const smRaw = Array.isArray(m?.subMoments) ? m.subMoments : (Array.isArray(m?.sousMoments) ? m.sousMoments : []);
                    return Array.isArray(smRaw) ? smRaw.map(sm => ({
                        ignored: !!(sm?.ignored || sm?.ignore || sm?.isIgnored || sm?.ldIgnored),
                        title: sm?.title ?? sm?.titre ?? "",
                        description: sm?.description ?? "",
                        targetTime: sm?.targetTime ?? sm?.dureeCible ?? "",
                        targetUnit: sm?.targetUnit ?? sm?.uniteDureeCible ?? (m?.targetUnit ?? m?.uniteDureeCible ?? (document.getElementById('param-learning-unit')?.value || "mins")),
                        steps: Array.isArray(sm?.steps) ? sm.steps.map(normaliseStep) : (Array.isArray(sm?.activites) ? sm.activites.map(normaliseStep) : [])
                    })) : [];
                })(),
                steps: Array.isArray(m?.steps) ? m.steps.map(normaliseStep) : (Array.isArray(m?.activites) ? m.activites.map(normaliseStep) : [])
            });

            const normaliseActivity = (a) => {
                const moments = Array.isArray(a?.moments) ? a.moments.map(normaliseMoment) : [];
                const hasMoments = Array.isArray(moments) && moments.length > 0;
                return {
                    title: a?.title ?? a?.titre ?? "",
                    description: a?.description ?? "",
                    targetTime: a?.targetTime ?? a?.dureeCible ?? "",
                    targetUnit: a?.targetUnit ?? a?.uniteDureeCible ?? "60",
                    objectifsApprentissageModule: Array.isArray(a?.objectifsApprentissageModule) ? a.objectifsApprentissageModule : (Array.isArray(a?.learningAimsModule) ? a.learningAimsModule : []),
                    resultatsApprentissageModule: Array.isArray(a?.resultatsApprentissageModule) ? a.resultatsApprentissageModule : (Array.isArray(a?.learningOutcomesModule) ? a.learningOutcomesModule : []),
                    competencesModuleSujet: _normaliseStepCompetenceIds(a?.competencesModuleSujet ?? a?.moduleCompetencesSujet ?? a?.competencesModuleCibleesSujet ?? a?.competencesModuleSujetIds ?? a?.competencesModule ?? []),
                    competencesModuleTransversales: _normaliseStepCompetenceIds(a?.competencesModuleTransversales ?? a?.moduleCompetencesTransversales ?? a?.competencesModuleCibleesTransversales ?? a?.competencesModuleTransversalesIds ?? a?.competencesModuleTransversalesList ?? []),
                    moments,
                    // Canonical choice: if moments exist, ignore module-level legacy 'activites/steps' to avoid duplicates.
                    steps: hasMoments ? [] : (Array.isArray(a?.steps) ? a.steps.map(normaliseStep) : (Array.isArray(a?.activites) ? a.activites.map(normaliseStep) : []))
                };
            };

            loadedActivitiesRaw.forEach(actData => {
                addActivityFromData(normaliseActivity(actData));
            });

            // If nothing was restored, keep a minimal empty state consistent with default behaviour
            if (!loadedActivitiesRaw.length) {
                addActivity();
            }


         
        // ---------------------------------------
        // Import: diagnostic (help on rejection)
        // ---------------------------------------
        window.__lastImportReport = null;

                window.__lastImportParsedObject = null;
        window.__lastImportRawJson = null;
function _i18nStr(key, fallback = "") {
            try {
                const pack = (translations && translations[currentLang]) ? translations[currentLang] : (translations.fr || {});
                const v = pack[key];
                return (typeof v === "string" && v.length) ? v : fallback;
            } catch (e) {
                return fallback;
            }
        }

        function _summariseKeys(obj, limit = 18) {
            try {
                if (!obj || typeof obj !== "object") return [];
                const keys = Object.keys(obj);
                if (keys.length <= limit) return keys;
                return keys.slice(0, limit).concat([`…(+${keys.length - limit})`]);
            } catch (e) { return []; }
        }

        function _analyseProjectShape(obj) {
            const shape = {
                type: (obj === null) ? "null" : Array.isArray(obj) ? "array" : typeof obj,
                rootKeys: _summariseKeys(obj),
                flags: {}
            };
            if (!obj || typeof obj !== "object" || Array.isArray(obj)) return shape;

            const p = (obj.project || obj.data || obj.conception || obj.learningDesign || obj);
            shape.flags.hasProjectWrapper = !!(obj.project || obj.data || obj.conception || obj.learningDesign);

            const keys = Object.keys(p || {});
            const has = (k) => keys.includes(k);
            shape.flags.hasActivities = has("activities") || has("activites") || has("modules");
            shape.flags.hasKeyParams = has("keyParams") || has("parametres") || has("parameters") || has("params");
            shape.flags.hasI18n = has("i18n") || has("languagePack") || has("langPack");
            shape.flags.hasSchemaVersion = has("schemaVersion") || has("schema") || has("version");
            shape.flags.schemaVersionValue = (p && (p.schemaVersion ?? p.schema ?? p.version)) ?? null;

            // Additional hints (common non-project JSON shapes)
            shape.flags.looksLikeSlides = has("slides") || has("pptx") || has("presentation");
            shape.flags.looksLikeGraph = has("nodes") || has("edges");
            return shape;
        }

        function buildImportReport({ file = null, stage = "unknown", error = null, parsedObject = null } = {}) {
            const now = new Date();
            const errObj = (error && typeof error === "object") ? {
                name: error.name || "Error",
                message: error.message || String(error),
                stack: (typeof error.stack === "string") ? error.stack.split("\n").slice(0, 8).join("\n") : ""
            } : null;

            const shape = _analyseProjectShape(parsedObject);

            return {
                kind: "import_report",
                generatedAt: now.toISOString(),
                stage,
                file: file ? {
                    name: file.name || "",
                    size: file.size || null,
                    type: file.type || "",
                    lastModified: file.lastModified ? new Date(file.lastModified).toISOString() : null
                } : null,
                error: errObj,
                detected: shape
            };
        }

        function _deriveImportCauseKey(report) {
            if (!report) return "import_error_cause_generic";
            if (report.stage === "parse") return "import_error_cause_parse";
            if (report.stage === "future_version") return "import_error_cause_version";
            if (report.stage === "validate" || report.stage === "tolerant_reject") return "import_error_cause_structure";
            return "import_error_cause_generic";
        }

        function showImportError(report) {
            window.__lastImportReport = report || null;

            const modal = document.getElementById("import-error-modal");
            const body = document.getElementById("import-error-body");
            const btnDownload = document.getElementById("import-error-download");
            const btnCopy = document.getElementById("import-error-copy");
            const btnCopyRecovery = document.getElementById("import-error-copy-recovery");

            const btnRecover = document.getElementById("import-error-recover");
// Fallback if modal is unavailable (should not happen)
            if (!modal || !body) {
                showAlert('Erreur', _i18nStr("import_error_cause_generic", "Import impossible."));
                return;
            }

            const causeKey = _deriveImportCauseKey(report);
            const causeText = _i18nStr(causeKey, "Import impossible.");

            const keys = (report && report.detected && Array.isArray(report.detected.rootKeys)) ? report.detected.rootKeys : [];
            const flags = (report && report.detected && report.detected.flags) ? report.detected.flags : {};
            const detectedParts = [];
            if (keys.length) detectedParts.push(`<div><span class="font-semibold">${escapeHtml(_i18nStr("import_error_detected", "Détecté"))}:</span> ${escapeHtml(keys.join(", "))}</div>`);
            if (flags && typeof flags === "object") {
                const hints = [];
                if (flags.hasProjectWrapper) hints.push("wrapper");
                if (flags.hasActivities) hints.push("activities");
                if (flags.hasKeyParams) hints.push("keyParams");
                if (flags.hasI18n) hints.push("i18n");
                if (flags.looksLikeSlides) hints.push("slides");
                if (flags.looksLikeGraph) hints.push("graph");
                if (hints.length) detectedParts.push(`<div class="text-[11px] text-slate-500">${escapeHtml(_i18nStr("import_error_hints", "Indices"))}: ${escapeHtml(hints.join(" • "))}</div>`);
            }

            const actionsHtml = `
              <div class="mt-1">
                <div class="font-semibold">${escapeHtml(_i18nStr("import_error_actions", "Actions recommandées"))}:</div>
                <ol class="list-decimal ml-5 space-y-1 mt-1">
                  <li>${escapeHtml(_i18nStr("import_error_action1", "Vérifiez que le fichier provient de « Sauver » dans cet outil."))}</li>
                  <li>${escapeHtml(_i18nStr("import_error_action2", "Si le fichier a été modifié (éditeur/IA), assurez-vous que le JSON est valide."))}</li>
                  <li>${escapeHtml(_i18nStr("import_error_action3", "Si le fichier provient d’une ancienne version, réexportez-le depuis cette version puis réimportez-le ici."))}</li>
                  <li>${escapeHtml(_i18nStr("import_error_action4", "Si le problème persiste, téléchargez le rapport d’import et joignez-le à votre demande de support."))}</li>
                </ol>
              </div>`;

            const tech = (report && report.error && report.error.message) ? `<div class="text-[11px] text-slate-500 mt-1">${escapeHtml(_i18nStr("import_error_detail", "Détail"))}: ${escapeHtml(report.error.message)}</div>` : "";

            body.innerHTML = `
              <div><span class="font-semibold">${escapeHtml(_i18nStr("import_error_probable_cause", "Cause probable"))}:</span> ${escapeHtml(causeText)}</div>
              ${detectedParts.join("")}
              ${tech}
              ${actionsHtml}
            `;

            if (btnDownload) {
                btnDownload.classList.toggle("hidden", !window.__lastImportReport);
            }
            if (btnCopy) {
                btnCopy.classList.toggle("hidden", !window.__lastImportReport);
                // Reset label if it was temporarily changed
                if (btnCopy.dataset && btnCopy.dataset.origLabel) {
                    btnCopy.textContent = btnCopy.dataset.origLabel;
                }
            }
            if (btnCopyRecovery) {
                // Reset label if it was temporarily changed
                if (btnCopyRecovery.dataset && btnCopyRecovery.dataset.origLabel) {
                    btnCopyRecovery.textContent = btnCopyRecovery.dataset.origLabel;
                }
            }
            
            if (btnRecover) {
                // Recovery is only possible when a parsed JSON object is available.
                btnRecover.classList.toggle("hidden", !window.__lastImportParsedObject);
            }
            if (btnCopyRecovery) {
                btnCopyRecovery.classList.toggle("hidden", !window.__lastImportParsedObject);
            }
            modal.classList.remove("hidden");
        }

        function closeImportErrorModal() {
            const modal = document.getElementById("import-error-modal");
            if (modal) modal.classList.add("hidden");
        }

        function downloadLastImportReport() {
            if (!window.__lastImportReport) return;
            const stamp = (new Date()).toISOString().slice(0,19).replace(/[:T]/g,'-');
            const name = `rapport_import_${stamp}.json`;
            downloadJSON(name, window.__lastImportReport);
        }

function _downloadTextFile(filename, text, mime = 'text/plain;charset=utf-8') {
    const blob = new Blob([String(text || "")], { type: mime });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
        URL.revokeObjectURL(a.href);
        a.remove();
    }, 0);
}

// ------------------------------
// Export filename helpers (training title + local date/time)
// ------------------------------
function __ldGetTrainingTitleForFilename() {
    const v = (document.getElementById('param-name')?.value || '').trim();
    return v || 'conception_pedagogique';
}
function __ldSanitiseFilenamePart(s) {
    const raw = String(s || '').trim();
    // Remove diacritics, then keep a conservative safe set for cross-platform filenames.
    const noDia = raw.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    return noDia
        .replace(/[\/:*?"<>|]+/g, '-')      // illegal on Windows
        .replace(/[\r\n\t]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/\s/g, '_')                // spaces -> underscores
        .replace(/_+/g, '_')
        .slice(0, 120) || 'conception_pedagogique';
}
function __ldExportStampLocal() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
}
function __ldBuildExportFilename(ext, label) {
    const base = __ldSanitiseFilenamePart(__ldGetTrainingTitleForFilename());
    const stamp = __ldExportStampLocal();
    const lbl = label ? `_${__ldSanitiseFilenamePart(label)}` : '';
    return `${base}${lbl}_${stamp}.${ext}`;
}

// Backward-compatible alias (some handlers reference _ldBuildExportFilename)
window._ldBuildExportFilename = __ldBuildExportFilename;
window.__ldBuildExportFilename = __ldBuildExportFilename;




function _recAsStr(v) {
    return (typeof v === "string") ? v : (v == null ? "" : String(v));
}
function _recAsNum(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
}
function _recDurationLabel(step) {
    if (!step || typeof step !== "object") return "";
    const val = _recAsNum(step.duree ?? step.duration ?? step.durationValue);
    const unit = _recAsNum(step.unite ?? step.unit ?? step.durationUnitSecs);
    if (val == null) return "";
    if (unit != null && typeof unitLabelFromSecs === "function") {
        return `${val} ${unitLabelFromSecs(unit)}`.trim();
    }
    return `${val}`.trim();
}
function _looksLikePedagogicalStep(obj) {
    if (!obj || typeof obj !== "object") return false;
    return (
        ("aFaire" in obj) || ("notes" in obj) || ("objectifActivite" in obj) ||
        ("tasks" in obj) || ("objective" in obj) || ("duration" in obj) || ("duree" in obj)
    );
}

function generateRecoveryMarkdown(rawProject) {
    const now = new Date();
    const root = (rawProject && typeof rawProject === "object")
        ? (rawProject.project || rawProject.data || rawProject.conception || rawProject.learningDesign || rawProject)
        : {};

    const keyParams = root.keyParams || root.parametres || root.parameters || root.meta || {};
    const title =
        _recAsStr(keyParams.courseName) ||
        _recAsStr(keyParams.nomFormation) ||
        _recAsStr(root.courseName) ||
        _recAsStr(root.title) ||
        _recAsStr(root.nom) ||
        _i18nStr("import_recovery_default_title", "Conception pédagogique (récupération)");

    let md = `# ${title}\n\n`;
    md += `_${_i18nStr("import_recovery_disclaimer", "Récupération automatique depuis un fichier JSON (import échoué). À relire et ajuster si nécessaire.")}_\n\n`;
    md += `- ${_i18nStr("import_recovery_generated_at", "Généré le")}: ${now.toISOString()}\n\n`;

    const desc = _recAsStr(keyParams.description || root.description || "");
    if (desc) {
        md += `## ${_i18nStr("import_recovery_description", "Description")}\n${desc}\n\n`;
    }
    const aims = _recAsStr(keyParams.aims || keyParams.objectifs || root.aims || root.objectifs || "");
    if (aims) {
        md += `## ${_i18nStr("import_recovery_aims", "Objectifs")}\n${aims}\n\n`;
    }
    const outcomes = _recAsStr(keyParams.outcomesText || keyParams.outcomes || root.outcomesText || root.outcomes || "");
    if (outcomes) {
        md += `## ${_i18nStr("import_recovery_outcomes", "Résultats d’apprentissage")}\n${outcomes}\n\n`;
    }

    const modules =
        (Array.isArray(root.activities) && root.activities) ||
        (Array.isArray(root.activites) && root.activites) ||
        (Array.isArray(root.modules) && root.modules) ||
        (Array.isArray(root.sequence) && root.sequence) ||
        [];

    md += `## ${_i18nStr("import_recovery_structure", "Structure")}\n`;

    if (!modules.length) {
        md += `- ${_i18nStr("import_recovery_no_modules", "Aucun module détecté dans ce fichier.")}\n`;
        return md;
    }

    modules.forEach((mod, i) => {
        if (!mod || typeof mod !== "object") return;
        const modTitle = _recAsStr(mod.title || mod.titre || mod.name || "") || `${_i18nStr("import_recovery_module", "Module")} ${i + 1}`;
        md += `\n### ${i + 1}. ${modTitle}\n`;

        const modDesc = _recAsStr(mod.description || mod.desc || mod.details || "");
        if (modDesc) md += `${modDesc}\n\n`;

        // Extract steps/activities
        let steps = [];

        if (Array.isArray(mod.moments) && mod.moments.length) {
            mod.moments.forEach((mom) => {
                if (!mom || typeof mom !== "object") return;
                if (Array.isArray(mom.activites) && mom.activites.length) {
                    mom.activites.forEach((a) => { if (a && typeof a === "object") steps.push(a); });
                } else if (_looksLikePedagogicalStep(mom)) {
                    steps.push(mom);
                }
            });
        } else if (Array.isArray(mod.activites) && mod.activites.length) {
            mod.activites.forEach((a) => { if (a && typeof a === "object") steps.push(a); });
        } else if (Array.isArray(mod.steps) && mod.steps.length) {
            mod.steps.forEach((a) => { if (a && typeof a === "object") steps.push(a); });
        }

        if (!steps.length) {
            md += `- ${_i18nStr("import_recovery_no_steps", "Aucune activité détectée dans ce module.")}\n`;
            return;
        }

        md += `#### ${_i18nStr("import_recovery_activities", "Activités")}\n`;

        steps.forEach((st, j) => {
            const stTitle = _recAsStr(st.title || st.titre || st.name || "") || `${_i18nStr("import_recovery_activity", "Activité")} ${j + 1}`;
            const dur = _recDurationLabel(st);
            md += `\n${j + 1}. **${stTitle}**${dur ? ` — ${dur}` : ""}\n`;

            const type = _recAsStr(st.type || st.learningType || "");
            if (type) md += `   - ${_i18nStr("import_recovery_type", "Type")}: ${type}\n`;

            const grouping = _recAsStr(st.regroupement || st.grouping || "");
            if (grouping) md += `   - ${_i18nStr("import_recovery_grouping", "Regroupement")}: ${grouping}\n`;

            const trainer = _recAsStr(st.formateur || st.trainer || "");
            if (trainer) md += `   - ${_i18nStr("import_recovery_trainer", "Formateur")}: ${trainer}\n`;

            const place = _recAsStr(st.lieu || st.place || "");
            const time = _recAsStr(st.temps || st.time || "");
            if (place || time) md += `   - ${_i18nStr("import_recovery_context", "Contexte")}: ${[place, time].filter(Boolean).join(" • ")}\n`;

            const objective = _recAsStr(st.objectifActivite || st.objective || st.objectif || "");
            if (objective) md += `   - ${_i18nStr("import_recovery_objective", "Objectif")}: ${objective}\n`;

            const tasks = _recAsStr(st.aFaire || st.tasks || st.instructions || "");
            if (tasks) md += `   - ${_i18nStr("import_recovery_tasks", "À faire")}: ${tasks}\n`;

            const notes = _recAsStr(st.notes || "");
            if (notes) md += `   - ${_i18nStr("import_recovery_notes", "Notes")}: ${notes}\n`;
        });
    });

    return md;
}

function downloadLastImportRecoveryText() {
    const obj = window.__lastImportParsedObject;
    if (!obj) {
        showAlert('Erreur', _i18nStr("import_recovery_unavailable", "Aucune donnée exploitable pour la récupération."));
        return;
    }
    try {
        const md = generateRecoveryMarkdown(obj);
        const stamp = (new Date()).toISOString().slice(0,19).replace(/[:T]/g,'-');
        const name = `recuperation_${stamp}.md`;
        _downloadTextFile(name, md, 'text/markdown;charset=utf-8');
    } catch (e) {
        console.error("Recovery export failed:", e);
        showAlert('Erreur', _i18nStr("import_recovery_failed", "La récupération a échoué."));
    }
}

async function copyLastImportRecoveryText() {
    const obj = window.__lastImportParsedObject;
    if (!obj) {
        showAlert('Erreur', _i18nStr("import_recovery_unavailable", "Aucune donnée exploitable pour la récupération."));
        return;
    }
    const btn = document.getElementById("import-error-copy-recovery");
    if (btn && !btn.dataset.origLabel) btn.dataset.origLabel = btn.textContent;

    try {
        const md = generateRecoveryMarkdown(obj);
        const header = "RECOVERY_TEXT_MD\n";
        await _copyTextToClipboard(header + md);

        if (btn) {
            btn.disabled = true;
            const orig = btn.dataset.origLabel || btn.textContent;
            btn.dataset.origLabel = orig;
            btn.textContent = _i18nStr("btn_copied", "Copié");
            setTimeout(() => {
                btn.disabled = false;
                btn.textContent = orig;
            }, 1400);
        }
    } catch (e) {
        console.error("Recovery copy failed:", e);
        showAlert('Erreur', _i18nStr("import_error_copy_failed", "Impossible de copier."));
    }
}


        async function _copyTextToClipboard(text) {
            // Use Clipboard API when available; fallback to textarea selection.
            if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(text);
                return true;
            }
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.setAttribute("readonly", "");
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            ta.style.top = "0";
            document.body.appendChild(ta);
            ta.select();
            ta.setSelectionRange(0, ta.value.length);
            let ok = false;
            try {
                ok = document.execCommand("copy");
            } catch (_) {
                ok = false;
            }
            ta.remove();
            if (!ok) throw new Error("copy_failed");
            return true;
        }

        async function copyLastImportDiagnostic() {
            if (!window.__lastImportReport) return;
            const btnCopy = document.getElementById("import-error-copy");
            if (btnCopy && !btnCopy.dataset.origLabel) btnCopy.dataset.origLabel = btnCopy.textContent;

            // “Diagnostic” = report + short header, ready to paste to support / generative AI.
            const header = "IMPORT_DIAGNOSTIC\n";
            const payload = JSON.stringify(window.__lastImportReport, null, 2);
            const text = header + payload;

            try {
                await _copyTextToClipboard(text);
                if (btnCopy) {
                    // Temporary feedback without changing layout.
                    btnCopy.disabled = true;
                    const orig = btnCopy.dataset.origLabel || btnCopy.textContent;
                    btnCopy.dataset.origLabel = orig;
                    btnCopy.textContent = _i18nStr("btn_copied", "Copié");
                    setTimeout(() => {
                        btnCopy.disabled = false;
                        btnCopy.textContent = orig;
                    }, 1400);
                }
            } catch (e) {
                console.error("Copy diagnostic failed:", e);
                showAlert('Erreur', _i18nStr("import_error_copy_failed", "Impossible de copier le diagnostic dans le presse-papiers."));
                if (btnCopy) btnCopy.disabled = false;
            }
        }

        window.addEventListener("DOMContentLoaded", () => {
            const closeBtn = document.getElementById("import-error-close");
            const dlBtn = document.getElementById("import-error-download");
            const copyBtn = document.getElementById("import-error-copy");
                        const copyRecoveryBtn = document.getElementById("import-error-copy-recovery");
                        const recoverBtn = document.getElementById("import-error-recover");
const modal = document.getElementById("import-error-modal");

            if (closeBtn) closeBtn.addEventListener("click", closeImportErrorModal);
            if (dlBtn) dlBtn.addEventListener("click", downloadLastImportReport);
            if (copyBtn) copyBtn.addEventListener("click", copyLastImportDiagnostic);
                        if (copyRecoveryBtn) copyRecoveryBtn.addEventListener("click", copyLastImportRecoveryText);

                        if (recoverBtn) recoverBtn.addEventListener("click", downloadLastImportRecoveryText);
if (modal) {
                modal.addEventListener("click", (e) => {
                    if (e.target === modal) closeImportErrorModal();
                });
                document.addEventListener("keydown", (e) => {
                    if (e.key === "Escape" && !modal.classList.contains("hidden")) closeImportErrorModal();
                });
            }
        });

   // BUGFIX: Do NOT collapse everything by default - keep moments and activities expanded
   // so all activities are visible when the user first opens the application
   // Previously: collapseAllUiAfterLoad();
   // Now: Keep everything expanded for better visibility (activities view is the default)

            updateEmptyState();
            updateStats();
        
            } finally {
                if (typeof __chartsSuspendFn === 'function') __chartsSuspendFn(false);
            }
        }

window.loadProject = function loadProject(event) {
            const file = event.target.files[0];
            if (!file) { window.__loadFileDialogLock = false; return; }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const project = JSON.parse(e.target.result);
                                        try { window.__lastImportRawJson = String(e.target.result || ""); } catch(_) { window.__lastImportRawJson = null; }
                    window.__lastImportParsedObject = project;
loadProjectFromObject(project);
                    event.target.value = '';
                } catch (err) {

                    console.error("Import parse error:", err);
                    window.__lastImportParsedObject = null;
                    window.__lastImportRawJson = null;
                    const report = window.__ld_buildImportReport({ file, stage: "parse", error: err, parsedObject: null });
                    window.__ld_showImportError(report);
                } finally {
                    window.__loadFileDialogLock = false;
                }
            };
            reader.readAsText(file);
        }

        function addActivityFromData(data) {
            const clone = activityTemplate.content.cloneNode(true);
            root.appendChild(clone);
            const actEl = root.lastElementChild;

            const momentsRoot = actEl.querySelector('.activity-moments-container');
            initSortableMoments(momentsRoot);

            actEl.querySelector('.activity-title').value = data.title || "";
            actEl.querySelector('.activity-description').value = data.description || "";
            
            const __modNotesEl = actEl.querySelector('.module-notes');
            if (__modNotesEl) __modNotesEl.value = (data.notes || data.moduleNotes || "");
            actEl.querySelector('.activity-target-time').value = data.targetTime || "";
            const tgtUnitSel = actEl.querySelector('.activity-target-unit');
            if (tgtUnitSel) tgtUnitSel.value = mapUnitToSecs(data.targetUnit || getDefaultDurationUnitKey());

            // Clear any template content and rebuild moments/steps from data (backward compatible)
            if (momentsRoot) momentsRoot.innerHTML = '';

            if (data.moments && Array.isArray(data.moments) && data.moments.length) {
                data.moments.forEach(momentData => {
                    const mClone = momentTemplate.content.cloneNode(true);
                    if (momentsRoot) momentsRoot.appendChild(mClone);
                    const momentEl = momentsRoot ? momentsRoot.lastElementChild : null;
                    if (momentEl) {
                        const titleInput = momentEl.querySelector('.moment-title');
                        if (titleInput) titleInput.value = momentData.title || "";
                        const mDescInput = momentEl.querySelector('.moment-description');
                        if (mDescInput) mDescInput.value = momentData.description || "";
                                                const mTgt = momentEl.querySelector('.moment-target-time');
                        if (mTgt) mTgt.value = momentData.targetTime || "";
                        const mUnitSel = momentEl.querySelector('.moment-target-unit');
                        if (mUnitSel) mUnitSel.value = mapUnitToSecs(momentData.targetUnit ?? getDefaultDurationUnitKey());
                        try { if (momentData.ignored || momentData.ignore || momentData.ldIgnored) __ldSetIgnored(momentEl, true, { silent: true }); } catch(_){ __ldSilentErr(_); }
const stepsContainer = momentEl.querySelector('.activity-steps-container');
                        initSortableSteps(stepsContainer);
                        try { setupCompactTextareas(momentEl); } catch(_){ __ldSilentErr(_); }

                        const subWrap = momentEl.querySelector('.submoments-container');
                        try { initSortableSubmoments(subWrap); } catch(_){ __ldSilentErr(_); }
                        if (subWrap && ((Array.isArray(momentData.subMoments) && momentData.subMoments.length) || (Array.isArray(momentData.sousMoments) && momentData.sousMoments.length)) && submomentTemplate) {
                            subWrap.innerHTML = '';
                            (momentData.subMoments || momentData.sousMoments || []).forEach((sm, smIdx) => {
                                const smClone = submomentTemplate.content.cloneNode(true);
                                subWrap.appendChild(smClone);
                                const smEl = subWrap.lastElementChild;
                                const smTitle = smEl ? smEl.querySelector('.submoment-title') : null;
                                if (smTitle) smTitle.value = (sm.title || sm.titre || "");
                                const smTgtTime = smEl ? smEl.querySelector('.submoment-target-time') : null;
                                if (smTgtTime) smTgtTime.value = (sm.targetTime || sm.dureeCible || "");
                                const smTgtUnit = smEl ? smEl.querySelector('.submoment-target-unit') : null;
                                if (smTgtUnit) smTgtUnit.value = mapUnitToSecs(sm.targetUnit || sm.uniteDureeCible || getDefaultDurationUnitKey());
                                try { if (sm.ignored || sm.ignore || sm.ldIgnored) __ldSetIgnored(smEl, true, { silent: true }); } catch(_){ __ldSilentErr(_); }
                                const smSteps = smEl ? smEl.querySelector('.submoment-steps') : null;
                                initSortableSteps(smSteps);
                                ((sm.steps || sm.activites || []) || []).forEach(stepData => { addStepToContainerFromData(smSteps, stepData); });
                            });
                        } else {
                            (momentData.steps || []).forEach(stepData => {
                                addStepToContainerFromData(stepsContainer, stepData);
                            });
                        }
                        syncMomentSubmomentsUI(momentEl);
}
                });
                ensureDefaultMoment(actEl);
                updateMomentIndexes(actEl);
            } else {
                ensureDefaultMoment(actEl);
                const moments = actEl.querySelectorAll('.activity-moments-container .moment-group');
                const targetMoment = moments[moments.length - 1];
                const container = targetMoment ? targetMoment.querySelector('.activity-steps-container') : actEl.querySelector('.activity-steps-container');
                (data.steps || []).forEach(stepData => {
                    addStepToContainerFromData(container, stepData);
                });
            }

            applyTranslations();
            try { __ldApplyUnitLabelFormat(); } catch(_){ __ldSilentErr(_); }
            // Restore module-level learning goals/outcomes selections (optional)
            try {
                if (Array.isArray(data.objectifsApprentissageModule)) {
                    setModuleSelectedAims(actEl, data.objectifsApprentissageModule);
                }
                if (Array.isArray(data.resultatsApprentissageModule)) {
                    setModuleSelectedOutcomes(actEl, data.resultatsApprentissageModule);
                }
            } catch(_){ __ldSilentErr(_); }
            try { updateModuleAimsSummary(actEl); } catch(_){ __ldSilentErr(_); }
            try { updateModuleOutcomesSummary(actEl); } catch(_){ __ldSilentErr(_); }

            // Restore module-level targeted competences selections (optional)
            try { populateModuleTargetCompetencesSujetSelect(actEl, data.competencesModuleSujet || []); } catch(_){ __ldSilentErr(_); }
            try { populateModuleTargetCompetencesTransvSelect(actEl, data.competencesModuleTransversales || []); } catch(_){ __ldSilentErr(_); }
            try { updateModuleTargetCompetencesSummary(actEl); } catch(_){ __ldSilentErr(_); }
            try { __ldRefreshIgnoreCascade(); } catch(_){ __ldSilentErr(_); }
            syncSoloMomentUI(actEl);

            return actEl;
        }

        function addStepToContainerFromData(container, data) {
            if (!container) return;
            const clone = stepTemplate.content.cloneNode(true);
            const stepEl = clone.querySelector('.step-card');
            stepEl.querySelector('.step-input-title').value = data.title || "";
            stepEl.querySelector('.learning-type-select').value = data.type || "acquisition";
            const __durRaw = (data && (data.duration ?? data.duree ?? data.durée ?? data.durationVal ?? data.dureeVal ?? data.dureeActivite ?? data.duree_activite)) ?? "";
            stepEl.querySelector('.duration-input').value = (__durRaw === "" || __durRaw == null) ? 0 : __durRaw;
            const __unitRaw = (data && (data.unit ?? data.unite ?? data.durationUnit ?? data.uniteDuree ?? data.unite_duree ?? data.uniteDureeActivite)) ?? getDefaultDurationUnitKey();
            stepEl.querySelector('.duration-unit').value = mapUnitToSecs(__unitRaw);
            stepEl.querySelector('.step-group-mode').value = (data.groupMode || data.regroupement || "class");
            stepEl.querySelector('.step-group-count').value = data.groupCount || 1;
            stepEl.querySelector('.step-group-size').value = data.groupSize || 30;
            const groupDetailsEl = stepEl.querySelector('.step-group-details-notes');
            if (groupDetailsEl) groupDetailsEl.value = data.groupDetails || data.detailsRegroupement || "";
            stepEl.querySelector('.trainer-select').value = data.trainer || "present";
            stepEl.querySelector('.place-select').value = data.place || "situ";
            stepEl.querySelector('.time-select').value = data.time || "sync";
                        stepEl.querySelector('.evaluation-select').value = data.evaluation || "Aucune";
            try { applyStepStatus(stepEl, (data.status ?? data.etat ?? data.state ?? 'in_progress')); } catch(_){ __ldSilentErr(_); }
            try { if (data.ignored || data.ignore || data.isIgnored || data.ldIgnored) __ldSetIgnored(stepEl, true, { silent: true }); } catch(_){ __ldSilentErr(_); }
stepEl.querySelector('.step-input-objective').value = data.objective || "";
            stepEl.querySelector('.step-input-tasks').value = data.tasks || "";
            stepEl.querySelector('.step-input-trainer-tasks').value = data.trainerTasks || data.aFaireFormateur || data.trainer_actions || data.trainerActions || "";
            stepEl.querySelector('.step-input-notes').value = data.notes || "";
            try {
              const lrEl = stepEl.querySelector('.step-input-linksrefs');
              if (lrEl) lrEl.value = (data.liensReferences || data.linksReferences || data.links_refs || data.linksRefs || data.links || data.references || data.refs || data.referencess || "");
            } catch(_){ __ldSilentErr(_); }
            const __ef = stepEl.querySelector('.step-input-eval-followup'); if (__ef) __ef.value = data.evaluationSuivi || data.evaluation || data.suiviEvaluation || data.followUp || data.evalFollowUp || "";
            try { populateStepCompetencesSelect(stepEl, data.competencesSujet || data.competences || data.competenceIds || data.competencies || data.competencesCiblees || []); } catch(_){ __ldSilentErr(_); }
            try { populateStepCompetencesTransversalesSelect(stepEl, data.competencesTransversales || data.transversalCompetences || data.competences_transversales || []); } catch(_){ __ldSilentErr(_); }
            try { populateStepAimsSelect(stepEl, data.objectifsCibles || data.aimsTargeted || data.objectifsCiblesActivite || data.objectifs || []); } catch(_){ __ldSilentErr(_); }
            try { populateStepOutcomesSelect(stepEl, data.resultatsApprentissageCibles || data.outcomesTargeted || data.resultatsCibles || data.resultats || []); } catch(_){ __ldSilentErr(_); }
                        try {
                const rawNotes = (data.outilsMaterielNotes || data.toolsMaterialsNotes || data.toolsMaterialsNotesByItem || {});
                __setStepToolMatNotesMap(stepEl, __normaliseToolsMaterialsNotes(rawNotes));
            } catch(_){ __ldSilentErr(_); }
            try { populateStepToolsMaterialsSelect(stepEl, data.outilsMaterielCibles || data.toolsMaterialsTargets || data.toolsMaterialsTargeted || []); } catch(_){ __ldSilentErr(_); }
try { const _tmD = stepEl.querySelector('.step-tools-materials-select')?.closest('details'); if (_tmD) _tmD.open = false; } catch(_){ __ldSilentErr(_); }
if (((data.groupMode || data.regroupement) === 'groups')) stepEl.querySelector('.step-group-details').classList.remove('hidden');
            container.appendChild(clone);
            try { setupCompactTextareas(stepEl); } catch(_){ __ldSilentErr(_); }
            updateStepType(stepEl.querySelector('.learning-type-select'));
        }

                // --- Core Application Logic ---

        function applyTranslations() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[currentLang][key]) el.innerHTML = sanitizeBasicHtml(translations[currentLang][key]);
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (translations[currentLang][key]) el.placeholder = translations[currentLang][key];
            });
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                if (translations[currentLang][key]) el.title = translations[currentLang][key];
            });
        }

        function toggleGroupMode(select) {
            const card = select.closest('.step-card');
            const details = card.querySelector('.step-group-details');
            if (details) details.classList.add('hidden');
            updateStats();
        }

        function updateGroupMath(input, type) {
            updateStats();
        }

        function updateEmptyState() {
            const hasActivities = root.children.length > 0;
            emptyState.classList.toggle('hidden', hasActivities);
            document.querySelectorAll('.activity-index').forEach((el, i) => { el.innerText = i + 1; });
            root.querySelectorAll('.activity-group').forEach((ag) => { updateMomentIndexes(ag); });
            updateStats();
        }

        function addActivity() {
            historyCaptureNow();
            const clone = activityTemplate.content.cloneNode(true);
            root.appendChild(clone);
            const lastActivity = root.lastElementChild;

            const momentsRoot = lastActivity.querySelector('.activity-moments-container');
            initSortableMoments(momentsRoot);
            ensureDefaultMoment(lastActivity);
            const actUnitSel = lastActivity.querySelector('.activity-target-unit');
            if (actUnitSel) {
                __ldEnsureUnitOption(actUnitSel, 2592000, 'unit_months', 'Mois');
                actUnitSel.value = String(getDefaultDurationUnitSecs());
                __ldLockUnitSelect(actUnitSel);
            }

            addStepToActivity(lastActivity.querySelector('button'));
            applyTranslations();
            try { __ldApplyUnitLabelFormat(); } catch(_){ __ldSilentErr(_); }
            try { updateModuleAimsSummary(lastActivity); } catch(_){ __ldSilentErr(_); }
            try { populateModuleTargetCompetencesSujetSelect(lastActivity); } catch(_){ __ldSilentErr(_); }
            try { populateModuleTargetCompetencesTransvSelect(lastActivity); } catch(_){ __ldSilentErr(_); }
            try { updateModuleTargetCompetencesSummary(lastActivity); } catch(_){ __ldSilentErr(_); }
            try { updateModuleOutcomesSummary(lastActivity); } catch(_){ __ldSilentErr(_); }
            syncSoloMomentUI(lastActivity);
            updateEmptyState();
        }

        function addStepToActivity(btnOrEvent) {
            historyCaptureNow();
            // Robust handler: accepts either a button element or a click event
            const btn = (btnOrEvent && (btnOrEvent.currentTarget || btnOrEvent.target)) ? (btnOrEvent.currentTarget || btnOrEvent.target) : btnOrEvent;

            const activityGroup = btn && btn.closest ? btn.closest('.activity-group') : null;
            if (!activityGroup) return;

            ensureDefaultMoment(activityGroup);
            const moments = activityGroup.querySelectorAll('.activity-moments-container .moment-group');
            const targetMoment = moments[moments.length - 1];
            let container = targetMoment
                ? targetMoment.querySelector('.activity-steps-container')
                : activityGroup.querySelector('.activity-steps-container');

            // If sub-moments exist, add activities into the last sub-moment by default
            let addedToSubmoment = false;
            try {
                const subs = targetMoment ? targetMoment.querySelectorAll('.submoments-container .submoment-card') : [];
                if (subs && subs.length) {
                    const lastSub = subs[subs.length - 1];
                    const smCont = lastSub ? lastSub.querySelector('.submoment-steps') : null;
                    if (smCont) {
                        container = smCont;
                        addedToSubmoment = true;
                    }
                }
            } catch(_){ __ldSilentErr(_); }

            if (!container) return;

            const clone = stepTemplate.content.cloneNode(true);
            container.appendChild(clone);

            const newStep = container.lastElementChild;

            try { applyStepStatus(newStep, 'in_progress'); } catch(_){ __ldSilentErr(_); }

            
            try { populateStepCompetencesSelect(newStep, []); } catch(_){ __ldSilentErr(_); }
            try { populateStepCompetencesTransversalesSelect(newStep, []); } catch(_){ __ldSilentErr(_); }
            try { populateStepAimsSelect(newStep, []); } catch(_){ __ldSilentErr(_); }
            try { populateStepOutcomesSelect(newStep, []); } catch(_){ __ldSilentErr(_); }
            try { populateStepToolsMaterialsSelect(newStep, []); } catch(_){ __ldSilentErr(_); }

            try { setupCompactTextareas(newStep); } catch(_){ __ldSilentErr(_); }
try { const _tmD = newStep.querySelector('.step-tools-materials-select')?.closest('details'); if (_tmD) _tmD.open = false; } catch(_){ __ldSilentErr(_); }
// Default unit should be "min" (stored as 60 seconds)
            const unitSelect = newStep ? newStep.querySelector('.duration-unit') : null;
            if (unitSelect) {
                __ldEnsureUnitOption(unitSelect, 2592000, 'unit_months', 'Mois');
                unitSelect.value = String(getDefaultDurationUnitSecs());
                __ldLockUnitSelect(unitSelect);
            }

            // Ensure group-size reflects global cohort size at creation time
            const groupSize = newStep ? newStep.querySelector('.step-group-size') : null;
            const globalSize = document.getElementById('global-class-size');
            if (groupSize && globalSize) groupSize.value = globalSize.value;

            // Ensure Bloom dropdowns are correctly populated on newly-added steps
            const outLevel = newStep ? newStep.querySelector('.outcome-bloom-level') : null;
            if (outLevel) renderBloomOptions(outLevel, outLevel.value || "");

            // CRITICAL FIX: Ensure the new activity is visible
            // If we added to a sub-moment or if activities are hidden in current view, switch to "activities" view
            try {
                const lvl = document.body && document.body.getAttribute ? document.body.getAttribute('data-view-level') : '';
                const currentLevel = String(lvl || '').trim();
                
                // Switch to activities view if:
                // 1. We're in "modules" view (activities hidden)
                // 2. We're in "moments" view (activities hidden)
                // 3. We added to a submoment and we're not already in "activities" view
                if (currentLevel === 'modules' || currentLevel === 'moments' || (addedToSubmoment && currentLevel !== 'activities')) {
                    if (typeof applyViewLevel === 'function') {
                        applyViewLevel('activities');
                    } else if (document.body && document.body.setAttribute) {
                        document.body.setAttribute('data-view-level', 'activities');
                    }
                }
                
                // Also ensure the moment is expanded if it was collapsed
                if (targetMoment) {
                    const momentBody = targetMoment.querySelector('.moment-body');
                    if (momentBody && momentBody.classList.contains('collapsed')) {
                        momentBody.classList.remove('collapsed');
                        const toggleBtn = targetMoment.querySelector('button[data-action="toggle-moment"]');
                        if (toggleBtn) {
                            toggleBtn.setAttribute('aria-expanded', 'true');
                            const icon = toggleBtn.querySelector('.rotate-icon');
                            if (icon) icon.style.transform = 'rotate(180deg)';
                        }
                    }
                }
            } catch(_){ __ldSilentErr(_); }

            // Ensure UI updates
            updateStats();
            
            // CRITICAL FIX: Scroll to the new activity and highlight it
            try {
                // Force a small delay to ensure view change is applied
                setTimeout(() => {
                    if (newStep && typeof newStep.scrollIntoView === 'function') {
                        newStep.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        newStep.classList.add('newly-created-activity');
                        setTimeout(() => {
                            if (newStep) newStep.classList.remove('newly-created-activity');
                        }, 2000);
                    }
                }, 150);
            } catch(_){ __ldSilentErr(_); }
        }

        function copyFormValues(source, dest) {
            const srcInputs = source.querySelectorAll('input');
            const destInputs = dest.querySelectorAll('input');
            srcInputs.forEach((inp, i) => { if (destInputs[i]) destInputs[i].value = inp.value; });

            const srcText = source.querySelectorAll('textarea');
            const destText = dest.querySelectorAll('textarea');
            srcText.forEach((txt, i) => { if (destText[i]) destText[i].value = txt.value; });

            const srcSelects = source.querySelectorAll('select');
            const destSelects = dest.querySelectorAll('select');
            srcSelects.forEach((sel, i) => {
                const dst = destSelects[i];
                if (!dst) return;
                if (sel && sel.multiple) {
                    const selected = Array.from(sel.selectedOptions || []).map(o => o.value);
                    Array.from(dst.options || []).forEach(o => {
                        o.selected = selected.includes(o.value);
                    });
                } else {
                    dst.value = sel.value;
                }
            });
        }// RENAMED TO AVOID CONFLICTS
        function cloneModule(btn) {
            historyCaptureNow();
            const original = btn.closest('.activity-group');
            const clone = original.cloneNode(true);
            original.after(clone);
            copyFormValues(original, clone);
            
            // Explicitly rebind buttons in the clone to be safe - CRITICAL FIX
            // Remove any manual rebind logic that depends on titles and let inline handlers work
            // The cloneNode(true) copies the type="button" data-action="duplicate-module" correctly.
            
            const momentsRoot = clone.querySelector('.activity-moments-container');
            initSortableMoments(momentsRoot);
            clone.querySelectorAll('.activity-steps-container').forEach((c) => initSortableSteps(c));
            ensureDefaultMoment(clone);
            updateMomentIndexes(clone);
            updateEmptyState();
            updateStats();
        }

        // RENAMED TO AVOID CONFLICTS
        function cloneStep(btn) {
            historyCaptureNow();
            const original = btn.closest('.step-card');
            const clone = original.cloneNode(true);
            original.after(clone);
            copyFormValues(original, clone);
            const select = clone.querySelector('.learning-type-select');
            updateStepType(select);
            updateStats();
        }

        // RENAMED AND FIXED MODAL LOGIC
        // Signature supports both: trashModule(this) and trashModule(event, this)
        function trashModule(evtOrBtn, maybeBtn) {
            const evt = (evtOrBtn && typeof evtOrBtn === 'object' && 'preventDefault' in evtOrBtn) ? evtOrBtn : null;
            const btn = evt ? maybeBtn : evtOrBtn;

            if (!btn) return;
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }

            const activityGroup = btn.closest('.activity-group');
            if (!activityGroup) return;

            const modal = document.getElementById('custom-confirm-modal');
            const msg = document.getElementById('custom-confirm-msg');

            // Fallback: if modal is missing for any reason, delete directly.
            if (!modal || !msg) {
                activityGroup.remove();
                updateEmptyState();
                return;
            }

            msg.innerText = translations[currentLang].confirm_delete_activity || 'Supprimer ce module ?';

            // Set the *single* pending confirm action. This prevents stacked handlers (which can cause duplication).
            __confirmAction = () => {
                historyCaptureNow();
                activityGroup.remove();
                updateEmptyState();
            };

            modal.classList.remove('hidden');
        }
        // RENAMED TO AVOID CONFLICTS
        function trashStep(btn) {
            historyCaptureNow();
            btn.closest('.step-card').remove();
            updateStats();
        }

        function updateStepType(select) {
            const card = select.closest('.step-card');
            const type = select.value;
            const types = Object.keys(TYPE_COLORS).map(t => `type-${t}`);
            card.classList.remove(...types);
            card.classList.add(`type-${type}`);
            const selectStyles = Object.keys(TYPE_COLORS).map(t => `select-${t}`);
            select.classList.remove(...selectStyles);
            select.classList.add(`select-${type}`);
            updateStats();
        }

        // --- Step status (Finalisé / À revoir / En cours) ---
        function normaliseStepStatus(v) {
            const raw = String(v ?? '').trim().toLowerCase();
            if (!raw) return 'in_progress';
            // Common synonyms (FR/EN)
            if (['done','final','finalised','finalized','finalise','finalisé','termine','terminé','ok','validé','valide'].includes(raw)) return 'done';
            if (['review','to_review','a_revoir','a revoir','à revoir','revoir','rework','needs_review','à valider','a valider'].includes(raw)) return 'review';
            if (['in_progress','progress','en_cours','en cours','draft','brouillon','todo','à faire','a faire'].includes(raw)) return 'in_progress';
            return 'in_progress';
        }

        function getStepStatus(stepEl) {
            try {
                const ds = stepEl?.dataset?.status;
                if (ds) return normaliseStepStatus(ds);
                const sel = stepEl?.querySelector?.('.step-status-select');
                if (sel) return normaliseStepStatus(sel.value);
            } catch(_){ __ldSilentErr(_); }
            return 'in_progress';
        }

        function applyStepStatus(stepEl, statusKey) {
            if (!stepEl) return;
            const st = normaliseStepStatus(statusKey);
            try { stepEl.dataset.status = st; } catch(_){ __ldSilentErr(_); }
            const sel = stepEl.querySelector?.('.step-status-select');
            if (sel && sel.value !== st) sel.value = st;
            const dot = stepEl.querySelector?.('.step-status-dot');
            if (dot) {
                dot.dataset.val = st;
                const titles = {in_progress:'En cours',done:'Finalisé',review:'À revoir'};
                dot.title = 'État : ' + (titles[st] || st);
            }
        }

        function updateStepStatus(el) {
            try { historyCaptureNow(); } catch(_){ __ldSilentErr(_); }
            const stepEl = el?.closest ? el.closest('.step-card') : null;
            if (!stepEl) return;
            applyStepStatus(stepEl, el.value);
            try { __ldUpdateAllStatusSummariesDebounced(); } catch(_){ __ldSilentErr(_); }
            try { updateStatsDebounced(); } catch(_){ __ldSilentErr(_); }
            try { __ldApplyStatusFilterDebounced(); } catch(_){ __ldSilentErr(_); }
        }

        // --- Status dot widget (compact icon dropdown) ---
        (function(){
            let _activeDot = null; // the dot button that opened the floating menu
            const _floatingMenu = document.createElement('div');
            _floatingMenu.className = 'step-status-dot-menu';
            _floatingMenu.innerHTML =
                '<button type="button" class="step-status-dot-menu-item" data-val="in_progress" title="En cours"></button>' +
                '<button type="button" class="step-status-dot-menu-item" data-val="review" title="À revoir"></button>' +
                '<button type="button" class="step-status-dot-menu-item" data-val="done" title="Finalisé"></button>';
            document.body.appendChild(_floatingMenu);

            function closeMenu(){
                _floatingMenu.classList.remove('open');
                _activeDot = null;
            }
            document.addEventListener('click', function(e){
                // Click on the dot => toggle menu
                const dot = e.target.closest?.('.step-status-dot');
                if (dot) {
                    e.stopPropagation();
                    if (_activeDot === dot) { closeMenu(); return; }
                    _activeDot = dot;
                    const rect = dot.getBoundingClientRect();
                    _floatingMenu.style.left = Math.max(0, rect.left + rect.width / 2 - 45) + 'px';
                    _floatingMenu.style.top = (rect.bottom + 4) + 'px';
                    _floatingMenu.classList.add('open');
                    return;
                }
                // Click on a menu item => apply status
                const item = e.target.closest?.('.step-status-dot-menu-item');
                if (item && _activeDot) {
                    e.stopPropagation();
                    const val = item.dataset.val;
                    const stepEl = _activeDot.closest('.step-card');
                    const sel = stepEl?.querySelector('.step-status-select');
                    if (sel) { sel.value = val; sel.dispatchEvent(new Event('change', {bubbles:true})); }
                    else if (stepEl) { applyStepStatus(stepEl, val); }
                    closeMenu();
                    return;
                }
                // Click elsewhere => close menu
                closeMenu();
            });
        })();

        // --- Status filter (affichage : Tous / À revoir / En cours / Finalisé) ---
        let __ldStatusFilterTimer = null;

        function __ldGetStatusFilterValue(){
            const sel = document.getElementById('status-filter');
            const v = String(sel?.value || 'all').trim();
            return (v === 'review' || v === 'done' || v === 'in_progress' || v === 'all') ? v : 'all';
        }

        function __ldSetStatusFilterValue(v){
            const sel = document.getElementById('status-filter');
            if (!sel) return;
            const vv = (v === 'review' || v === 'done' || v === 'in_progress' || v === 'all') ? v : 'all';
            sel.value = vv;
            try { localStorage.setItem('ld_status_filter', vv); } catch(_){ __ldSilentErr(_); }
        }

        function __ldApplyStatusFilter(){
            const v = __ldGetStatusFilterValue();

            // Filter step cards
            __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stepEl => {
                let st = 'in_progress';
                try { st = (typeof getStepStatus === 'function') ? getStepStatus(stepEl) : (stepEl?.dataset?.status || 'in_progress'); } catch(_){ __ldSilentErr(_); }
                st = (typeof normaliseStepStatus === 'function') ? normaliseStepStatus(st) : String(st || '').trim();
                const show = (v === 'all') || (st === v);
                stepEl.classList.toggle('ld-hidden-by-status-filter', !show);
            });

            // Hide empty containers (sub-moments, moments, modules)
            // IMPORTANT: keep containers with 0 activities visible, otherwise creating a new empty sub-moment
            // would appear briefly and then be hidden by the status filter.
            document.querySelectorAll('.submoment-card').forEach(subEl => {
                const total = __ldFilterStepNodeList(subEl.querySelectorAll('.step-card')).length;
                const anyVisible = !!subEl.querySelector('.step-card:not(.ld-hidden-by-status-filter)');
                const shouldHide = (total > 0) && !anyVisible;
                subEl.classList.toggle('ld-hidden-by-status-filter', shouldHide);
            });

            document.querySelectorAll('.moment-group').forEach(momentEl => {
                const total = __ldFilterStepNodeList(momentEl.querySelectorAll('.step-card')).length;
                const anyVisible = !!momentEl.querySelector('.step-card:not(.ld-hidden-by-status-filter)');
                const shouldHide = (total > 0) && !anyVisible;
                momentEl.classList.toggle('ld-hidden-by-status-filter', shouldHide);
            });

            document.querySelectorAll('.activity-group').forEach(modEl => {
                const total = __ldFilterStepNodeList(modEl.querySelectorAll('.step-card')).length;
                const anyVisible = !!modEl.querySelector('.step-card:not(.ld-hidden-by-status-filter)');
                const shouldHide = (total > 0) && !anyVisible;
                modEl.classList.toggle('ld-hidden-by-status-filter', shouldHide);
            });

            // Empty message (only when a filter is active)
            const emptyEl = document.getElementById('status-filter-empty');
            if (emptyEl){
                const anyVisible = !!document.querySelector('.step-card:not(.ld-hidden-by-status-filter)');
                emptyEl.classList.toggle('hidden', anyVisible || v === 'all');
            }

            // If panorama is active, refresh the table to reflect the same filter
            try { if (document.body?.dataset?.viewLevel === 'panorama' && typeof renderPanoramaView === 'function') renderPanoramaView(); } catch(_){ __ldSilentErr(_); }
        }

        function __ldApplyStatusFilterDebounced(){
            try { if (__ldStatusFilterTimer) clearTimeout(__ldStatusFilterTimer); } catch(_){ __ldSilentErr(_); }
            __ldStatusFilterTimer = setTimeout(() => {
                try { __ldApplyStatusFilter(); } catch(_){ __ldSilentErr(_); }
            }, 40);
        }

        function __ldInitStatusFilterUI(){
            const sel = document.getElementById('status-filter');
            const btn = document.getElementById('status-filter-clear');
            if (!sel) return;
            if (sel.dataset && sel.dataset.ldInited === '1') return;
            if (sel.dataset) sel.dataset.ldInited = '1';

            // Load saved value
            try {
                const saved = localStorage.getItem('ld_status_filter');
                if (saved && (saved === 'all' || saved === 'review' || saved === 'done' || saved === 'in_progress')){
                    sel.value = saved;
                }
            } catch(_){ __ldSilentErr(_); }

            sel.addEventListener('change', () => {
                try { localStorage.setItem('ld_status_filter', __ldGetStatusFilterValue()); } catch(_){ __ldSilentErr(_); }
                __ldApplyStatusFilterDebounced();
            });

            if (btn){
                btn.addEventListener('click', () => {
                    __ldSetStatusFilterValue('all');
                    __ldApplyStatusFilterDebounced();
                });
            }

            __ldApplyStatusFilterDebounced();
        }

// --- Toggle status summaries (afficher/masquer) ---
function __ldAreStatusSummariesVisible(){
    try { return (localStorage.getItem('ld_show_status_summaries') ?? '1') !== '0'; } catch (_) { return true; }
}

function __ldUpdateStatusSummariesToggleButton(){
    const btn = document.getElementById('btn-toggle-status-summaries');
    if (!btn) return;
    const icon = document.getElementById('icon-toggle-status-summaries');
    const txt = document.getElementById('text-toggle-status-summaries');
    const visible = !document.body.classList.contains('ld-hide-status-summaries');
    if (icon) icon.textContent = visible ? 'visibility_off' : 'visibility';
    if (txt) txt.textContent = visible ? 'Masquer synthèses' : 'Afficher synthèses';
    btn.setAttribute('aria-pressed', visible ? 'true' : 'false');
}

function __ldSetStatusSummariesVisible(isVisible){
    const v = isVisible ? '1' : '0';
    try { localStorage.setItem('ld_show_status_summaries', v); } catch(_){ __ldSilentErr(_); }
    try { document.body.classList.toggle('ld-hide-status-summaries', !isVisible); } catch(_){ __ldSilentErr(_); }
    try { __ldUpdateStatusSummariesToggleButton(); } catch(_){ __ldSilentErr(_); }
    if (isVisible){
        try { __ldUpdateAllStatusSummariesDebounced(); } catch(_){ __ldSilentErr(_); }
    }
}

function __ldInitStatusSummariesToggleUI(){
    const btn = document.getElementById('btn-toggle-status-summaries');
    if (!btn) return;
    if (btn.dataset && btn.dataset.ldInited === '1') return;
    if (btn.dataset) btn.dataset.ldInited = '1';

    // Load saved preference (default: visible)
    let visible = true;
    try {
        const saved = localStorage.getItem('ld_show_status_summaries');
        if (saved === '0') visible = false;
    } catch(_){ __ldSilentErr(_); }

    try { document.body.classList.toggle('ld-hide-status-summaries', !visible); } catch(_){ __ldSilentErr(_); }
    try { __ldUpdateStatusSummariesToggleButton(); } catch(_){ __ldSilentErr(_); }

    btn.addEventListener('click', () => {
        const currentlyHidden = document.body.classList.contains('ld-hide-status-summaries');
        __ldSetStatusSummariesVisible(currentlyHidden); // if hidden -> show, else hide

        // Auto-close "Affichage des états" menu after selecting an option.
        try {
            const det = btn.closest('details');
            if (det) det.open = false;
        } catch(_){ __ldSilentErr(_); }
    });
}

document.addEventListener('DOMContentLoaded', () => { try { __ldInitStatusSummariesToggleUI(); } catch(_){ __ldSilentErr(_); } }, { once: true });

// --- Toggle status selectors (afficher/masquer les sélecteurs d'état dans les activités) ---
function __ldAreStatusSelectorsVisible(){
    try { return (localStorage.getItem('ld_show_status_selectors') ?? '0') === '1'; } catch (_) { return false; }
}

function __ldUpdateStatusSelectorsToggleButton(){
    const btn = document.getElementById('btn-toggle-status-selectors');
    if (!btn) return;
    const icon = document.getElementById('icon-toggle-status-selectors');
    const txt = document.getElementById('text-toggle-status-selectors');
    const visible = document.body.classList.contains('ld-show-status-selectors');
    if (icon) icon.textContent = visible ? 'visibility_off' : 'visibility';
    if (txt) {
        const t = translations[currentLang] || translations.fr || {};
        txt.textContent = visible ? (t.btn_hide_status_selectors || 'Masquer états') : (t.btn_show_status_selectors || 'Afficher états');
        txt.setAttribute('data-i18n', visible ? 'btn_hide_status_selectors' : 'btn_show_status_selectors');
    }
    btn.setAttribute('aria-pressed', visible ? 'true' : 'false');
}

function __ldSetStatusSelectorsVisible(isVisible){
    const v = isVisible ? '1' : '0';
    try { localStorage.setItem('ld_show_status_selectors', v); } catch(_){ __ldSilentErr(_); }
    try { document.body.classList.toggle('ld-show-status-selectors', isVisible); } catch(_){ __ldSilentErr(_); }
    try { __ldUpdateStatusSelectorsToggleButton(); } catch(_){ __ldSilentErr(_); }
}

function __ldInitStatusSelectorsToggleUI(){
    const btn = document.getElementById('btn-toggle-status-selectors');
    if (!btn) return;
    if (btn.dataset && btn.dataset.ldInited === '1') return;
    if (btn.dataset) btn.dataset.ldInited = '1';

    // Force states to be hidden by default on every page load
    let visible = false;
    try {
        localStorage.setItem('ld_show_status_selectors', '0');
    } catch(_){ __ldSilentErr(_); }

    try { document.body.classList.toggle('ld-show-status-selectors', visible); } catch(_){ __ldSilentErr(_); }
    try { __ldUpdateStatusSelectorsToggleButton(); } catch(_){ __ldSilentErr(_); }

    btn.addEventListener('click', () => {
        const currentlyVisible = document.body.classList.contains('ld-show-status-selectors');
        __ldSetStatusSelectorsVisible(!currentlyVisible); // toggle

        // Auto-close "Affichage des états" menu after selecting an option.
        try {
            const det = btn.closest('details');
            if (det) det.open = false;
        } catch(_){ __ldSilentErr(_); }
    });
}

document.addEventListener('DOMContentLoaded', () => { try { __ldInitStatusSelectorsToggleUI(); } catch(_){ __ldSilentErr(_); } }, { once: true });


        // --- Status summaries (Module / Moment / Sous-moment) ---
        let __ldStatusSummaryTimer = null;

        function __ldComputeStatusCounts(rootEl){
            const counts = { done: 0, review: 0, in_progress: 0, total: 0 };
            if (!rootEl) return counts;
            const steps = __ldQueryDesignedStepCards(rootEl);
            steps.forEach(stepEl => {
                const st = getStepStatus(stepEl);
                if (st === 'done') counts.done += 1;
                else if (st === 'review') counts.review += 1;
                else counts.in_progress += 1;
                counts.total += 1;
            });
            return counts;
        }

        function __ldRenderStatusSummary(summaryEl, counts){
            if (!summaryEl) return;
            const total = counts?.total || 0;
            if (total <= 0){
                summaryEl.innerHTML = '<span class="ld-ss-empty">0</span>';
                return;
            }
            // Vertical histogram: bar height proportional to count, max bar = 22px
            const maxH = 22;
            const maxVal = Math.max(counts.done || 0, counts.review || 0, counts.in_progress || 0, 1);
            function barH(v){ return Math.max(2, Math.round((v / maxVal) * maxH)); }
            function col(cls, v, label){
                return '<div class="ld-ss-bar-col" title="' + label + ' : ' + v + '">' +
                    '<span class="ld-ss-count">' + v + '</span>' +
                    '<div class="ld-ss-bar ld-ss-bar--' + cls + '" style="height:' + barH(v) + 'px"></div>' +
                '</div>';
            }
            summaryEl.innerHTML =
                col('progress', counts.in_progress || 0, 'En cours') +
                col('review', counts.review || 0, 'À revoir') +
                col('done', counts.done || 0, 'Finalisé');
        }

        function __ldEnsureModuleSummaryEl(modEl){
            if (!modEl) return null;
            let el = modEl.querySelector('.activity-status-summary');
            if (el){ el.classList && el.classList.add('ld-status-summary--module'); return el; }
            const btn = modEl.querySelector('[data-action="toggle-module-subblocks"]');
            if (!btn || !btn.parentElement) return null;
            el = document.createElement('div');
            el.className = 'activity-status-summary ld-status-summary ld-status-summary--module';
            el.title = "Synthèse des états des activités du module";
            btn.parentElement.insertBefore(el, btn);
            return el;
        }

        function __ldEnsureMomentSummaryEl(momentEl){
            if (!momentEl) return null;
            let el = momentEl.querySelector('.moment-status-summary');
            if (el){ el.classList && el.classList.add('ld-status-summary--moment'); return el; }
            const btn = momentEl.querySelector('[data-action="toggle-moment-description"]');
            if (!btn || !btn.parentElement) return null;
            el = document.createElement('div');
            el.className = 'moment-status-summary ld-status-summary ld-status-summary--moment';
            el.title = "Synthèse des états des activités du moment";
            btn.parentElement.insertBefore(el, btn);
            return el;
        }

        function __ldEnsureSubmomentSummaryEl(subEl){
            if (!subEl) return null;
            let el = subEl.querySelector('.submoment-status-summary');
            if (el) return el;
            const btn = subEl.querySelector('[data-action="add-step-submoment"]');
            if (!btn || !btn.parentElement) return null;
            el = document.createElement('div');
            el.className = 'submoment-status-summary ld-status-summary';
            el.title = "Synthèse des états des activités du sous-moment";
            btn.parentElement.insertBefore(el, btn);
            return el;
        }

        function __ldUpdateAllStatusSummaries(){
            // Modules
            document.querySelectorAll('.activity-group').forEach(modEl => {
                const sumEl = __ldEnsureModuleSummaryEl(modEl);
                __ldRenderStatusSummary(sumEl, __ldComputeStatusCounts(modEl));
            });
            // Moments
            document.querySelectorAll('.moment-group').forEach(momentEl => {
                const sumEl = __ldEnsureMomentSummaryEl(momentEl);
                __ldRenderStatusSummary(sumEl, __ldComputeStatusCounts(momentEl));
            });
            // Sous-moments
            document.querySelectorAll('.submoment-card').forEach(subEl => {
                const sumEl = __ldEnsureSubmomentSummaryEl(subEl);
                __ldRenderStatusSummary(sumEl, __ldComputeStatusCounts(subEl));
            });
        }

        function __ldUpdateAllStatusSummariesDebounced(){
            try { if (__ldStatusSummaryTimer) clearTimeout(__ldStatusSummaryTimer); } catch(_){ __ldSilentErr(_); }
            __ldStatusSummaryTimer = setTimeout(() => {
                try { __ldUpdateAllStatusSummaries(); } catch(_){ __ldSilentErr(_); }
            }, 60);
        }


        function getTotals() {
            const activities = document.querySelectorAll('.activity-group');
            const classSize = parseInt((document.getElementById('global-class-size')?.value)) || 1;
            const typeTime = { acquisition: 0, collaboration: 0, discussion: 0, investigation: 0, practice: 0, production: 0 };
            const timelineData = [];
            const detailedTimeline = [];
            let totalSecs = 0;
            let currentTimelineSecs = 0;

            activities.forEach((act, idx) => {
                const title = act.querySelector('.activity-title').value || `${translations[currentLang].md_untitled_activity} ${idx+1}`;
                let actSecs = 0;
                const activitySteps = [];
                const steps = __ldQueryDesignedStepCards(act);
                steps.forEach(step => {
                    const secs = getStepDurationSecs(step);
                    const type = step.querySelector('.learning-type-select').value;
                    
                    const stepTitle = step.querySelector('.step-input-title').value || translations[currentLang].md_untitled_step;
                    activitySteps.push({
                        title: stepTitle,
                        type: type,
                        duration: secs,
                        learningTypeLabel: translations[currentLang][`type_${type}`],
                        groupMode: step.querySelector('.step-group-mode').value,
                        trainer: step.querySelector('.trainer-select').value,
                        place: step.querySelector('.place-select').value,
                        time: step.querySelector('.time-select').value
                    });

                    currentTimelineSecs += secs;
                    const mode = step.querySelector('.step-group-mode').value;
                    let stepGroupSize = mode === 'groups' ? (parseInt(step.querySelector('.step-group-size').value) || classSize) : classSize;
                    typeTime[type] += secs;
                    actSecs += secs;
                    totalSecs += secs;
                });
                timelineData.push({ title, duration: Math.round(actSecs / 60) });
                detailedTimeline.push({ title: title, duration: actSecs, steps: activitySteps });
            });
            return { totalSecs, detailedTimeline };
        }

        // Timeline label formatter (compact): m / h / j(d) / sem(w) / mo
        
        // Zoom de la visualisation temporelle (piste / règles)
        let timelineZoom = 1;

        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

        function setTimelineZoom(z){
            timelineZoom = clamp(parseFloat(z) || 1, 0.5, 3);
            applyTimelineZoom();
        }

        function applyTimelineZoom(){
            const zr = document.getElementById('timeline-zoom-range');
            const zv = document.getElementById('timeline-zoom-value');
            if(zr) zr.value = String(timelineZoom);
            if(zv) zv.textContent = `${Math.round(timelineZoom * 100)}%`;

            // Preserve current relative scroll position when changing zoom
            const before = __getTimelineTracks();
            const beforeMax = before.maxScroll || 0;
            const beforeLeft = before.outers[0] ? (before.outers[0].scrollLeft || 0) : 0;
            const ratio = beforeMax > 0 ? (beforeLeft / beforeMax) : 0;

            // Stretch the inner content to create real horizontal overflow
            const pct = (timelineZoom * 100);
            document.querySelectorAll('#timeline-panel .timeline-zoom-outer').forEach(outer => {
                const inner = outer.querySelector(':scope > .timeline-inner');
                if(inner){
                    inner.style.minWidth = pct + '%';
                    inner.style.width = pct + '%';
                }
            });

            // Re-sync unified scrollbar after layout settles
            requestAnimationFrame(() => {
                const after = __getTimelineTracks();
                const afterMax = after.maxScroll || 0;
                const targetLeft = afterMax > 0 ? clamp(ratio * afterMax, 0, afterMax) : 0;

                __timelineHScroll.busy = true;
                const bar = document.getElementById('timeline-hscroll');
                if(bar) bar.scrollLeft = targetLeft;
                after.outers.forEach(o => { o.scrollLeft = targetLeft; });
                __timelineHScroll.busy = false;

                updateTimelineHScroll();
            });
        }

        
        const __timelineHScroll = { busy:false, ro:null };

        function __getTimelineTracks(){
            const outers = Array.from(document.querySelectorAll('#timeline-panel .timeline-zoom-outer'));
            let maxScrollWidth = 0;
            outers.forEach(o => { maxScrollWidth = Math.max(maxScrollWidth, o.scrollWidth); });
            const viewportWidth = outers[0] ? outers[0].clientWidth : 0;
            const maxScroll = Math.max(0, maxScrollWidth - viewportWidth);
            return { outers, maxScrollWidth, viewportWidth, maxScroll };
        }

        function updateTimelineHScrollThumb(){
            const bar = document.getElementById('timeline-hscroll');
            const thumb = document.getElementById('timeline-hscroll-thumb');
            if(!bar || !thumb) return;

            const { maxScrollWidth, viewportWidth, maxScroll, outers } = __getTimelineTracks();
            const trackW = bar.clientWidth || 0;

            if(!trackW || !maxScrollWidth || !viewportWidth || !outers.length){
                bar.classList.add('is-disabled');
                thumb.style.width = Math.max(36, Math.round(trackW * 0.4)) + 'px';
                thumb.style.left = '0px';
                return;
            }

            const scrollLeft = outers[0].scrollLeft || 0;

            if(maxScroll <= 1){
                bar.classList.add('is-disabled');
                const w = Math.max(36, Math.round((viewportWidth / maxScrollWidth) * trackW));
                thumb.style.width = w + 'px';
                thumb.style.left = '0px';
                return;
            }

            bar.classList.remove('is-disabled');

            const thumbW = Math.max(36, Math.round((viewportWidth / maxScrollWidth) * trackW));
            const maxThumbX = Math.max(0, trackW - thumbW);
            const x = maxThumbX * (scrollLeft / maxScroll);
            thumb.style.width = thumbW + 'px';
            thumb.style.left = Math.round(x) + 'px';
        }

        function updateTimelineHScroll(){
            const bar = document.getElementById('timeline-hscroll');
            const inner = document.getElementById('timeline-hscroll-inner');
            if(!bar || !inner) return;

            const { outers, maxScrollWidth } = __getTimelineTracks();
            if(!outers.length) { inner.style.width = '0px'; updateTimelineHScrollThumb(); return; }

            inner.style.width = Math.max(maxScrollWidth, bar.clientWidth) + 'px';

            if(!bar.dataset.bound){
                bar.dataset.bound = '1';
                bar.addEventListener('scroll', () => {
                    if(__timelineHScroll.busy) return;
                    const { outers } = __getTimelineTracks();
                    if(!outers.length) return;

                    __timelineHScroll.busy = true;
                    const x = bar.scrollLeft;
                    outers.forEach(o => { o.scrollLeft = x; });
                    __timelineHScroll.busy = false;
                    updateTimelineHScrollThumb();
                }, { passive:true });
            }

            outers.forEach(o => {
                if(o.dataset.hscrollBound) return;
                o.dataset.hscrollBound = '1';
                o.addEventListener('scroll', () => {
                    if(__timelineHScroll.busy) return;
                    __timelineHScroll.busy = true;
                    bar.scrollLeft = o.scrollLeft;
                    __timelineHScroll.busy = false;
                    updateTimelineHScrollThumb();
                }, { passive:true });
            });

            if(window.ResizeObserver && !__timelineHScroll.ro){
                __timelineHScroll.ro = new ResizeObserver(() => updateTimelineHScroll());
                __timelineHScroll.ro.observe(bar);
            }
            if(__timelineHScroll.ro){
                outers.forEach(o => __timelineHScroll.ro.observe(o));
            }

            if(!window.__timelineHScrollWindowResizeBound){
                window.__timelineHScrollWindowResizeBound = true;
                window.addEventListener('resize', () => updateTimelineHScroll());
            }

            updateTimelineHScrollThumb();
        }

        function initTimelineHScrollThumbDrag(){
            const bar = document.getElementById('timeline-hscroll');
            const thumb = document.getElementById('timeline-hscroll-thumb');
            if(!bar || !thumb || thumb.dataset.bound) return;
            thumb.dataset.bound = '1';

            let dragging = false;
            let startX = 0;
            let startScrollLeft = 0;

            const onMoveMouse = (e) => {
                if(!dragging) return;
                const { maxScroll } = __getTimelineTracks();
                if(maxScroll <= 0){
                    __timelineHScroll.busy = true;
                    bar.scrollLeft = 0;
                    const { outers } = __getTimelineTracks();
                    outers.forEach(o => { o.scrollLeft = 0; });
                    __timelineHScroll.busy = false;
                    updateTimelineHScrollThumb();
                    return;
                }
                const rect = bar.getBoundingClientRect();
                const trackW = rect.width || 1;
                const thumbW = thumb.getBoundingClientRect().width || 1;
                const maxThumbX = Math.max(1, trackW - thumbW);
                const dx = e.clientX - startX;
                const ratio = maxScroll / maxThumbX;
                const target = clamp(startScrollLeft + (dx * ratio), 0, maxScroll);

                __timelineHScroll.busy = true;
                bar.scrollLeft = target;
                const { outers } = __getTimelineTracks();
                outers.forEach(o => { o.scrollLeft = target; });
                __timelineHScroll.busy = false;
                updateTimelineHScrollThumb();
            };

            const endMouse = () => {
                dragging = false;
                document.removeEventListener('mousemove', onMoveMouse);
                document.removeEventListener('mouseup', endMouse);
            };

            thumb.addEventListener('mousedown', (e) => {
                e.preventDefault();
                dragging = true;
                startX = e.clientX;
                startScrollLeft = bar.scrollLeft || 0;
                document.addEventListener('mousemove', onMoveMouse);
                document.addEventListener('mouseup', endMouse);
            });

            const onMoveTouch = (e) => {
                if(!dragging) return;
                e.preventDefault();

                const clientX = e.touches[0].clientX;
                const { maxScroll } = __getTimelineTracks();
                if(maxScroll <= 0){
                    __timelineHScroll.busy = true;
                    bar.scrollLeft = 0;
                    const { outers } = __getTimelineTracks();
                    outers.forEach(o => { o.scrollLeft = 0; });
                    __timelineHScroll.busy = false;
                    updateTimelineHScrollThumb();
                    return;
                }
                const rect = bar.getBoundingClientRect();
                const trackW = rect.width || 1;
                const thumbW = thumb.getBoundingClientRect().width || 1;
                const maxThumbX = Math.max(1, trackW - thumbW);
                const dx = clientX - startX;
                const ratio = maxScroll / maxThumbX;
                const target = clamp(startScrollLeft + (dx * ratio), 0, maxScroll);

                __timelineHScroll.busy = true;
                bar.scrollLeft = target;
                const { outers } = __getTimelineTracks();
                outers.forEach(o => { o.scrollLeft = target; });
                __timelineHScroll.busy = false;
                updateTimelineHScrollThumb();
            };

            const endTouch = () => {
                dragging = false;
                document.removeEventListener('touchmove', onMoveTouch);
                document.removeEventListener('touchend', endTouch);
            };

            thumb.addEventListener('touchstart', (e) => {
                dragging = true;
                startX = e.touches[0].clientX;
                startScrollLeft = bar.scrollLeft || 0;
                document.addEventListener('touchmove', onMoveTouch, { passive:false });
                document.addEventListener('touchend', endTouch);
            }, { passive:true });

            bar.addEventListener('mousedown', (e) => {
                if(e.target === thumb) return;
                const { maxScroll } = __getTimelineTracks();
                if(maxScroll <= 0) return;

                const rect = bar.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const thumbW = thumb.getBoundingClientRect().width || 1;
                const trackW = bar.clientWidth || 0;
                const maxThumbX = Math.max(1, trackW - thumbW);
                const thumbX = clamp(clickX - (thumbW / 2), 0, maxThumbX);
                const target = clamp((thumbX / maxThumbX) * maxScroll, 0, maxScroll);

                __timelineHScroll.busy = true;
                bar.scrollLeft = target;
                const { outers } = __getTimelineTracks();
                outers.forEach(o => { o.scrollLeft = target; });
                __timelineHScroll.busy = false;
                updateTimelineHScrollThumb();
            });
        }

        function setupTimelineHScroll(){
            initTimelineHScrollThumbDrag();
            updateTimelineHScroll();
        }
function bumpTimelineZoom(delta) {
            const z = clamp((parseFloat(timelineZoom) || 1) + delta, 0.5, 3);
            setTimelineZoom(parseFloat(z.toFixed(1)));
        }

        function initTimelineZoomControls() {
            try {
                const zr = document.getElementById('timeline-zoom-range');
                const zi = document.getElementById('timeline-zoom-in');
                const zo = document.getElementById('timeline-zoom-out');
                const zreset = document.getElementById('timeline-zoom-reset');

                if (zr && !zr.dataset.bound) {
                    zr.addEventListener('input', (e) => setTimelineZoom(e.target.value));
                    zr.dataset.bound = '1';
                }
                if (zi && !zi.dataset.bound) {
                    zi.addEventListener('click', () => bumpTimelineZoom(0.1));
                    zi.dataset.bound = '1';
                }
                if (zo && !zo.dataset.bound) {
                    zo.addEventListener('click', () => bumpTimelineZoom(-0.1));
                    zo.dataset.bound = '1';
                }
                if (zreset && !zreset.dataset.bound) {
                    zreset.addEventListener('click', () => setTimelineZoom(1));
                    zreset.dataset.bound = '1';
                }

                // Applique le zoom courant (et met à jour l’affichage %)
                applyTimelineZoom();
            } catch (e) {
                // ignore
            }
        }

        function getTimelineContainerForRender(id) {
            const outer = document.getElementById(id);
            if (!outer) return null;
            const inner = outer.querySelector(':scope > .timeline-inner');
            return inner || outer;
        }

function formatTimelineDuration(secs) {
            const mins = Math.round((secs || 0) / 60);
            if (!mins || mins <= 0) return '0m';

            const MINS_PER_HOUR = 60;
            const MINS_PER_DAY = 1440;
            const MINS_PER_WEEK = 10080;     // 7 * 1440
            const MINS_PER_MONTH = 43200;    // 30 * 1440 (convention)

            const fmt = (val) => Number.isInteger(val) ? String(val) : String(parseFloat(val.toFixed(1)));

            if (mins >= MINS_PER_MONTH) {
                const mo = mins / MINS_PER_MONTH;
                return `${fmt(mo)}mo`;
            }
            if (mins >= MINS_PER_WEEK) {
                const w = mins / MINS_PER_WEEK;
                return `${fmt(w)}sem`;
            }
            if (mins >= MINS_PER_DAY) {
                const d = mins / MINS_PER_DAY;
                return `${fmt(d)}j`;
            }
            if (mins >= MINS_PER_HOUR) {
                const h = Math.floor(mins / 60);
                const m = mins % 60;
                return m === 0 ? `${h}h` : `${h}h${m}`;
            }
            return `${mins}m`;
        }

        // --- Export helpers (cohérence / robustesse) ---
        function el(id) { return document.getElementById(id); }
        function val(id) { return el(id)?.value || ''; }
        function txt(id) { return el(id)?.innerText || ''; }
                function fmtTotalDuration(totalSecs, t) {
            const secs = Math.max(0, Number(totalSecs || 0));
            if (!secs) return `0 ${t.unit_mins}`;
            if (secs >= 604800) return `${(secs / 604800).toFixed(1)} ${t.unit_weeks}`;
            if (secs >= 86400) return `${(secs / 86400).toFixed(1)} ${t.unit_days}`;
            if (secs >= 3600) {
                const h = Math.floor(secs / 3600);
                const m = Math.round((secs % 3600) / 60);
                return `${h}h ${m}m`;
            }
            return `${Math.round(secs / 60)} ${t.unit_mins}`;
        }

        function escapeRtf(s) {
            // RTF-safe text with robust Unicode support (accents, non‑ASCII, etc.)
            // - Escapes control characters \, {, }
            // - Normalises newlines to \par
            // - Encodes any non-ASCII character using \uN? (Unicode escape with fallback)
            const str = String(s ?? '');
            let out = '';
            for (let i = 0; i < str.length; i++) {
                let ch = str[i];

                // Handle surrogate pairs (code points > U+FFFF)
                const code = str.codePointAt(i);
                if (code > 0xFFFF) {
                    i++; // advance extra for surrogate pair
                }

                if (ch === '\\' || ch === '{' || ch === '}') {
                    out += '\\' + ch;
                    continue;
                }
                if (ch === '\r') continue;
                if (ch === '\n') { out += '\\par '; continue; }

                if (code <= 0x7F) {
                    // ASCII
                    out += String.fromCharCode(code);
                } else {
                    // RTF \u expects a signed 16-bit integer
                    let signed = code;
                    if (signed > 0x7FFF) signed = signed - 0x10000;
                    out += `\\u${signed}?`;
                }
            }
            return out;
        }

        
        function getDefaultDurationUnitKey() {
            const sel = document.getElementById('param-learning-unit');
            return (sel && sel.value) ? sel.value : 'mins';
        }

        function getDefaultDurationUnitSecs() {
            const key = getDefaultDurationUnitKey();
            return mapUnitToSecs(key);
        }

        function mapUnitToSecs(unit) {
            // Accept seconds values ("60", 60), or parameter keys ("mins", "hours", ...)
            const v = (unit ?? '').toString().trim();
            if (v === '') return 60;
            if (!isNaN(parseFloat(v)) && isFinite(parseFloat(v))) return parseFloat(v);

            if (v === 'mins' || v === 'min' || v === 'minute' || v === 'minutes') return 60;
            if (v === 'hours' || v === 'hour' || v === 'h' || v === 'heures' || v === 'heure') return 3600;
            if (v === 'days' || v === 'day' || v === 'd' || v === 'jours' || v === 'jour') return 86400;
            if (v === 'weeks' || v === 'week' || v === 'w' || v === 'semaines' || v === 'semaine') return 604800;
            // If months was selected in Parameters, default to weeks for per-field units
            if (v === 'months' || v === 'month' || v === 'mois') return 2592000;

            return 60;
        }


        // ---- Preferred unit for Modules / Moments / Activities (seconds-based) ----
        function __ldGetPreferredUnitSecs() {
            try {
                const sel = document.getElementById('param-preferred-unit');
                const v = sel ? parseFloat(sel.value) : NaN;
                if (!isNaN(v) && isFinite(v) && v > 0) return v;
            } catch(_){ __ldSilentErr(_); }
            try {
                const stored = localStorage.getItem('ld_preferred_unit_secs');
                const s = parseFloat(stored);
                if (!isNaN(s) && isFinite(s) && s > 0) return s;
            } catch(_){ __ldSilentErr(_); }
            return 60;
        }

        function __ldSetPreferredUnitSecs(secs) {
            try {
                const sel = document.getElementById('param-preferred-unit');
                if (sel) sel.value = String(secs);
            } catch(_){ __ldSilentErr(_); }
            try { localStorage.setItem('ld_preferred_unit_secs', String(secs)); } catch(_){ __ldSilentErr(_); }
        }

        function __ldConvertValuePreserveSecs(valStr, fromSecs, toSecs) {
            const v = parseFloat(valStr);
            if (isNaN(v)) return '';
            const secs = v * (fromSecs || 60);
            let out = secs / (toSecs || 60);
            if ((toSecs || 60) === 60) out = Math.round(out);
            else out = parseFloat(out.toFixed(2));
            return (typeof __ldTrimNumber === 'function') ? __ldTrimNumber(out) : String(out);
        }

        function __ldApplyPreferredUnit(convertExisting) {
            try {
                const newSecs = __ldGetPreferredUnitSecs();
                // Ensure months exists
                document.querySelectorAll('.activity-target-unit, .moment-target-unit, .duration-unit').forEach(sel => {
                    try { __ldEnsureUnitOption(sel, 2592000, 'unit_months', 'Mois'); } catch(_){ __ldSilentErr(_); }
                });

                // MODULE target units
                document.querySelectorAll('.activity-group').forEach(group => {
                    const unitSel = group.querySelector('.activity-target-unit');
                    const valEl = group.querySelector('.activity-target-time');
                    if (!unitSel) return;
                    const oldSecs = mapUnitToSecs(unitSel.value || 60);
                    if (convertExisting && valEl && valEl.value !== '') {
                        valEl.value = __ldConvertValuePreserveSecs(valEl.value, oldSecs, newSecs);
                    }
                    if (Array.from(unitSel.options || []).some(o => String(o.value) === String(newSecs))) unitSel.value = String(newSecs);
                    // keep editable
                    unitSel.disabled = false;
                    unitSel.classList.remove('ld-locked-unit');
                });

                // MOMENT target units
                document.querySelectorAll('.moment-group').forEach(momentEl => {
                    const unitSel = momentEl.querySelector('.moment-target-unit');
                    const valEl = momentEl.querySelector('.moment-target-time');
                    if (!unitSel) return;
                    const oldSecs = mapUnitToSecs(unitSel.value || 60);
                    if (convertExisting && valEl && valEl.value !== '') {
                        valEl.value = __ldConvertValuePreserveSecs(valEl.value, oldSecs, newSecs);
                    }
                    if (Array.from(unitSel.options || []).some(o => String(o.value) === String(newSecs))) unitSel.value = String(newSecs);
                    unitSel.disabled = false;
                    unitSel.classList.remove('ld-locked-unit');
                });

                // STEP duration units
                __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stepEl => {
                    const unitSel = stepEl.querySelector('.duration-unit');
                    const valEl = stepEl.querySelector('.duration-input');
                    if (!unitSel) return;
                    const oldSecs = mapUnitToSecs(unitSel.value || 60);
                    if (convertExisting && valEl && valEl.value !== '') {
                        valEl.value = __ldConvertValuePreserveSecs(valEl.value, oldSecs, newSecs);
                    }
                    if (Array.from(unitSel.options || []).some(o => String(o.value) === String(newSecs))) unitSel.value = String(newSecs);
                    unitSel.disabled = false;
                    unitSel.classList.remove('ld-locked-unit');
                });

                try { updateStats(); } catch(_){ __ldSilentErr(_); }
            } catch(_){ __ldSilentErr(_); }
        }

        // Backward compatibility: disable previous locking helper if present
        function __ldLockUnitSelect(_) { /* no-op (units must remain editable) */ }
        function __ldApplyGlobalDurationUnit(_) { /* deprecated (replaced by preferred unit) */ }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                const sel = document.getElementById('param-preferred-unit');
                if (!sel) return;

                // Restore preference
                try {
                    const stored = localStorage.getItem('ld_preferred_unit_secs');
                    if (stored && !isNaN(parseFloat(stored))) sel.value = String(parseFloat(stored));
                } catch(_){ __ldSilentErr(_); }

                // Apply to any initial content (mostly zero values) without harm
                __ldApplyPreferredUnit(true);

                sel.addEventListener('change', () => {
                    // Apply and convert existing values to preserve durations
                    __ldSetPreferredUnitSecs(parseFloat(sel.value) || 60);
                    __ldApplyPreferredUnit(true);
                    try { if (typeof __ldApplyUnitLabelFormat === 'function') __ldApplyUnitLabelFormat(); } catch(_){ __ldSilentErr(_); }
                });
            } catch(_){ __ldSilentErr(_); }
        });




        // ---- Global duration display unit (modules / moments / activities) ----
        function __ldTrimNumber(n) {
            const s = (typeof n === 'number') ? n.toString() : String(n ?? '');
            return s.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
        }
        function __ldConvertValuePreserveSecs(valStr, fromSecs, toSecs) {
            const v = parseFloat(valStr);
            if (isNaN(v)) return '';
            const secs = v * (fromSecs || 60);
            let out = secs / (toSecs || 60);
            if ((toSecs || 60) === 60) out = Math.round(out);
            else out = parseFloat(out.toFixed(2));
            return __ldTrimNumber(out);
        }
        function __ldEnsureUnitOption(selectEl, secsValue, i18nKey, fallbackText) {
            try {
                const v = String(secsValue);
                const exists = Array.from(selectEl.options || []).some(o => String(o.value) === v);
                if (exists) return;
                const opt = document.createElement('option');
                opt.value = v;
                if (i18nKey) opt.setAttribute('data-i18n', i18nKey);
                opt.textContent = (translations && translations[currentLang] && i18nKey && translations[currentLang][i18nKey]) ? translations[currentLang][i18nKey] : (fallbackText || v);
                selectEl.appendChild(opt);
            } catch(_){ __ldSilentErr(_); }
        }
        function __ldLockUnitSelect(selectEl) {
            try {
                if (!selectEl) return;
                selectEl.disabled = true;
                selectEl.classList.add('ld-locked-unit');
                selectEl.title = "Unité globale (modifiable dans les paramètres initiaux)";
            } catch(_){ __ldSilentErr(_); }
        }
        function __ldApplyGlobalDurationUnit(convertInputs) {
            try {
                const globalKeySel = document.getElementById('param-learning-unit');
                if (!globalKeySel) return;

                const globalKey = globalKeySel.value || 'mins';
                const newSecs = mapUnitToSecs(globalKey);

                // Persist preference (local only)
                try { localStorage.setItem('ld_global_unit_key', globalKey); } catch(_){ __ldSilentErr(_); }

                // Ensure months option exists where needed
                document.querySelectorAll('.activity-target-unit, .moment-target-unit, .duration-unit').forEach(sel => {
                    if (!sel) return;
                    __ldEnsureUnitOption(sel, 2592000, 'unit_months', 'Mois');
                });

                // Update MODULE target unit + (optional) convert target value
                document.querySelectorAll('.activity-group').forEach(group => {
                    const unitSel = group.querySelector('.activity-target-unit');
                    const valEl = group.querySelector('.activity-target-time');
                    if (!unitSel) return;
                    const oldSecs = mapUnitToSecs(unitSel.value || 60);
                    if (convertInputs && valEl && valEl.value !== '') {
                        valEl.value = __ldConvertValuePreserveSecs(valEl.value, oldSecs, newSecs);
                    }
                    // set unit
                    const targetVal = String(newSecs);
                    if (Array.from(unitSel.options).some(o => String(o.value) === targetVal)) unitSel.value = targetVal;
                    __ldLockUnitSelect(unitSel);
                });

                // Update MOMENT target unit + (optional) convert target value
                document.querySelectorAll('.moment-group').forEach(momentEl => {
                    const unitSel = momentEl.querySelector('.moment-target-unit');
                    const valEl = momentEl.querySelector('.moment-target-time');
                    if (!unitSel) return;
                    const oldSecs = mapUnitToSecs(unitSel.value || 60);
                    if (convertInputs && valEl && valEl.value !== '') {
                        valEl.value = __ldConvertValuePreserveSecs(valEl.value, oldSecs, newSecs);
                    }
                    const targetVal = String(newSecs);
                    if (Array.from(unitSel.options).some(o => String(o.value) === targetVal)) unitSel.value = targetVal;
                    // BUGFIX: Do NOT lock moment target units - users should be able to change them
                    // __ldLockUnitSelect(unitSel); // REMOVED
                });

                // Update STEP (activity) duration units + (optional) convert values
                __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stepEl => {
                    const unitSel = stepEl.querySelector('.duration-unit');
                    const valEl = stepEl.querySelector('.duration-input');
                    if (!unitSel) return;
                    const oldSecs = mapUnitToSecs(unitSel.value || 60);
                    if (convertInputs && valEl && valEl.value !== '') {
                        valEl.value = __ldConvertValuePreserveSecs(valEl.value, oldSecs, newSecs);
                    }
                    const targetVal = String(newSecs);
                    if (Array.from(unitSel.options).some(o => String(o.value) === targetVal)) unitSel.value = targetVal;
                    __ldLockUnitSelect(unitSel);
                });

                // Update derived displays
                try { updateStats(); } catch(_){ __ldSilentErr(_); }
            } catch(_){ __ldSilentErr(_); }
        }

        // Initialise global unit preference from localStorage (only if no project has set it yet)
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const sel = document.getElementById('param-learning-unit');
                if (!sel) return;

                // store previous key for conversion when user changes the global unit
                sel.dataset.prevUnitKey = sel.value || 'mins';

                // Restore preference (local) for fresh sessions
                try {
                    const stored = localStorage.getItem('ld_global_unit_key');
                    if (stored && stored !== sel.value) {
                        // only apply if it's a recognised key
                        if (['mins','hours','days','weeks','months'].includes(stored)) {
                            sel.value = stored;
                        }
                    }
                } catch(_){ __ldSilentErr(_); }

                // Apply without conversion on initial load (no values yet)
                __ldApplyGlobalDurationUnit(false);

                sel.addEventListener('change', () => {
                    const oldKey = sel.dataset.prevUnitKey || 'mins';
                    const newKey = sel.value || 'mins';
                    const oldSecs = mapUnitToSecs(oldKey);
                    const newSecs = mapUnitToSecs(newKey);

                    // Convert GLOBAL learning target value to preserve seconds
                    try {
                        const vEl = document.getElementById('param-learning-val');
                        if (vEl && vEl.value !== '') {
                            vEl.value = __ldConvertValuePreserveSecs(vEl.value, oldSecs, newSecs);
                        }
                    } catch(_){ __ldSilentErr(_); }

                    // Convert all module/moment/step values and lock to the new unit
                    __ldApplyGlobalDurationUnit(true);

                    sel.dataset.prevUnitKey = newKey;
                });
            } catch(_){ __ldSilentErr(_); }
        });

        // ---- Unit label format (short/long) for time units ----
        function __ldGetUnitLabelByKey(unitKey, format) {
            const f = (format || 'short').toString();
            const k = (unitKey || 'mins').toString();
            const shortMap = { mins: 'min', hours: 'h', days: 'j', weeks: 'sem', months: 'mois' };
            const longMap  = { mins: 'minutes', hours: 'heures', days: 'jours', weeks: 'semaines', months: 'mois' };
            return (f === 'long' ? (longMap[k] || longMap.mins) : (shortMap[k] || shortMap.mins));
        }
        function __ldGetUnitLabelBySecs(unitSecs, format) {
            const s = parseFloat(unitSecs) || 60;
            if (s === 60) return __ldGetUnitLabelByKey('mins', format);
            if (s === 3600) return __ldGetUnitLabelByKey('hours', format);
            if (s === 86400) return __ldGetUnitLabelByKey('days', format);
            if (s === 604800) return __ldGetUnitLabelByKey('weeks', format);
            if (s === 2592000) return __ldGetUnitLabelByKey('months', format);
            return __ldGetUnitLabelByKey('mins', format);
        }
        function __ldApplyUnitLabelFormat() {
            try {
                const fmtSel = document.getElementById('param-unit-label-format');
                const fmt = (fmtSel && fmtSel.value) ? fmtSel.value : 'short';

                // Persist preference (local only)
                try { localStorage.setItem('ld_unit_label_format', fmt); } catch(_){ __ldSilentErr(_); }

                // Update global unit selector (key-based)
                const globalSel = document.getElementById('param-learning-unit');
                if (globalSel) {
                    Array.from(globalSel.options || []).forEach(opt => {
                        const k = opt.value;
                        opt.textContent = __ldGetUnitLabelByKey(k, fmt);
                    });
                }

                // Keep hidden "designed time unit" selector aligned (used by exports/imports)
                const designedSel = document.getElementById('param-designed-unit');
                if (designedSel) {
                    try {
                        Array.from(designedSel.options || []).forEach(opt => {
                            const k = opt.value;
                            opt.textContent = __ldGetUnitLabelByKey(k, fmt);
                        });
                        if (globalSel && globalSel.value) designedSel.value = globalSel.value;
                    } catch(_){ __ldSilentErr(_); }
                }

                // Update all seconds-based unit selects
                document.querySelectorAll('.activity-target-unit, .moment-target-unit, .duration-unit').forEach(sel => {
                    if (!sel) return;
                    Array.from(sel.options || []).forEach(opt => {
                        const secs = parseFloat(opt.value);
                        if (!isNaN(secs)) opt.textContent = __ldGetUnitLabelBySecs(secs, fmt);
                    });
                });

                // Update any static unit display spans if present
                const designedSpan = document.getElementById('param-designed-unit-display');
                if (designedSpan) {
                    const key = (globalSel && globalSel.value) ? globalSel.value : 'mins';
                    designedSpan.textContent = __ldGetUnitLabelByKey(key, fmt);
                }

                // Refresh derived displays with the new label format
                try { updateStats(); } catch(_){ __ldSilentErr(_); }
            } catch(_){ __ldSilentErr(_); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                const fmtSel = document.getElementById('param-unit-label-format');
                if (!fmtSel) return;

                // Restore preference
                try {
                    const stored = localStorage.getItem('ld_unit_label_format');
                    if (stored && (stored === 'short' || stored === 'long')) fmtSel.value = stored;
                } catch(_){ __ldSilentErr(_); }

                __ldApplyUnitLabelFormat();
                fmtSel.addEventListener('change', () => { __ldApplyUnitLabelFormat(); });
            } catch(_){ __ldSilentErr(_); }
        });

// Debounced wrapper for heavy timeline/canvas recomputation (used by input events)
// Micro-optimisation: adapt debounce delay to the type of field being edited to avoid rebuilding heavy timelines while typing titles/long text.
let __updateStatsDebounceTimer = null;
let __lastUpdateStatsTriggerKind = 'default'; // 'timing' | 'title' | 'default'

function __classifyUpdateStatsTriggerTarget(el) {
  if (!el) return 'default';
  const t = (el.tagName || '').toLowerCase();
  const cls = (el.classList || { contains: () => false });

  // Timing / duration drivers (need quick feedback)
  if (cls.contains('duration-input') || cls.contains('activity-target-time') || cls.contains('moment-target-time')) return 'timing';
  if (el.id === 'param-learning-val' || el.id === 'global-class-size') return 'timing';

  // Title edits do not affect totals materially but currently trigger updateStats; delay more to reduce needless rebuilds
  if (cls.contains('activity-title')) return 'title';

  // Default
  if (t === 'select' || t === 'input') return 'default';
  return 'default';
}

// Track last user edit kind (capture phase to run before inline handlers)
document.addEventListener('input', (e) => {
  try { __lastUpdateStatsTriggerKind = __classifyUpdateStatsTriggerTarget(e.target); } catch(_){ __ldSilentErr(_); }
}, true);

function updateStatsDebounced() {
  if (__updateStatsDebounceTimer) clearTimeout(__updateStatsDebounceTimer);

  // Adaptive delays: keep duration feedback responsive, but avoid heavy recomputation while typing titles.
  const kind = __lastUpdateStatsTriggerKind || 'default';
  const delay = (kind === 'timing') ? 200 : (kind === 'title') ? 800 : 300;

  __updateStatsDebounceTimer = setTimeout(() => {
    __updateStatsDebounceTimer = null;
    updateStats();
    try { __ldApplyStatusFilterDebounced(); } catch(_){ __ldSilentErr(_); }
    try { updateAllStepHeaderChips(); } catch(_){ __ldSilentErr(_); }
    }, delay);
}


function formatAdaptiveDurationFromSecs(totalSecs) {
            const mins = totalSecs / 60;
            if (!isFinite(mins) || mins <= 0) return { value: 0, unit: translations[currentLang].unit_mins };
            if (mins < 60) return { value: Math.round(mins), unit: translations[currentLang].unit_mins };
            const hours = mins / 60;
            if (hours < 24) return { value: parseFloat(hours.toFixed(1)), unit: translations[currentLang].unit_hours };
            const days = hours / 24;
            if (days < 7) return { value: parseFloat(days.toFixed(1)), unit: translations[currentLang].unit_days };
            const weeks = days / 7;
            if (weeks < 4) return { value: parseFloat(weeks.toFixed(1)), unit: translations[currentLang].unit_weeks };
            const months = days / 30;
            return { value: parseFloat(months.toFixed(1)), unit: translations[currentLang].unit_months };
        }


function updateStats() {
            const totals = getTotals();
            // Sync user-defined duration tolerance (% only)
            try {
                const relEl = document.getElementById('param-duration-tol-rel');
                const relVal = relEl ? parseFloat(relEl.value) : NaN;
                durationComparisonSettings.absoluteTolerance = 0;
                if (Number.isFinite(relVal) && relVal >= 0) durationComparisonSettings.relativeTolerance = relVal / 100;
            } catch(_){ __ldSilentErr(_); }
            try { __ldUpdateAllStatusSummariesDebounced(); } catch(_){ __ldSilentErr(_); }
            try { __ldApplyStatusFilterDebounced(); } catch(_){ __ldSilentErr(_); }
            let display = `0 ${translations[currentLang].unit_mins}`;
            if (totals.totalSecs >= 604800) display = `${(totals.totalSecs / 604800).toFixed(1)} ${translations[currentLang].unit_weeks}`;
            else if (totals.totalSecs >= 86400) display = `${(totals.totalSecs / 86400).toFixed(1)} ${translations[currentLang].unit_days}`;
            else if (totals.totalSecs >= 3600) {
                const h = Math.floor(totals.totalSecs / 3600);
                const m = Math.round((totals.totalSecs % 3600) / 60);
                display = `${h}h ${m}m`;
            } else if (totals.totalSecs > 0) display = `${Math.round(totals.totalSecs / 60)} ${translations[currentLang].unit_mins}`;
            
            const totalDurationEl = document.getElementById('total-duration');
            if (totalDurationEl) totalDurationEl.innerText = display;

            // Updated logic for synced time units
            const learningUnitSelect = document.getElementById('param-learning-unit');
            const learningUnit = learningUnitSelect ? learningUnitSelect.value : 'mins';
            let learningUnitText = '';
            try {
                if (learningUnitSelect && learningUnitSelect.options && learningUnitSelect.options.length) {
                    const idx = (learningUnitSelect.selectedIndex != null && learningUnitSelect.selectedIndex >= 0)
                        ? learningUnitSelect.selectedIndex : 0;
                    const opt = learningUnitSelect.options[idx];
                    learningUnitText = opt ? (opt.text || opt.textContent || '') : '';
                }
            } catch (_) { learningUnitText = ''; }
            
            // Sync UI text display
            try {
                const disp = document.getElementById('param-designed-unit-display');
                if (disp) disp.innerText = learningUnitText || '';
            } catch(_){ __ldSilentErr(_); }
            
            const headerDesignedUnitEl = document.getElementById('header-designed-unit');
            if (headerDesignedUnitEl) headerDesignedUnitEl.innerText = learningUnitText;
            const unitLabelFmt = (document.getElementById('param-unit-label-format')?.value || 'short');
            
            // Update Header Target Time
            const targetVal = (document.getElementById('param-learning-val')?.value) || 0;
            const headerTargetTimeEl = document.getElementById('header-target-time');
            if (headerTargetTimeEl) headerTargetTimeEl.innerText = `${targetVal} ${learningUnitText}`;

            const designedInput = document.getElementById('param-designed-val');
            let divisor = 60;
            if (learningUnit === 'hours') divisor = 3600;
            if (learningUnit === 'days') divisor = 86400;
            if (learningUnit === 'weeks') divisor = 604800;
            if (learningUnit === 'months') divisor = 2592000; // 30 days
            
            let designedVal = totals.totalSecs / divisor;
            if (learningUnit === 'mins') designedVal = Math.round(designedVal);
            else designedVal = parseFloat(designedVal.toFixed(1)); 
            
            designedInput.value = designedVal;
            // Keep backward-compatible hidden fields in sync for exports/imports
            const designedTimeHidden = document.getElementById('param-designed-time');
            if (designedTimeHidden) designedTimeHidden.value = String(designedVal);
            const designedUnitHidden = document.getElementById('param-designed-unit');
            if (designedUnitHidden) designedUnitHidden.value = learningUnit;
            const headerDesignedValEl = document.getElementById('header-designed-val');
            const headerDesignedUnitEl2 = document.getElementById('header-designed-unit');
            if (headerDesignedValEl) headerDesignedValEl.innerText = String(designedVal);
            if (headerDesignedUnitEl2) headerDesignedUnitEl2.innerText = learningUnitText;
            // Update designed time per moment (sum of contained activities), expressed in the moment unit
            document.querySelectorAll('.moment-group').forEach(momentEl => {
                let secs = 0;
                __ldQueryDesignedStepCards(momentEl).forEach(stepEl => { secs += getStepDurationSecs(stepEl); });

                try { momentEl.dataset.designedSecs = String(secs); } catch(_){ __ldSilentErr(_); }
const unitSel = momentEl.querySelector('.moment-target-unit');
                const unitSecs = mapUnitToSecs(unitSel?.value || getDefaultDurationUnitSecs());
                const unitText = __ldGetUnitLabelBySecs(unitSecs, unitLabelFmt);

                // BUGFIX: Do NOT auto-compute moment target - user should manually enter it
                // The target duration is a GOAL set by the user, not a sum of activities
                // Previously, this code was overwriting the user's input every time updateStats() was called
                // REMOVED: Auto-compute moment target from contained activities (steps)

                const label = momentEl.querySelector('.moment-total-time');
                if (label) {
                    let v = secs / unitSecs;
                    // minutes: integer; others: 1 decimal
                    if (unitSecs === 60) v = Math.round(v);
                    else v = parseFloat(v.toFixed(1));
                    label.innerText = `${v} ${unitText}`;
                }

                // Submoment designed duration from contained activities (steps)
                try {
                    const subEls = momentEl.querySelectorAll('.submoments-container .submoment-card');
                    subEls.forEach(smEl => {
                        let smSecs = 0;
                        __ldQueryDesignedStepCards(smEl).forEach(stepEl => { smSecs += getStepDurationSecs(stepEl); });
                        try { smEl.dataset.designedSecs = String(smSecs); } catch(_){ __ldSilentErr(_); }

                        const smUnitSel = smEl.querySelector('.submoment-target-unit');
                        const smUnitSecs = mapUnitToSecs(smUnitSel?.value || unitSecs || getDefaultDurationUnitSecs());
                        const smUnitText = __ldGetUnitLabelBySecs(smUnitSecs, unitLabelFmt);

                        let v = smSecs / smUnitSecs;
                        if (smUnitSecs === 60) v = Math.round(v);
                        else v = parseFloat(v.toFixed(1));

                        const designedEl = smEl.querySelector('.submoment-total-time');
                        if (designedEl) designedEl.innerText = `${v} ${smUnitText}`;

                        const targetValEl = smEl.querySelector('.submoment-target-time');
                        const designedBadge = smEl.querySelector('.submoment-designed-badge');
                        const compareEl = smEl.querySelector('.submoment-time-compare');

                        if (designedBadge) designedBadge.classList.remove('duration-alert-light');
                        const tv = targetValEl ? parseFloat(targetValEl.value) : 0;
                        const targetSecs = (isNaN(tv) ? 0 : tv) * (isNaN(smUnitSecs) ? 60 : smUnitSecs);
                        
                        try { __ldUpdateDeltaBar(designedBadge, targetSecs, smSecs); } catch(_){ __ldSilentErr(_); }
if (targetSecs > 0) {
                            const cmp = (typeof compareDurations === 'function')
                                ? compareDurations(smSecs, targetSecs)
                                : { isMatch: Math.round(smSecs) === Math.round(targetSecs), deviation: smSecs - targetSecs };
                            if (!cmp.isMatch && designedBadge) designedBadge.classList.add('duration-alert-light');
                            if (compareEl) {
                                const sym = cmp.isMatch ? '=' : (cmp.deviation > 0 ? '<' : '>');
                                compareEl.textContent = sym;
                                compareEl.classList.toggle('text-red-600', !cmp.isMatch);
                            }
                        } else if (compareEl) {
                            compareEl.textContent = '=';
                            compareEl.classList.remove('text-red-600');
                        }
                    });
                } catch(_){ __ldSilentErr(_); }
                // Moment designed duration alert + comparison (target vs designed)
                try {
                    const targetVal = momentEl.querySelector('.moment-target-time');
                    const designedBadge = momentEl.querySelector('.moment-designed-badge');
                    const compareEl = momentEl.querySelector('.moment-time-compare');

                    if (designedBadge) designedBadge.classList.remove('duration-alert-light');

                    const tv = targetVal ? parseFloat(targetVal.value) : 0;
                    const targetSecs = (isNaN(tv) ? 0 : tv) * (isNaN(unitSecs) ? 60 : unitSecs);

                    
                    try { __ldUpdateDeltaBar(designedBadge, targetSecs, secs); } catch(_){ __ldSilentErr(_); }
if (targetSecs > 0) {
                        const cmp = (typeof compareDurations === 'function')
                            ? compareDurations(secs, targetSecs)
                            : { isMatch: Math.round(secs) === Math.round(targetSecs), deviation: secs - targetSecs };
                        if (!cmp.isMatch && designedBadge) designedBadge.classList.add('duration-alert-light');

                        if (compareEl) {
                            // Comparison symbol is rendered between Target (left) and Designed (right)
                            // so direction must reflect target vs designed, not designed vs target.
                            const sym = cmp.isMatch ? '=' : (cmp.deviation > 0 ? '<' : '>');
                            compareEl.textContent = sym;
                            compareEl.classList.toggle('text-red-600', !cmp.isMatch);
                        }
                    } else if (compareEl) {
                        compareEl.textContent = '=';
                        compareEl.classList.remove('text-red-600');
                    }
                } catch(_){ __ldSilentErr(_); }

            });

            // DOM Elements for the two timelines
            const containerActivitiesPlanned = getTimelineContainerForRender('timeline-activities-planned');
            const labelsActivitiesPlanned = getTimelineContainerForRender('timeline-activities-planned-labels');
            const containerActivities = getTimelineContainerForRender('timeline-activities');
            const labelsActivities = getTimelineContainerForRender('timeline-activities-labels');
            const containerMoments = getTimelineContainerForRender('timeline-moments');
            const labelsMoments = getTimelineContainerForRender('timeline-moments-labels');
            const containerSubmoments = getTimelineContainerForRender('timeline-submoments');
            const labelsSubmoments = getTimelineContainerForRender('timeline-submoments-labels');

            const containerSteps = getTimelineContainerForRender('timeline-steps');
            const containerGrouping = getTimelineContainerForRender('timeline-grouping');
            const containerTrainer = getTimelineContainerForRender('timeline-trainer');
            const containerPlace = getTimelineContainerForRender('timeline-place');
            const containerTime = getTimelineContainerForRender('timeline-time');
            const containerRuler = getTimelineContainerForRender('timeline-ruler');
            
            // Clear all
            if (containerActivitiesPlanned) containerActivitiesPlanned.innerHTML = '';
            if (labelsActivitiesPlanned) labelsActivitiesPlanned.innerHTML = '';
            containerActivities.innerHTML = '';
            labelsActivities.innerHTML = '';
            if (containerMoments) containerMoments.innerHTML = '';
            if (labelsMoments) labelsMoments.innerHTML = '';
            if (containerSubmoments) containerSubmoments.innerHTML = '';
            if (labelsSubmoments) labelsSubmoments.innerHTML = '';

            containerSteps.innerHTML = '';
            containerGrouping.innerHTML = '';
            containerTrainer.innerHTML = '';
            containerPlace.innerHTML = '';
            containerTime.innerHTML = '';
            if (containerRuler) containerRuler.innerHTML = "";

            // Compute planned structure (target durations) per module
            const activityGroups = document.querySelectorAll('.activity-group');
            const plannedTimeline = [];
            let plannedTotalSecs = 0;

            activityGroups.forEach((act, idx) => {
                const title = act.querySelector('.activity-title')?.value || `${translations[currentLang].md_untitled_activity} ${idx + 1}`;
                const targetValRaw = parseFloat(act.querySelector('.activity-target-time')?.value);
                const targetVal = Math.max(0, isNaN(targetValRaw) ? 0 : targetValRaw);
                const targetUnitSecs = parseFloat(act.querySelector('.activity-target-unit')?.value) || 60;
                const targetSecs = targetVal * targetUnitSecs;

                const designedSecs = (totals.detailedTimeline[idx] && totals.detailedTimeline[idx].duration) ? totals.detailedTimeline[idx].duration : 0;

                // If target not set, fall back to designed duration so the planned track remains interpretable.
                const secs = targetSecs > 0 ? targetSecs : designedSecs;
                const isEstimated = targetSecs <= 0 && designedSecs > 0;

                plannedTimeline.push({ title, secs, targetSecs, isEstimated });
                plannedTotalSecs += secs;
            });

            const baseTotalSecs = Math.max(totals.totalSecs, plannedTotalSecs);

            if (baseTotalSecs > 0) {
                
                // --- TRACK 0: PLANNED STRUCTURE (TARGET DURATIONS) ---
                if (containerActivitiesPlanned && labelsActivitiesPlanned) {
                    plannedTimeline.forEach((activity, index) => {
                        if (activity.secs > 0) {
                            const actWidthPct = (activity.secs / baseTotalSecs) * 100;
                            const actEl = document.createElement('div');

                            const bgClass = index % 2 === 0 ? 'bg-slate-200' : 'bg-slate-300';
                            const patternClass = activity.isEstimated ? 'pattern-dots' : 'pattern-grid-dark';

                            actEl.className = `h-full border-r border-white last:border-0 relative group box-border ${bgClass} ${patternClass} hover:bg-slate-400 transition-colors flex items-center justify-center cursor-pointer`;
                            actEl.style.width = `${actWidthPct}%`;

                            const durationMins = Math.round(activity.secs / 60);

                            let tooltipText;
                            if (activity.targetSecs > 0) {
                                tooltipText = `<strong>${escapeHtml(activity.title)}</strong>`;
                            } else if (activity.isEstimated) {
                                tooltipText = `<strong>${escapeHtml(activity.title)}</strong>`;
                            } else {
                                tooltipText = `<strong>${escapeHtml(activity.title)}</strong>`;
                            }

                            actEl.onmouseenter = (e) => showTooltip(e, tooltipText, true);
                            actEl.onmousemove = (e) => updateTooltipPos(e);
                            actEl.onmouseleave = () => hideTooltip();
                        actEl.onclick = () => scrollToEditor(index);

                            let durationStr = `${durationMins}m`;
                            if (durationMins >= 60) {
                                const h = Math.floor(durationMins / 60);
                                const m = durationMins % 60;
                                durationStr = m === 0 ? `${h}h` : `${h}h${m}`;
                            }

                            const innerLabel = document.createElement('div');
                            innerLabel.className = 'timeline-duration-label text-[10px] font-bold text-slate-700 pointer-events-none select-none truncate px-1 opacity-90 group-hover:opacity-100 transition-opacity';
                            innerLabel.innerText = formatTimelineDuration(activity.secs);
                            if (actWidthPct > 4) {
                                actEl.appendChild(innerLabel);
                            }

                            containerActivitiesPlanned.appendChild(actEl);

                            const labelEl = document.createElement('div');
                            labelEl.style.width = `${actWidthPct}%`;
                            labelEl.className = 'px-1 truncate text-center border-r border-transparent last:border-0';

                            if (actWidthPct > 5) {
                                labelEl.innerText = activity.title;
                                labelEl.title = activity.title;
                            } else {
                                labelEl.innerText = '.';
                                labelEl.classList.add('text-transparent');
                            }
                            labelsActivitiesPlanned.appendChild(labelEl);
                        }
                    });
                }

                // --- TRACK 1: ACTIVITIES / MODULES (ALIGNED TO PLANNED) ---
                if (containerActivities && labelsActivities) {
                    plannedTimeline.forEach((planned, index) => {
                        const plannedSecs = planned && planned.secs ? planned.secs : 0;
                        const designedSecs = (totals.detailedTimeline[index] && totals.detailedTimeline[index].duration) ? totals.detailedTimeline[index].duration : 0;

                        if (plannedSecs <= 0 && designedSecs <= 0) return;

                        // Width is based on planned segment to ensure alignment with Track 0
                        const segmentSecsForWidth = plannedSecs > 0 ? plannedSecs : designedSecs;
                        const actWidthPct = (segmentSecsForWidth / baseTotalSecs) * 100;

                        // Fill ratio (designed within planned)
                        const ratio = plannedSecs > 0 ? Math.min(1, Math.max(0, designedSecs / plannedSecs)) : 1;

                        const actEl = document.createElement('div');

                        // Alternating colours (Slate) for the designed fill only
                        const bgClass = index % 2 === 0 ? 'bg-slate-400' : 'bg-slate-500';

                        actEl.className = 'h-full border-r border-white last:border-0 relative group box-border flex items-center justify-center cursor-pointer';
                        actEl.style.width = `${actWidthPct}%`;

                        const cmp = (typeof compareDurations === 'function')
                            ? compareDurations(designedSecs, plannedSecs)
                            : { isMatch: designedSecs === plannedSecs, isUnder: designedSecs < plannedSecs, isOver: designedSecs > plannedSecs };

                        // Missing part (only when a target is set and designed < planned)
                        const missingEl = document.createElement('div');
                        missingEl.className = 'absolute inset-0 timeline-missing-light';
                        if (!(plannedSecs > 0 && cmp.isUnder)) {
                            missingEl.style.display = 'none';
                        }

                        // Designed fill aligned to the left
                        const fillEl = document.createElement('div');
                        fillEl.className = `absolute left-0 top-0 bottom-0 ${bgClass} hover:bg-indigo-500 transition-colors`;
                        fillEl.style.width = `${ratio * 100}%`;

                        // Overrun alert (designed > planned)
                        const overEl = document.createElement('div');
                        overEl.className = 'absolute inset-0 timeline-alert-light pointer-events-none';
                        if (!(plannedSecs > 0 && cmp.isOver)) {
                            overEl.style.display = 'none';
                        }

const tooltipText = `<strong>${escapeHtml(planned.title)}</strong>`;
                        actEl.onmouseenter = (e) => showTooltip(e, tooltipText, true);
                        actEl.onmousemove = (e) => updateTooltipPos(e);
                        actEl.onmouseleave = () => hideTooltip();
                        actEl.onclick = () => scrollToEditor(index);

                        const innerLabel = document.createElement('div');
                        innerLabel.className = 'timeline-duration-label text-[10px] font-bold text-white pointer-events-none select-none truncate px-1 opacity-90 group-hover:opacity-100 transition-opacity relative z-10';
                        innerLabel.innerText = formatTimelineDuration(designedSecs);

                        actEl.appendChild(missingEl);
                        actEl.appendChild(fillEl);
                        actEl.appendChild(overEl);

                        if (actWidthPct > 4) {
                            actEl.appendChild(innerLabel);
                        }

                        containerActivities.appendChild(actEl);

                        const labelEl = document.createElement('div');
                        labelEl.style.width = `${actWidthPct}%`;
                        labelEl.className = 'px-1 truncate text-center border-r border-transparent last:border-0';

                        if (actWidthPct > 5) {
                            labelEl.innerText = planned.title;
                            labelEl.title = planned.title;
                        } else {
                            labelEl.innerText = '.';
                            labelEl.classList.add('text-transparent');
                        }
                        labelsActivities.appendChild(labelEl);
                    });
                }


                // --- TRACK 1.5: MOMENTS (ALIGNED TO PLANNED) ---
                if (containerMoments && labelsMoments) {
                    const t = translations[currentLang] || translations.fr;
                    const moduleEls = Array.from(activityGroups || document.querySelectorAll('.activity-group'));

                    plannedTimeline.forEach((planned, index) => {
                        const plannedSecs = planned && planned.secs ? planned.secs : 0;
                        const designedSecs = (totals.detailedTimeline[index] && totals.detailedTimeline[index].duration) ? totals.detailedTimeline[index].duration : 0;

                        if (plannedSecs <= 0 && designedSecs <= 0) return;

                        const segmentSecsForWidth = plannedSecs > 0 ? plannedSecs : designedSecs;
                        const actWidthPct = baseTotalSecs > 0 ? (segmentSecsForWidth / baseTotalSecs) * 100 : 0;
                        const ratio = plannedSecs > 0 ? clamp(designedSecs / plannedSecs, 0, 1) : 1;

                        const wrap = document.createElement('div');
                        wrap.className = 'relative h-full flex overflow-hidden border-r border-slate-200/70 last:border-0';
                        wrap.style.width = `${actWidthPct}%`;

                        const cmp = (typeof compareDurations === 'function')
                            ? compareDurations(designedSecs, plannedSecs)
                            : { isMatch: designedSecs === plannedSecs, isUnder: designedSecs < plannedSecs, isOver: designedSecs > plannedSecs };

                        const missingEl = document.createElement('div');
                        missingEl.className = 'absolute inset-0 bg-slate-200/30 timeline-missing-light pointer-events-none';
                        if (!(plannedSecs > 0 && cmp.isUnder)) missingEl.style.display = 'none';

                        const overEl = document.createElement('div');
                        overEl.className = 'absolute inset-0 bg-red-200/35 timeline-alert-light pointer-events-none';
                        if (!(plannedSecs > 0 && cmp.isOver)) overEl.style.display = 'none';

                        const fill = document.createElement('div');
                        fill.className = 'absolute left-0 top-0 bottom-0 flex';
                        fill.style.width = `${ratio * 100}%`;

                        const actEl = moduleEls[index] || null;

                        let segments = [];
                        if (actEl) {
                            const momentEls = Array.from(actEl.querySelectorAll(':scope .activity-moments-container > .moment-group'));

                            momentEls.forEach((momEl, mi) => {
                                let secs = 0;
                                __ldQueryDesignedStepCards(momEl).forEach(stepEl => { secs += getStepDurationSecs(stepEl); });
                                if (secs <= 0) return;

                                const title = (momEl.querySelector('.moment-title')?.value || '').trim() || `Moment ${mi + 1}`;
                                segments.push({ title, secs, el: momEl, isGap: false });
                            });

                            // Handle steps not contained in any moment (rare, but keeps the track consistent)
                            const inMomSecs = segments.reduce((acc, s) => acc + (s.secs || 0), 0);
                            const gap = designedSecs - inMomSecs;
                            if (gap > 1) {
                                segments.push({ title: (t.label_out_of_moments || 'Hors moments'), secs: gap, el: actEl, isGap: true });
                            }

                            if (!segments.length && designedSecs > 0) {
                                segments.push({ title: (t.label_out_of_moments || 'Hors moments'), secs: designedSecs, el: actEl, isGap: true });
                            }
                        } else if (designedSecs > 0) {
                            segments = [{ title: (t.label_out_of_moments || 'Hors moments'), secs: designedSecs, el: null, isGap: true }];
                        }

                        if (designedSecs > 0) {
                            segments.forEach((seg, si) => {
                                const w = (seg.secs / designedSecs) * 100;
                                if (w <= 0) return;

                                const block = document.createElement('div');
                                const bg = seg.isGap ? 'bg-slate-300 pattern-dots' : (si % 2 === 0 ? 'bg-indigo-200' : 'bg-indigo-300');
                                block.className = `h-full ${bg} border-r border-white/60 last:border-0 cursor-pointer`;
                                block.style.width = `${w}%`;

                                const moduleTitle = (totals.detailedTimeline[index] && totals.detailedTimeline[index].title) ? totals.detailedTimeline[index].title : `Module ${index + 1}`;

                                const tooltipHtml = `<strong>${escapeHtml(seg.title)}</strong>`;

                                block.onmouseenter = (e) => showTooltip(e, tooltipHtml, true);
                                block.onmousemove = (e) => updateTooltipPos(e);
                                block.onmouseleave = () => hideTooltip();

                                block.onclick = () => {
                                    try {
                                        if (seg.el) {
                                            const moduleEl = moduleEls[index];
                                            const moduleBody = moduleEl ? moduleEl.querySelector('.activity-body') : null;
                                            if (moduleBody && moduleBody.classList.contains('collapsed')) moduleBody.classList.remove('collapsed');

                                            const momentBody = seg.el.querySelector('.moment-body');
                                            if (momentBody && momentBody.classList.contains('collapsed')) momentBody.classList.remove('collapsed');

                                            seg.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                            flashHighlight(seg.el);
                                        } else {
                                            scrollToEditor(index);
                                        }
                                    } catch (err) {
                                        console.error(err);
                                    }
                                };

                                fill.appendChild(block);
                            });
                        }

                        wrap.appendChild(missingEl);
                        wrap.appendChild(fill);
                        wrap.appendChild(overEl);
                        containerMoments.appendChild(wrap);

                        // Labels row (keeps the same module widths, shows labels only over the designed part)
                        const lWrap = document.createElement('div');
                        lWrap.style.width = `${actWidthPct}%`;
                        lWrap.className = 'flex overflow-hidden border-r border-transparent last:border-0';

                        const lFill = document.createElement('div');
                        lFill.className = 'flex';
                        lFill.style.width = `${ratio * 100}%`;

                        if (designedSecs > 0) {
                            segments.forEach((seg) => {
                                const w = (seg.secs / designedSecs) * 100;
                                if (w <= 0) return;

                                const labelEl = document.createElement('div');
                                labelEl.style.width = `${w}%`;
                                labelEl.className = 'px-1 truncate text-center border-r border-transparent last:border-0';
                                if (w > 6) {
                                    labelEl.innerText = seg.isGap ? (t.label_out_of_moments || 'Hors') : seg.title;
                                    labelEl.title = seg.title;
                                } else {
                                    labelEl.innerText = '.';
                                    labelEl.classList.add('text-transparent');
                                }
                                lFill.appendChild(labelEl);
                            });
                        }

                        lWrap.appendChild(lFill);
                        labelsMoments.appendChild(lWrap);
                    });
                }

                // --- TRACK 1.6: SUBMOMENTS (ALIGNED TO PLANNED) ---
                if (containerSubmoments && labelsSubmoments) {
                    const t = translations[currentLang] || translations.fr;
                    const moduleEls = Array.from(activityGroups || document.querySelectorAll('.activity-group'));

                    plannedTimeline.forEach((planned, index) => {
                        const plannedSecs = planned && planned.secs ? planned.secs : 0;
                        const designedSecs = (totals.detailedTimeline[index] && totals.detailedTimeline[index].duration) ? totals.detailedTimeline[index].duration : 0;

                        if (plannedSecs <= 0 && designedSecs <= 0) return;

                        const segmentSecsForWidth = plannedSecs > 0 ? plannedSecs : designedSecs;
                        const actWidthPct = baseTotalSecs > 0 ? (segmentSecsForWidth / baseTotalSecs) * 100 : 0;
                        const ratio = plannedSecs > 0 ? clamp(designedSecs / plannedSecs, 0, 1) : 1;

                        const wrap = document.createElement('div');
                        wrap.className = 'relative h-full flex overflow-hidden border-r border-slate-200/70 last:border-0';
                        wrap.style.width = `${actWidthPct}%`;

                        const cmp = (typeof compareDurations === 'function')
                            ? compareDurations(designedSecs, plannedSecs)
                            : { isMatch: designedSecs === plannedSecs, isUnder: designedSecs < plannedSecs, isOver: designedSecs > plannedSecs };

                        const missingEl = document.createElement('div');
                        missingEl.className = 'absolute inset-0 bg-slate-200/30 timeline-missing-light pointer-events-none';
                        if (!(plannedSecs > 0 && cmp.isUnder)) missingEl.style.display = 'none';

                        const overEl = document.createElement('div');
                        overEl.className = 'absolute inset-0 bg-red-200/35 timeline-alert-light pointer-events-none';
                        if (!(plannedSecs > 0 && cmp.isOver)) overEl.style.display = 'none';

                        const fill = document.createElement('div');
                        fill.className = 'absolute left-0 top-0 bottom-0 flex';
                        fill.style.width = `${ratio * 100}%`;

                        const actEl = moduleEls[index] || null;

                        let segments = [];
                        if (actEl) {
                            const momentEls = Array.from(actEl.querySelectorAll(':scope .activity-moments-container > .moment-group'));

                            momentEls.forEach((momEl, mi) => {
                                const momentTitle = (momEl.querySelector('.moment-title')?.value || '').trim() || `Moment ${mi + 1}`;

                                // Submoments
                                const subEls = Array.from(momEl.querySelectorAll(':scope .submoments-container > .submoment-card'));
                                subEls.forEach((smEl, si) => {
                                    let secs = 0;
                                    __ldQueryDesignedStepCards(smEl).forEach(stepEl => { secs += getStepDurationSecs(stepEl); });
                                    if (secs <= 0) return;

                                    const title = (smEl.querySelector('.submoment-title')?.value || '').trim() || `Sous-moment ${si + 1}`;
                                    segments.push({ title, secs, el: smEl, momentTitle, isDirect: false, isGap: false, isMomentStart: (si === 0) });
                                });

                                // Direct steps in the moment (not inside any submoment)
                                let directSecs = 0;
                                momEl.querySelectorAll('.moment-direct-steps .step-card').forEach(stepEl => { directSecs += getStepDurationSecs(stepEl); });
                                if (directSecs > 0) {
                                    segments.push({
                                        title: (t.label_direct_steps || 'Direct'),
                                        secs: directSecs,
                                        el: momEl,
                                        momentTitle,
                                        isDirect: true,
                                        isGap: false,
                                        isMomentStart: (subEls.length === 0)
                                    });
                                }
                            });

                            // Handle steps not contained in any moment (rare)
                            const inSegSecs = segments.reduce((acc, s) => acc + (s.secs || 0), 0);
                            const gap = designedSecs - inSegSecs;
                            if (gap > 1) {
                                segments.push({ title: (t.label_out_of_submoments || 'Hors sous-moments'), secs: gap, el: actEl, momentTitle: '', isDirect: false, isGap: true, isMomentStart: false });
                            }

                            if (!segments.length && designedSecs > 0) {
                                segments.push({ title: (t.label_out_of_submoments || 'Hors sous-moments'), secs: designedSecs, el: actEl, momentTitle: '', isDirect: false, isGap: true, isMomentStart: false });
                            }
                        } else if (designedSecs > 0) {
                            segments = [{ title: (t.label_out_of_submoments || 'Hors sous-moments'), secs: designedSecs, el: null, momentTitle: '', isDirect: false, isGap: true, isMomentStart: false }];
                        }

                        if (designedSecs > 0) {
                            segments.forEach((seg, si) => {
                                const w = (seg.secs / designedSecs) * 100;
                                if (w <= 0) return;

                                const block = document.createElement('div');
                                let bg = '';
                                if (seg.isGap) bg = 'bg-slate-300 pattern-dots';
                                else if (seg.isDirect) bg = (si % 2 === 0 ? 'bg-slate-300 pattern-vertical' : 'bg-slate-200 pattern-vertical');
                                else bg = (si % 2 === 0 ? 'bg-slate-300' : 'bg-slate-400');

                                const momentSep = seg.isMomentStart ? 'border-l border-slate-500/40' : '';
                                block.className = `h-full ${bg} ${momentSep} border-r border-white/60 last:border-0 cursor-pointer`;
                                block.style.width = `${w}%`;

                                const moduleTitle = (totals.detailedTimeline[index] && totals.detailedTimeline[index].title) ? totals.detailedTimeline[index].title : `Module ${index + 1}`;
                                const tooltipHtml = `<strong>${escapeHtml(seg.title)}</strong>`;

                                block.onmouseenter = (e) => showTooltip(e, tooltipHtml, true);
                                block.onmousemove = (e) => updateTooltipPos(e);
                                block.onmouseleave = () => hideTooltip();

                                block.onclick = () => {
                                    try {
                                        if (seg.el) {
                                            const moduleEl = moduleEls[index];
                                            const moduleBody = moduleEl ? moduleEl.querySelector('.activity-body') : null;
                                            if (moduleBody && moduleBody.classList.contains('collapsed')) moduleBody.classList.remove('collapsed');

                                            // Ensure parent moment expanded
                                            const momentGroup = seg.el.classList.contains('moment-group') ? seg.el : seg.el.closest('.moment-group');
                                            const momentBody = momentGroup ? momentGroup.querySelector('.moment-body') : null;
                                            if (momentBody && momentBody.classList.contains('collapsed')) momentBody.classList.remove('collapsed');

                                            seg.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                            flashHighlight(seg.el);
                                        } else {
                                            scrollToEditor(index);
                                        }
                                    } catch (err) {
                                        console.error(err);
                                    }
                                };

                                fill.appendChild(block);
                            });
                        }

                        wrap.appendChild(missingEl);
                        wrap.appendChild(fill);
                        wrap.appendChild(overEl);
                        containerSubmoments.appendChild(wrap);

                        // Labels row
                        const lWrap = document.createElement('div');
                        lWrap.style.width = `${actWidthPct}%`;
                        lWrap.className = 'flex overflow-hidden border-r border-transparent last:border-0';

                        const lFill = document.createElement('div');
                        lFill.className = 'flex';
                        lFill.style.width = `${ratio * 100}%`;

                        if (designedSecs > 0) {
                            segments.forEach((seg) => {
                                const w = (seg.secs / designedSecs) * 100;
                                if (w <= 0) return;

                                const labelEl = document.createElement('div');
                                labelEl.style.width = `${w}%`;
                                labelEl.className = 'px-1 truncate text-center border-r border-transparent last:border-0';
                                const labelText = seg.isGap ? (t.label_out_of_submoments || 'Hors') : (seg.isDirect ? (t.label_direct_steps || 'Direct') : seg.title);

                                if (w > 6) {
                                    labelEl.innerText = labelText;
                                    labelEl.title = seg.title;
                                } else {
                                    labelEl.innerText = '.';
                                    labelEl.classList.add('text-transparent');
                                }
                                lFill.appendChild(labelEl);
                            });
                        }

                        lWrap.appendChild(lFill);
                        labelsSubmoments.appendChild(lWrap);
                    });
                }

// --- TRACK 2: LEARNING TYPES (STEPS) ---
                // Group segments by planned module so Track 2 aligns with Tracks 0/1.
                // Also show the same "Trop court / Trop long" alerts when designed duration diverges from planned.
                const t = translations[currentLang];

                // Standard Grey Colours
                const greySolid = '#64748b';   // Slate-500
                const greyStriped = '#94a3b8'; // Slate-400

                const makeModuleWrapper = (widthPct) => {
                    const wrap = document.createElement('div');
                    wrap.className = 'h-full border-r border-white last:border-0 relative group box-border overflow-visible';
                    wrap.style.width = `${widthPct}%`;
                    return wrap;
                };

                const makeFillContainer = (ratio) => {
                    const fill = document.createElement('div');
                    fill.className = 'absolute left-0 top-0 bottom-0 flex';
                    fill.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
                    return fill;
                };

                // Helper to create simple blocks with patterns (for Regroupement / Formateur / Lieu / Temps).
                const createBlock = (widthPct, bgColor, patternClass, tooltip, onClick) => {
                    const el = document.createElement('div');
                    el.style.width = `${widthPct}%`;
                    el.style.backgroundColor = bgColor;
                    el.className = `h-full border-r border-white/20 last:border-0 hover:brightness-90 transition-all relative group cursor-pointer ${patternClass}`;
                    el.onmouseenter = (e) => showTooltip(e, tooltip, true);
                    el.onmousemove = (e) => updateTooltipPos(e);
                    el.onmouseleave = () => hideTooltip();
                    if (typeof onClick === 'function') el.onclick = onClick;
                    return el;
                };

                plannedTimeline.forEach((planned, index) => {
                    const plannedSecs = planned && planned.secs ? planned.secs : 0;
                    const activity = totals.detailedTimeline[index];
                    const designedSecs = (activity && activity.duration) ? activity.duration : 0;

                    if (plannedSecs <= 0 && designedSecs <= 0) return;

                    // Width is based on planned segment to ensure alignment with Track 0/1
                    const segmentSecsForWidth = plannedSecs > 0 ? plannedSecs : designedSecs;
                    const moduleWidthPct = (segmentSecsForWidth / baseTotalSecs) * 100;

                    // Fill ratio (designed within planned) – capped to 100% (overrun is shown via overlay)
                    const ratio = plannedSecs > 0 ? Math.min(1, Math.max(0, designedSecs / plannedSecs)) : 1;

                    // Module wrappers for each detail track
                    const stepsWrap = makeModuleWrapper(moduleWidthPct);
                    const groupingWrap = makeModuleWrapper(moduleWidthPct);
                    const trainerWrap = makeModuleWrapper(moduleWidthPct);
                    const placeWrap = makeModuleWrapper(moduleWidthPct);
                    const timeWrap = makeModuleWrapper(moduleWidthPct);

                    // Alerts on Track 2 (Learning types) – same behaviour as Track 1
                    const cmp = (typeof compareDurations === 'function')
                        ? compareDurations(designedSecs, plannedSecs)
                        : { isMatch: designedSecs === plannedSecs, isUnder: designedSecs < plannedSecs, isOver: designedSecs > plannedSecs, deviation: designedSecs - plannedSecs };

                    const missingEl = document.createElement('div');
                    missingEl.className = 'absolute inset-0 timeline-missing-light';
                    if (!(plannedSecs > 0 && cmp.isUnder)) {
                        missingEl.style.display = 'none';
                    }

                    const overEl = document.createElement('div');
                    overEl.className = 'absolute inset-0 timeline-alert-light pointer-events-none';
                    if (!(plannedSecs > 0 && cmp.isOver)) {
                        overEl.style.display = 'none';
                    }

                    const iconsEl = document.createElement('div');
                    iconsEl.className = 'timeline-alert-icons';
                    if (plannedSecs > 0 && !cmp.isMatch) {
                        const deviationMins = Math.round(Math.abs(cmp.deviation || 0) / 60);
                        if (deviationMins > 0) {
                            iconsEl.textContent = (cmp.deviation > 0)
                                ? `Trop long +${deviationMins}m`
                                : `Trop court -${deviationMins}m`;
                            iconsEl.style.display = 'flex';
                        } else {
                            iconsEl.style.display = 'none';
                        }
                    } else {
                        iconsEl.style.display = 'none';
                    }

                    const tooltipTextModule = `<strong>${escapeHtml(planned.title)}</strong>`;
                    stepsWrap.onmouseenter = (e) => showTooltip(e, tooltipTextModule, true);
                    stepsWrap.onmousemove = (e) => updateTooltipPos(e);
                    stepsWrap.onmouseleave = () => hideTooltip();

                    stepsWrap.appendChild(missingEl);
                    stepsWrap.appendChild(overEl);
                    stepsWrap.appendChild(iconsEl);

                    // Fill containers (only the designed portion is filled with step-level segments)
                    const stepsFill = makeFillContainer(ratio);
                    const groupingFill = makeFillContainer(ratio);
                    const trainerFill = makeFillContainer(ratio);
                    const placeFill = makeFillContainer(ratio);
                    const timeFill = makeFillContainer(ratio);

                    // When there is no designed time, we still append empty wrappers to preserve alignment.
                    if (activity && Array.isArray(activity.steps) && activity.steps.length && designedSecs > 0) {
                        activity.steps.forEach((step, stepIdx) => {
                            if (!(step && step.duration > 0)) return;
                            const stepPctWithinDesigned = (step.duration / designedSecs) * 100;

                            // Track 2 – Learning types (coloured by pedagogical type)
                            const stepEl = document.createElement('div');
                            stepEl.style.backgroundColor = TYPE_COLORS[step.type];
                            stepEl.style.width = `${stepPctWithinDesigned}%`;
                            stepEl.className = 'h-full border-r border-white/20 last:border-0 hover:brightness-90 transition-all relative group cursor-pointer';

                            const sDur = Math.round(step.duration / 60);
                            const tooltipText = `<strong>${escapeHtml(step.title)}</strong>`;
                            stepEl.onmouseenter = (e) => showTooltip(e, tooltipText, true);
                            stepEl.onmousemove = (e) => updateTooltipPos(e);
                            stepEl.onmouseleave = () => hideTooltip();
                            stepsFill.appendChild(stepEl);

                            // Grouping (Stripes for Groups)
                            const grpColor = step.groupMode === 'class' ? greySolid : greyStriped;
                            const grpPattern = step.groupMode === 'groups' ? 'pattern-stripes' : '';
                            const grpLabel = step.groupMode === 'groups' ? t.opt_groups : (step.groupMode === 'individual' ? t.opt_individual : t.opt_whole_class);
                            groupingFill.appendChild(createBlock(stepPctWithinDesigned, grpColor, grpPattern, `<strong>${grpLabel}</strong>`, () => scrollToEditor(index, stepIdx)));

                            // Trainer (Stripes for Absent)
                            const trainerColor = step.trainer === 'present' ? greySolid : greyStriped;
                            const trainerPattern = step.trainer === 'absent' ? 'pattern-stripes' : '';
                            const trainerLabel = step.trainer === 'present' ? t.opt_present : t.opt_absent;
                            trainerFill.appendChild(createBlock(stepPctWithinDesigned, trainerColor, trainerPattern, `<strong>${trainerLabel}</strong>`, () => scrollToEditor(index, stepIdx)));

                            // Place (Stripes for Online / Hybrid)
                            const placeLabel = (step.place === 'situ') ? t.opt_insitu : (step.place === 'online') ? t.opt_online : t.opt_hybrid;
                            const placeColor = (step.place === 'situ') ? greySolid : greyStriped;
                            const placePattern = (step.place === 'situ') ? '' : 'pattern-stripes';
                            placeFill.appendChild(createBlock(stepPctWithinDesigned, placeColor, placePattern, `<strong>${placeLabel}</strong>`, () => scrollToEditor(index, stepIdx)));

                            // Time (Stripes for Asynchronous)
                            const timeLabel = (step.time === 'sync') ? t.opt_sync : t.opt_async;
                            const timeColor = (step.time === 'sync') ? greySolid : greyStriped;
                            const timePattern = (step.time === 'sync') ? '' : 'pattern-stripes';
                            timeFill.appendChild(createBlock(stepPctWithinDesigned, timeColor, timePattern, `<strong>${timeLabel}</strong>`, () => scrollToEditor(index, stepIdx)));
                        });
                    }

                    stepsWrap.appendChild(stepsFill);
                    groupingWrap.appendChild(groupingFill);
                    trainerWrap.appendChild(trainerFill);
                    placeWrap.appendChild(placeFill);
                    timeWrap.appendChild(timeFill);

                    containerSteps.appendChild(stepsWrap);
                    containerGrouping.appendChild(groupingWrap);
                    containerTrainer.appendChild(trainerWrap);
                    containerPlace.appendChild(placeWrap);
                    containerTime.appendChild(timeWrap);
                });

                // --- RULER (supprimée) ---
            }

            // Update Individual Activity Timeline Bars
            totals.detailedTimeline.forEach((actData, index) => {
                if (index < activityGroups.length) {
                    const group = activityGroups[index];
                    const bar = group.querySelector('.activity-type-bar');
                    const label = group.querySelector('.activity-total-time');
	                    const designedBadge = group.querySelector('.activity-designed-badge');
	                    const targetVal = group.querySelector('.activity-target-time');
	                    const targetUnitSel = group.querySelector('.activity-target-unit');
	                    const compareEl = group.querySelector('.module-time-compare');

                    // Designed duration for this module (seconds) = sum of ACTIVITY durations only.
                    // This intentionally ignores MODULE/MOMENT target fields to avoid any double-counting.
                    const moduleDesignedSecs = (() => {
                        let secs = 0;
                        try {
                            __ldQueryDesignedStepCards(group).forEach(stepEl => { secs += getStepDurationSecs(stepEl); });
                        } catch(_){ __ldSilentErr(_); }
                        secs = Number.isFinite(secs) ? secs : 0;
                        try { group.dataset.designedSecs = String(secs); } catch(_){ __ldSilentErr(_); }
                        return secs;
                    })();

                    
                    if (bar && label) {
                        bar.innerHTML = '';
                        // Update label
                        const unitSecs = mapUnitToSecs(targetUnitSel?.value || getDefaultDurationUnitSecs());
                        const unitText = __ldGetUnitLabelBySecs(unitSecs, unitLabelFmt);
                        let v = moduleDesignedSecs / unitSecs;
                        if (unitSecs === 60) v = Math.round(v);
                        else v = parseFloat(v.toFixed(1));
                        label.innerText = `${v} ${unitText}`;

	                        // Module designed duration alert: if target is set and differs, tint the designed badge
	                        if (designedBadge) {
	                          designedBadge.classList.remove('duration-alert-light');
	                          const tv = targetVal ? parseFloat(targetVal.value) : 0;
	                          const tu = targetUnitSel ? mapUnitToSecs(targetUnitSel.value) : 60;
	                          const targetSecs = (isNaN(tv) ? 0 : tv) * (isNaN(tu) ? 60 : tu);
	                          
	                          try { __ldUpdateDeltaBar(designedBadge, targetSecs, moduleDesignedSecs); } catch(_){ __ldSilentErr(_); }
if (targetSecs > 0) {
	                            const cmp = (typeof compareDurations === 'function')
	                                ? compareDurations(moduleDesignedSecs, targetSecs)
	                                : { isMatch: Math.round(moduleDesignedSecs) === Math.round(targetSecs), deviation: moduleDesignedSecs - targetSecs };
	                            if (!cmp.isMatch) designedBadge.classList.add('duration-alert-light');
	                            // Comparison symbol between target and designed at module level
	                            if (compareEl) {
	                              // Comparison symbol is rendered between Target (left) and Designed (right)
	                              // so direction must reflect target vs designed, not designed vs target.
	                              const sym = cmp.isMatch ? '=' : (cmp.deviation > 0 ? '<' : '>');
	                              compareEl.textContent = sym;
	                              compareEl.classList.toggle('text-red-600', !cmp.isMatch);
	                            }
	                          } else if (compareEl) {
	                            compareEl.textContent = '';
	                            compareEl.classList.remove('text-red-600');
	                          }
	                        }

                        // Update bar
                        if (moduleDesignedSecs > 0) {
                            actData.steps.forEach(step => {
                                if (step.duration > 0) {
                                    const pct = (step.duration / moduleDesignedSecs) * 100;
                                    const el = document.createElement('div');
                                    el.style.width = `${pct}%`;
                                    el.style.backgroundColor = TYPE_COLORS[step.type];
                                    el.className = 'h-full hover:brightness-90 transition-all border-r border-white/20 last:border-0';
                                    el.title = `${escapeHtml(step.title)}: ${Math.round(step.duration/60)}m (${escapeHtml(step.learningTypeLabel)})`;
                                    bar.appendChild(el);
                                }
                            });
                        }
                    }
                }
            });
            try { updateAllModuleCompetenceSummaries(); } catch (e) { console.error('updateAllModuleCompetenceSummaries failed', e); }
            try { updateAllModuleLearningTargetsSummaries(); } catch (e) { console.error('updateAllModuleLearningTargetsSummaries failed', e); }

            updateFocusButtons();
        }
        
        const EXPORT_ERROR_MSG = {
            fr: "Une erreur est survenue lors de l’export. Consultez la console pour le détail.",
            en: "An error occurred during export. Please check the console for details."
        };

        function runExport(fn) {
            try {
                fn();
            } catch (err) {
                console.error(err);
                showAlert('Erreur', EXPORT_ERROR_MSG[currentLang] || EXPORT_ERROR_MSG.fr);
            }
        }

        
        function exportPDFPrintFull() {
            // Ensure print/PDF includes all collapsible content.
            const details = Array.from(document.querySelectorAll('details'));
            const prev = details.map(d => d.hasAttribute('open'));
            details.forEach(d => d.setAttribute('open', ''));

            const cleanup = () => {
                details.forEach((d, i) => {
                    if (prev[i]) d.setAttribute('open', '');
                    else d.removeAttribute('open');
                });
                window.removeEventListener('afterprint', cleanup);
            };
            window.addEventListener('afterprint', cleanup);
            window.print();
            // In some browsers afterprint may not fire if print is cancelled; still keep listener.
        }

function handleExport(select) {
            const value = select.value;
            select.value = ""; // Reset dropdown

            if (value === 'markdown') {
                runExport(exportMarkdown);
            } else if (value === 'pdf') {
                runExport(exportPDFPrintFull);
            } else if (value === 'richtext') {
                runExport(exportRichText);
            } else if (value === 'rtf') {
                runExport(exportRTF);
            } else if (value === 'csv') {
                runExport(exportCSV);
            } else if (value === 'docx') {
                runExport(exportDOCX);
            }
        }

function buildExportModel() {
    // Centralised export model derived from the same source as project save (single point of truth).
    // This model is used by XLSX/DOCX exports and aims to keep a stable, explicit structure:
    // Modules → Moments → Sub-moments → Activities.
    const t = translations[currentLang] || translations.fr;
    const project = buildExportProjectData();

    const __compMap = new Map(((project.parametres?.competences) || []).map(c => [String(c?.id || '').trim(), String(c?.label || c?.id || '').trim()]));
    const __compTMap = new Map(((project.parametres?.competencesTransversales) || []).map(c => [String(c?.id || '').trim(), String(c?.label || c?.id || '').trim()]));
    const __idsToLabels = (ids, mp) => {
        if (!Array.isArray(ids)) return [];
        return ids.map(x => String(x || '').trim()).filter(Boolean).map(id => mp.get(id) || id);
    };

    const asStr = (v) => (v == null ? '' : String(v));
    const asNum = (v) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : 0;
    };

    const unitLabelFromSecs = (secs) => {
        // For XLSX/TXT exports we use the visible labels from the UI options when possible.
        const map = {
            60: t.unit_mins || 'min',
            3600: t.unit_hours || 'Heures',
            86400: t.unit_days || 'Jours',
            604800: t.unit_weeks || 'Semaines',
            2592000: t.unit_months || 'Mois'
        };
        const n = Number(secs);
        return map[n] || asStr(secs);
    };

    const fmtTarget = (val, unitSecsOrKey) => {
        const v = asStr(val).trim();
        if (!v) return '';
        const unitLabel = unitLabelFromSecs(unitSecsOrKey);
        return `${v} ${unitLabel}`.trim();
    };

    const safeTypeLabel = (typeKey) => {
        const key = `type_${typeKey}`;
        return (t && t[key]) ? t[key] : asStr(typeKey);
    };

    const safeOptLabel = (prefix, key, fallback) => {
        const k = `${prefix}_${key}`;
        return (t && t[k]) ? t[k] : (fallback || asStr(key));
    };

    const __mapActivity = (a) => {
        const duree = asStr(a.duree);
        const unite = asStr(a.unite);
        const minutes = Math.round((asNum(duree) * asNum(unite) / 60) * 100) / 100;
        const evalKey = asStr(a.evaluation || 'Aucune');

        const toolsTargets = Array.isArray(a.outilsMaterielCibles) ? a.outilsMaterielCibles : [];
        const toolsNotesObj = __normaliseToolsMaterialsNotes(a.outilsMaterielNotes ?? a.toolsMaterialsNotes ?? a.toolsMaterialsNotesByItem ?? {});
        const toolsTargetsWithNotesText = (toolsTargets || []).map(v0 => {
            const v = String(v0 || '').trim();
            if (!v) return null;
            const nn = (toolsNotesObj && Object.prototype.hasOwnProperty.call(toolsNotesObj, v)) ? String(toolsNotesObj[v] || '').trim() : '';
            return nn ? (v + ' — ' + __toOneLineNote(nn)) : v;
        }).filter(Boolean).join('; ');

        const csIds = Array.isArray(a.competencesSujet) ? a.competencesSujet : (Array.isArray(a.competences) ? a.competences : []);
        const ctIds = Array.isArray(a.competencesTransversales) ? a.competencesTransversales : [];

        return {
            title: ((a && a.ignored) ? '[IGNORÉ] ' : '') + asStr(a.titre),
            objective: asStr(a.objectifActivite),
            tasks: asStr(a.aFaire),
            trainerTasks: asStr(a.aFaireFormateur),
            notes: asStr(a.notes),
            evaluationSuivi: asStr(a.evaluationSuivi),
            linksReferences: asStr(a.liensReferences),
            typeKey: asStr(a.type),
            typeLabel: safeTypeLabel(asStr(a.type)),
            groupingKey: asStr(a.regroupement),
            groupingLabel: safeOptLabel('opt', (a.regroupement === 'class' ? 'whole_class' : a.regroupement === 'groups' ? 'groups' : a.regroupement === 'individual' ? 'individual' : a.regroupement), asStr(a.regroupement)),
            groupCount: asStr(a.nombreGroupes),
            groupSize: asStr(a.tailleGroupe),
            groupDetails: asStr(a.detailsRegroupement),
            aimsTargets: Array.isArray(a.objectifsCibles) ? a.objectifsCibles : [],
            outcomesTargets: Array.isArray(a.resultatsApprentissageCibles) ? a.resultatsApprentissageCibles : [],
            toolsMaterialsTargets: toolsTargets,
            aimsTargetsText: (Array.isArray(a.objectifsCibles) ? a.objectifsCibles : []).join('; '),
            outcomesTargetsText: (Array.isArray(a.resultatsApprentissageCibles) ? a.resultatsApprentissageCibles : []).join('; '),
            toolsMaterialsTargetsText: (toolsTargets || []).join('; '),
            toolsMaterialsNotes: toolsNotesObj,
            toolsMaterialsTargetsWithNotesText,
            trainerKey: asStr(a.formateur),
            placeKey: asStr(a.lieu),
            timeKey: asStr(a.temps),
            evaluationKey: evalKey,
            trainerLabel: safeOptLabel('opt', asStr(a.formateur), asStr(a.formateur)),
            placeLabel: safeOptLabel('opt', asStr(a.lieu), asStr(a.lieu)),
            timeLabel: safeOptLabel('opt', asStr(a.temps), asStr(a.temps)),
            evaluationLabel: evalKey,
            durationValue: duree,
            durationUnitSecs: unite,
            durationLabel: `${duree} ${unitLabelFromSecs(unite)}`.trim(),
            durationMinutes: minutes,
            competencesSujetIds: csIds,
            competencesTransversalesIds: ctIds,
            competencesSujetLabels: __idsToLabels(csIds, __compMap),
            competencesTransversalesLabels: __idsToLabels(ctIds, __compTMap),
            competencesSujetText: (__idsToLabels(csIds, __compMap)).join(', '),
            competencesTransversalesText: (__idsToLabels(ctIds, __compTMap)).join(', ')
        };
    };

    const modules = (project.modules || []).map((m) => {
        const __rawMoments = (m.moments || []);
        const __momentsSource = (__rawMoments && __rawMoments.length) ? __rawMoments : [{
            titre: '',
            description: '',
            dureeCible: '',
            uniteDureeCible: '',
            activites: (m.activites || [])
        }];

        const moments = (__momentsSource || []).map((mo) => {
            // Normalise sub-moments (keep both legacy FR keys and canonical EN keys)
            let smSrc = [];
            if (Array.isArray(mo.sousMoments) && mo.sousMoments.length) smSrc = mo.sousMoments;
            else if (Array.isArray(mo.subMoments) && mo.subMoments.length) smSrc = mo.subMoments;

            const momentObj = {
                title: ((mo && mo.ignored) ? '[IGNORÉ] ' : '') + asStr(mo.titre),
                description: asStr(mo.description),
                target: fmtTarget(mo.dureeCible, mo.uniteDureeCible),
                targetRaw: { value: asStr(mo.dureeCible), unit: asStr(mo.uniteDureeCible) },
                submoments: []
            };

            if (smSrc && smSrc.length) {
                momentObj.submoments = smSrc.map((sm) => {
                    // Support both shapes:
                    // - legacy: {titre, dureeCible, uniteDureeCible, activites:[...]}
                    // - canonical: {title, targetTime, targetUnit, steps:[...]}
                    const smTitle = (((sm && sm.ignored) ? '[IGNORÉ] ' : '') + asStr(sm.titre ?? sm.title));
                    const smTargetVal = asStr(sm.dureeCible ?? sm.targetTime);
                    const smTargetUnit = asStr(sm.uniteDureeCible ?? sm.targetUnit);
                    const acts = (sm.activites || sm.steps || []);
                    return {
                        title: smTitle,
                        description: asStr(sm.description || ''),
                        target: fmtTarget(smTargetVal, smTargetUnit),
                        targetRaw: { value: smTargetVal, unit: smTargetUnit },
                        activities: (acts || []).map(__mapActivity)
                    };
                });
            } else {
                // No sub-moments: keep a single implicit sub-moment to preserve a stable depth
                const acts = (mo.activites || []);
                momentObj.submoments = [{
                    title: '',
                    description: '',
                    target: '',
                    targetRaw: { value: '', unit: '' },
                    activities: (acts || []).map(__mapActivity)
                }];
            }

            // Backward-compatible flattened list (some exporters may still rely on it)
            momentObj.activities = momentObj.submoments.reduce((acc, sm) => acc.concat(sm.activities || []), []);
            return momentObj;
        });

        return {
            title: asStr(m.titre),
            description: asStr(m.description),
            notes: asStr(m.notes),
            target: fmtTarget(m.dureeCible, m.uniteDureeCible),
            targetRaw: { value: asStr(m.dureeCible), unit: asStr(m.uniteDureeCible) },
            aimsTargets: Array.isArray(m.objectifsApprentissageModule) ? m.objectifsApprentissageModule : [],
            outcomesTargets: Array.isArray(m.resultatsApprentissageModule) ? m.resultatsApprentissageModule : [],
            competencesSujetIds: Array.isArray(m.competencesModuleSujet) ? m.competencesModuleSujet : [],
            competencesTransversalesIds: Array.isArray(m.competencesModuleTransversales) ? m.competencesModuleTransversales : [],
            competencesSujetLabels: __idsToLabels(m.competencesModuleSujet, __compMap),
            competencesTransversalesLabels: __idsToLabels(m.competencesModuleTransversales, __compTMap),
            competencesSujetText: __idsToLabels(m.competencesModuleSujet, __compMap).join(', '),
            competencesTransversalesText: __idsToLabels(m.competencesModuleTransversales, __compTMap).join(', '),
            moments
        };
    });

    const meta = {
        courseName: asStr(project.parametres?.nom),
        topic: asStr(project.parametres?.theme),
        authors: asStr(project.parametres?.auteurs),
        trainers: asStr(project.parametres?.formateurs),
        level: asStr(project.parametres?.niveau),
        targetAudience: asStr(project.parametres?.publicCible),
        prerequisites: asStr(project.parametres?.prerequis),
        toolsMaterials: asStr(project.parametres?.outilsMateriel),
        toolsMaterialsItems: Array.isArray(project.parametres?.outilsMaterielItems) ? project.parametres.outilsMaterielItems : [],
        toolsMaterialsNotes: asStr(project.parametres?.outilsMaterielNotes),
        mode: asStr(project.parametres?.modalite),
        cohortSize: asStr(project.parametres?.tailleCohorte),
        learningTime: `${asStr(project.parametres?.dureeApprentissageValeur)} ${asStr(project.parametres?.dureeApprentissageUnite)}`.trim(),
        designedTime: `${asStr(project.parametres?.dureeConcueValeur)} ${asStr(project.parametres?.dureeConcueUnite)}`.trim(),
        aims: asStr(project.parametres?.objectifs),
        aimsItems: Array.isArray(project.parametres?.objectifsItems) ? project.parametres.objectifsItems : [],
        outcomesText: asStr(project.parametres?.resultatsTexte),
        outcomesTextItems: Array.isArray(project.parametres?.resultatsTexteItems) ? project.parametres.resultatsTexteItems : [],
        outcomes: Array.isArray(project.parametres?.resultats) ? project.parametres.resultats : [],
        competences: Array.isArray(project.parametres?.competences) ? project.parametres.competences : [],
        competencesTransversales: Array.isArray(project.parametres?.competencesTransversales) ? project.parametres.competencesTransversales : [],
        description: asStr(project.parametres?.description),
        generatedOn: new Date().toISOString().slice(0, 10)
    };

    return { meta, modules };
}


function buildTabularExportRows(model) {
    // Tabular export for XLSX (menu label may say CSV). Keeps a strict header↔row parity.
    // Structure: Module → Moment → Sous-moment → Activité (une ligne par activité).
    const headers = [
        'Module #',
        'Module titre',
        'Module description',
        'Module notes',
        'Module durée cible',
        'Module objectifs (sélection)',
        'Module résultats (sélection)',
        'Module comp. sujet (sélection)',
        'Module comp. transversales (sélection)',
        'Moment #',
        'Moment titre',
        'Moment description',
        'Moment durée cible',
        'Sous-moment #',
        'Sous-moment titre',
        'Sous-moment description',
        'Sous-moment durée cible',
        'Activité #',
        'Activité titre',
        'Objectif',
        'Tâches',
        'Tâches du formateur',
        'Évaluation',
        'Évaluation / suivi',
        'Notes',
        'Liens / références',
        "Type d'apprentissage",
        'Regroupement',
        'Taille groupe',
        'Nb groupes',
        'Détails regroupement',
        'Objectifs ciblés',
        'Résultats ciblés',
        'Outils et matériel (activité)',
        'Lieu',
        'Temps',
        'Présence formateur',
        'Compétences du sujet',
        'Compétences transversales',
        'Durée (min)'
    ];

    const rows = [headers];
    const safe = (v) => (v == null ? '' : String(v));
    const joinArr = (a) => (Array.isArray(a) ? a.map(x => String(x || '').trim()).filter(Boolean).join(' ; ') : '');
    const blankRow = () => Array(headers.length).fill('');

    (model.modules || []).forEach((mod, mi) => {
        const moduleIdx = mi + 1;
        const modTitle = safe(mod.title);
        const modDesc = safe(mod.description);
        const modNotes = safe(mod.notes);
        const modTarget = safe(mod.target);
        const modAims = joinArr(mod.aimsTargets);
        const modOut = joinArr(mod.outcomesTargets);
        const modCs = safe(mod.competencesSujetText);
        const modCt = safe(mod.competencesTransversalesText);

        const moments = (mod.moments || []);
        if (moments.length) {
            moments.forEach((mom, mj) => {
                const momentIdx = mj + 1;
                const momTitle = safe(mom.title);
                const momDesc = safe(mom.description);
                const momTarget = safe(mom.target);

                const submoments = (mom.submoments && mom.submoments.length) ? mom.submoments : [{
                    title: '',
                    description: '',
                    target: '',
                    activities: (mom.activities || [])
                }];

                submoments.forEach((sm, smj) => {
                    const smIdx = smj + 1;
                    const smTitle = safe(sm.title);
                    const smDesc = safe(sm.description);
                    const smTarget = safe(sm.target);

                    const acts = (sm.activities || []);
                    if (acts.length) {
                        acts.forEach((act, ai) => {
                            const activityIdx = ai + 1;
                            rows.push([
                                moduleIdx,
                                modTitle,
                                modDesc,
                                modNotes,
                                modTarget,
                                modAims,
                                modOut,
                                modCs,
                                modCt,
                                momentIdx,
                                momTitle,
                                momDesc,
                                momTarget,
                                smTitle || smDesc || smTarget ? smIdx : '',     // keep blank when it's the implicit sub-moment
                                smTitle,
                                smDesc,
                                smTarget,
                                activityIdx,
                                safe(act.title),
                                safe(act.objective),
                                safe(act.tasks),
                                safe(act.trainerTasks),
                                safe(act.evaluationLabel || act.evaluationKey || act.evaluation || ''),
                                safe(act.evaluationSuivi),
                                safe(act.notes),
                                safe(act.linksReferences),
                                safe(act.typeLabel),
                                safe(act.groupingLabel),
                                safe(act.groupSize),
                                safe(act.groupCount),
                                safe(act.groupDetails),
                                safe(act.aimsTargetsText),
                                safe(act.outcomesTargetsText),
                                safe(act.toolsMaterialsTargetsWithNotesText || act.toolsMaterialsTargetsText),
                                safe(act.placeLabel),
                                safe(act.timeLabel),
                                safe(act.trainerLabel),
                                safe(act.competencesSujetText),
                                safe(act.competencesTransversalesText),
                                safe(act.durationMinutes)
                            ]);
                        });
                    } else {
                        // Keep a structural row even when there is no activity
                        const r = blankRow();
                        r[0] = moduleIdx;
                        r[1] = modTitle;
                        r[2] = modDesc;
                        r[3] = modNotes;
                        r[4] = modTarget;
                        r[5] = modAims;
                        r[6] = modOut;
                        r[7] = modCs;
                        r[8] = modCt;
                        r[9] = momentIdx;
                        r[10] = momTitle;
                        r[11] = momDesc;
                        r[12] = momTarget;
                        r[13] = smTitle || smDesc || smTarget ? smIdx : '';
                        r[14] = smTitle;
                        r[15] = smDesc;
                        r[16] = smTarget;
                        rows.push(r);
                    }
                });
            });
        } else {
            // No moments: keep a minimal structural row
            const r = blankRow();
            r[0] = moduleIdx;
            r[1] = modTitle;
            r[2] = modDesc;
            r[3] = modNotes;
            r[4] = modTarget;
            r[5] = modAims;
            r[6] = modOut;
            r[7] = modCs;
            r[8] = modCt;
            rows.push(r);
        }
    });

    return rows;
}





function exportDOCX() {
    if (!window.docx || !window.docx.Document) {
        showAlert('Erreur', (currentLang === 'en') ? 'Word export library is not available.' : 'La bibliothèque d’export Word n’est pas disponible.');
        return;
    }

    const model = buildExportModel();
    const { Document, Packer, Paragraph, HeadingLevel, TextRun } = window.docx;

    const safe = (s) => (s ?? '').toString().trim();
    const lines = (s) => safe(s).split(/\r\n|\r|\n/).filter(Boolean);

    const children = [];
    children.push(new Paragraph({
        text: `Export (Word) — ${model.meta.generatedOn}`,
        heading: HeadingLevel.TITLE
    }));

    const addMetaLine = (label, value) => {
        const v = safe(value);
        if (!v) return;
        children.push(new Paragraph({
            children: [new TextRun({ text: `${label} : `, bold: true }), new TextRun(v)]
        }));
    };

    addMetaLine('Nom de la formation', model.meta.courseName);
    addMetaLine('Concepteurs', model.meta.authors);
    addMetaLine('Formateurs', model.meta.trainers);
    addMetaLine('Thème', model.meta.topic);
    addMetaLine('Niveau', model.meta.level);
    addMetaLine('Modalité', model.meta.mode);
    addMetaLine('Taille cohorte', model.meta.cohortSize);
    if (model.meta.learningTime) addMetaLine('Temps apprentissage', model.meta.learningTime);
    if (model.meta.designedTime) addMetaLine('Temps conçu', model.meta.designedTime);

    if (safe(model.meta.description)) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Description', heading: HeadingLevel.HEADING_1 }));
        lines(model.meta.description).forEach(l => children.push(new Paragraph({ text: l })));
    }

    if (safe(model.meta.targetAudience)) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Public cible', heading: HeadingLevel.HEADING_1 }));
        lines(model.meta.targetAudience).forEach(l => children.push(new Paragraph({ text: l })));
    }

    if (safe(model.meta.prerequisites)) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Prérequis', heading: HeadingLevel.HEADING_1 }));
        lines(model.meta.prerequisites).forEach(l => children.push(new Paragraph({ text: l })));
    }

    if (safe(model.meta.aims)) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Objectifs', heading: HeadingLevel.HEADING_1 }));
        lines(model.meta.aims).forEach(l => children.push(new Paragraph({ text: l })));
    }

    if (safe(model.meta.outcomesText)) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Résultats attendus', heading: HeadingLevel.HEADING_1 }));
        lines(model.meta.outcomesText).forEach(l => children.push(new Paragraph({ text: l })));
    }

    if (model.meta.outcomes && model.meta.outcomes.length) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Résultats d\'apprentissage (Bloom)', heading: HeadingLevel.HEADING_1 }));
        model.meta.outcomes.forEach(o => {
            const txt = safe(o.texte || o.text || '');
            const lvl = safe(o.niveau || o.level || '');
            const sub = safe(o.sousNiveau || o.sub || '');
            let prefix = '';
            if (lvl) { prefix = `[${lvl.toUpperCase()}${sub ? ' - ' + sub : ''}] `; }
            if (txt) children.push(new Paragraph({ text: `${prefix}${txt}` }));
        });
    }

    if (safe(model.meta.toolsMaterials)) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Outils et matériel', heading: HeadingLevel.HEADING_1 }));
        lines(model.meta.toolsMaterials).forEach(l => children.push(new Paragraph({ text: l })));
    }


    if (safe(model.meta.toolsMaterialsNotes)) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Notes (outils et matériel)', heading: HeadingLevel.HEADING_1 }));
        lines(model.meta.toolsMaterialsNotes).forEach(l => children.push(new Paragraph({ text: l })));
    }

    if (model.meta.competences && model.meta.competences.length) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Compétences du sujet', heading: HeadingLevel.HEADING_1 }));
        model.meta.competences.forEach(c => {
            const label = safe(c.label || c.id || '');
            const cat = [safe(c.categorie), safe(c.sousCategorie)].filter(Boolean).join(' > ');
            children.push(new Paragraph({ text: cat ? `${label} (${cat})` : label }));
        });
    }

    if (model.meta.competencesTransversales && model.meta.competencesTransversales.length) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Compétences transversales', heading: HeadingLevel.HEADING_1 }));
        model.meta.competencesTransversales.forEach(c => {
            const label = safe(c.label || c.id || '');
            const cat = [safe(c.categorie), safe(c.sousCategorie)].filter(Boolean).join(' > ');
            children.push(new Paragraph({ text: cat ? `${label} (${cat})` : label }));
        });
    }

    children.push(new Paragraph({ text: '' }));
    children.push(new Paragraph({ text: 'Structure pédagogique', heading: HeadingLevel.HEADING_1 }));

    model.modules.forEach((mod, mi) => {
        const moduleIdx = mi + 1;
        const modTitle = safe(mod.title) || `Module ${moduleIdx}`;
        children.push(new Paragraph({ text: `Module ${moduleIdx} : ${modTitle}`, heading: HeadingLevel.HEADING_2 }));
        if (safe(mod.target)) {
            children.push(new Paragraph({ children: [new TextRun({ text: 'Durée cible : ', bold: true }), new TextRun(safe(mod.target))] }));
        }
        if (safe(mod.description)) {
            lines(mod.description).forEach(l => children.push(new Paragraph({ text: l })));
        }
        if (safe(mod.notes)) {
            children.push(new Paragraph({ children: [new TextRun({ text: 'Notes du module : ', bold: true }), new TextRun(safe(mod.notes))] }));
        }

        // Sélections du module (objectifs / résultats / compétences)
        if ((mod.aimsTargets && mod.aimsTargets.length) || (mod.outcomesTargets && mod.outcomesTargets.length) || safe(mod.competencesSujetText) || safe(mod.competencesTransversalesText)) {
            if (mod.aimsTargets && mod.aimsTargets.length) {
                children.push(new Paragraph({ children: [new TextRun({ text: 'Objectifs du module (sélection) : ', bold: true }), new TextRun(mod.aimsTargets.join(' ; '))] }));
            }
            if (mod.outcomesTargets && mod.outcomesTargets.length) {
                children.push(new Paragraph({ children: [new TextRun({ text: 'Résultats du module (sélection) : ', bold: true }), new TextRun(mod.outcomesTargets.join(' ; '))] }));
            }
            if (safe(mod.competencesSujetText)) {
                children.push(new Paragraph({ children: [new TextRun({ text: 'Compétences du module (sujet) : ', bold: true }), new TextRun(safe(mod.competencesSujetText) || '—')] }));
            }
            if (safe(mod.competencesTransversalesText)) {
                children.push(new Paragraph({ children: [new TextRun({ text: 'Compétences du module (transversales) : ', bold: true }), new TextRun(safe(mod.competencesTransversalesText) || '—')] }));
            }
        }

        (mod.moments || []).forEach((mom, mj) => {
            const momentIdx = mj + 1;
            const momTitle = safe(mom.title) || `Moment ${momentIdx}`;
            children.push(new Paragraph({ text: `Moment ${moduleIdx}.${momentIdx} : ${momTitle}`, heading: HeadingLevel.HEADING_3 }));
            if (safe(mom.target)) {
                children.push(new Paragraph({ children: [new TextRun({ text: 'Durée cible : ', bold: true }), new TextRun(safe(mom.target))] }));
            }
            if (safe(mom.description)) {
                lines(mom.description).forEach(l => children.push(new Paragraph({ text: l })));
            }

                        const __submoments = (mom.submoments && mom.submoments.length) ? mom.submoments : [{
                title: '',
                description: '',
                target: '',
                activities: (mom.activities || [])
            }];

            __submoments.forEach((sm, smj) => {
                const smIdx = smj + 1;
                const smTitle = safe(sm.title);
                const smDesc = safe(sm.description);
                const smTarget = safe(sm.target);
                const smHasExplicit = !!(smTitle || smDesc || smTarget);

                if (smHasExplicit) {
                    children.push(new Paragraph({ text: `Sous-moment ${moduleIdx}.${momentIdx}.${smIdx} : ${smTitle || `Sous-moment ${smIdx}`}`, heading: HeadingLevel.HEADING_4 }));
                    if (smTarget) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Durée cible : ', bold: true }), new TextRun(smTarget)] }));
                    }
                    if (smDesc) {
                        lines(smDesc).forEach(l => children.push(new Paragraph({ text: l })));
                    }
                }

                const acts = (sm.activities || []);
                acts.forEach((act, ai) => {
                    const actIdx = ai + 1;
                    const actTitle = safe(act.title) || `Activité ${actIdx}`;
                    const actHeading = smHasExplicit ? HeadingLevel.HEADING_5 : HeadingLevel.HEADING_4;
                    const actPrefix = smHasExplicit ? `${moduleIdx}.${momentIdx}.${smIdx}.${actIdx}` : `${moduleIdx}.${momentIdx}.${actIdx}`;
                    children.push(new Paragraph({ text: `Activité ${actPrefix} : ${actTitle}`, heading: actHeading }));

                    const metaParts = [];
                    if (safe(act.typeLabel)) metaParts.push(`Type : ${safe(act.typeLabel)}`);
                    if (safe(act.groupingLabel)) {
                        const __gBits = [];
                        if (safe(act.groupSize)) __gBits.push(`taille: ${safe(act.groupSize)}`);
                        if (safe(act.groupCount)) __gBits.push(`nb groupes: ${safe(act.groupCount)}`);
                        if (safe(act.groupDetails)) __gBits.push(`détails: ${safe(act.groupDetails)}`);
                        metaParts.push(`Regroupement : ${safe(act.groupingLabel)}${__gBits.length ? ` (${__gBits.join(', ')})` : ''}`);
                    }
                    const modality = [safe(act.trainerLabel), safe(act.placeLabel), safe(act.timeLabel)].filter(Boolean).join(', ');
                    if (modality) metaParts.push(`Modalité : ${modality}`);
                    const evalLabel = safe(act.evaluationLabel || act.evaluationKey || act.evaluation || '');
                    if (evalLabel) metaParts.push(`Évaluation : ${evalLabel}`);
                    if (act.durationMinutes) metaParts.push(`Durée (min) : ${act.durationMinutes}`);

                    if (metaParts.length) {
                        children.push(new Paragraph({ text: metaParts.join(' | ') }));
                    }

                    if (safe(act.objective)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Objectif : ', bold: true }), new TextRun(safe(act.objective))] }));
                    }
                    if (safe(act.aimsTargetsText)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Objectifs ciblés : ', bold: true }), new TextRun(safe(act.aimsTargetsText))] }));
                    }
                    if (safe(act.outcomesTargetsText)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Résultats ciblés : ', bold: true }), new TextRun(safe(act.outcomesTargetsText))] }));
                    }
                    if (safe(act.toolsMaterialsTargetsWithNotesText || act.toolsMaterialsTargetsText)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Outils et matériel (activité) : ', bold: true }), new TextRun(safe(act.toolsMaterialsTargetsWithNotesText || act.toolsMaterialsTargetsText))] }));
                    }
                    if (safe(act.tasks)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Ce que les apprenants doivent faire : ', bold: true }), new TextRun(safe(act.tasks))] }));
                    }
                    if (safe(act.trainerTasks)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Ce que le formateur doit faire : ', bold: true }), new TextRun(safe(act.trainerTasks))] }));
                    }
                    if (safe(act.evaluationSuivi)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Évaluation / suivi : ', bold: true }), new TextRun(safe(act.evaluationSuivi))] }));
                    }
                    if (safe(act.notes)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Notes : ', bold: true }), new TextRun(safe(act.notes))] }));
                    }
                    if (safe(act.linksReferences)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Liens / références : ', bold: true }), new TextRun(safe(act.linksReferences))] }));
                    }
                    // Competences (subject + transversal)
                    if (safe(act.competencesSujetText) || safe(act.competencesTransversalesText)) {
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Compétences du sujet : ', bold: true }), new TextRun(safe(act.competencesSujetText) || '—')] }));
                        children.push(new Paragraph({ children: [new TextRun({ text: 'Compétences transversales : ', bold: true }), new TextRun(safe(act.competencesTransversalesText) || '—')] }));
                    }
                    children.push(new Paragraph({ text: '' }));
                });
            });
        });

        children.push(new Paragraph({ text: '' }));
    });

    const doc = new Document({ sections: [{ properties: {}, children }] });

    Packer.toBlob(doc).then(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = window.__ldBuildExportFilename('docx');
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 500);
    });
}


function __deprecated__exportCSV_1() {
    if (!window.XLSX) {
        showAlert('Erreur', (currentLang === 'en') ? 'Excel export library is not available.' : 'La bibliothèque d’export Excel n’est pas disponible.');
        return;
    }
    // Excel export (.xlsx): modules, moments and activities (activity cards) only.
    // Includes module/moment descriptions and all activity dropdowns + text fields (objectif/tâches/notes).
    const rows = [];
    const header = [
        'Module #',
        'Module titre',
        'Module description',
        'Module durée cible',
        'Moment #',
        'Moment titre',
        'Moment description',
        'Moment durée cible',
        'Activité #',
        'Activité titre',
        'Objectif',
        'Tâches',
        'Notes',
        "Type d'apprentissage",
        'Regroupement',
        'Taille groupe',
        'Détails regroupement',
        'Lieu',
        'Temps',
        'Présence formateur',
        'Durée (min)'
    ];
    rows.push(header);

    const fmtTarget = (timeEl, unitEl) => {
        const v = (timeEl?.value || '').toString().trim();
        const u = unitEl?.selectedOptions?.[0]?.innerText || '';
        if (!v) return '';
        return `${v} ${u}`.trim();
    };

    const getSelectedText = (selectEl) => {
        const opt = selectEl && selectEl.selectedOptions ? selectEl.selectedOptions[0] : null;
        return opt ? (opt.innerText || opt.textContent || '').trim() : '';
    };

    const getGroupingText = (stepEl) => {
        const modeEl = stepEl.querySelector('.step-group-mode');
        const modeTxt = getSelectedText(modeEl);
        const modeVal = modeEl ? modeEl.value : '';
        const sizeVal = (stepEl.querySelector('.step-group-size')?.value || '').toString().trim();
        const detailsVal = (stepEl.querySelector('.step-group-details-notes')?.value || '').toString().trim();
        let txt = modeTxt;
        if (modeVal === 'groups' && sizeVal) txt = `${modeTxt} (${sizeVal})`;
        if (detailsVal) txt = txt ? `${txt} — ${detailsVal}` : detailsVal;
        return { txt, sizeVal, detailsVal };
    };

    const getStepMinutes = (stepEl) => {
        const v = parseFloat(stepEl.querySelector('.duration-input')?.value || 0);
        const unitSecs = parseFloat(stepEl.querySelector('.duration-unit')?.value || 60);
        const secs = (Number.isFinite(v) ? v : 0) * (Number.isFinite(unitSecs) ? unitSecs : 60);
        return Math.round((secs / 60) * 100) / 100;
    };

    let moduleIdx = 0;
    document.querySelectorAll('.activity-group').forEach((moduleEl) => {
        moduleIdx += 1;
        const moduleTitle = (moduleEl.querySelector('.activity-title')?.value || '').trim();
        const moduleDesc = (moduleEl.querySelector('.activity-description')?.value || '').trim();
        const moduleTarget = fmtTarget(moduleEl.querySelector('.activity-target-time'), moduleEl.querySelector('.activity-target-unit'));

        const moments = moduleEl.querySelectorAll('.moment-group');
        if (moments && moments.length) {
            let momentIdx = 0;
            moments.forEach((momentEl) => {
                momentIdx += 1;
                const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                const momentDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                const momentTarget = fmtTarget(momentEl.querySelector('.moment-target-time'), momentEl.querySelector('.moment-target-unit'));

                const steps = momentEl.querySelectorAll('.activity-steps-container .step-card');
                let activityIdx = 0;

                if (steps && steps.length) {
                    steps.forEach((stepEl) => {
                        activityIdx += 1;
                        const stepTitle = (stepEl.querySelector('.step-input-title')?.value || '').trim();
                        const objective = (stepEl.querySelector('.step-input-objective')?.value || '').trim();
                        const tasks = (stepEl.querySelector('.step-input-tasks')?.value || '').trim();
                                                const trainerTasks = (stepEl.querySelector('.step-input-trainer-tasks')?.value || '').trim();
                        const notes = (stepEl.querySelector('.step-input-notes')?.value || '').trim();

                        const typeTxt = getSelectedText(stepEl.querySelector('.learning-type-select'));
                        const placeTxt = getSelectedText(stepEl.querySelector('.place-select'));
                        const timeTxt = getSelectedText(stepEl.querySelector('.time-select'));
                        const trainerTxt = getSelectedText(stepEl.querySelector('.trainer-select'));

                        const grouping = getGroupingText(stepEl);
                        const mins = getStepMinutes(stepEl);

                        rows.push([
                            moduleIdx,
                            moduleTitle,
                            moduleDesc,
                            moduleTarget,
                            momentIdx,
                            momentTitle,
                            momentDesc,
                            momentTarget,
                            activityIdx,
                            stepTitle,
                            objective,
                            tasks,
                            trainerTasks,
                            notes,
                            typeTxt,
                            grouping.txt,
                            grouping.sizeVal,
                            grouping.detailsVal,
                            placeTxt,
                            timeTxt,
                            trainerTxt,
                            mins
                        ]);
                    });
                } else {
                    // moment with no activities
                    rows.push([
                        moduleIdx, moduleTitle, moduleDesc, moduleTarget,
                        momentIdx, momentTitle, momentDesc, momentTarget,
                        '', '', '', '', '', '', '', '', '', '', '', '', ''
                    ]);
                }
            });
        } else {
            // module with no moments
            rows.push([moduleIdx, moduleTitle, moduleDesc, moduleTarget, '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']);
        }
    });

    if (typeof XLSX === 'undefined' || !XLSX.utils) {
        showAlert('Erreur', "La librairie Excel (XLSX) n'est pas disponible. Vérifiez votre connexion ou le chargement des scripts.");
        return;
    }

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'Export');

    const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([out], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = window.__ldBuildExportFilename('xlsx');
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 500);
}

function __deprecated__exportRichText_1() {
             const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            
            // Ensure charts have a measurable width even if the panel is collapsed (display:none)
            const __chartsPanel = document.getElementById('analysis-pane-modalites');
            const __chartsPanelPrev = __chartsPanel ? {
                display: __chartsPanel.style.display,
                visibility: __chartsPanel.style.visibility,
                position: __chartsPanel.style.position,
                left: __chartsPanel.style.left,
                top: __chartsPanel.style.top,
                width: __chartsPanel.style.width
            } : null;

            if (__chartsPanel && (getComputedStyle(__chartsPanel).display === 'none' || __chartsPanel.clientWidth === 0)) {
                __chartsPanel.style.display = 'block';
                __chartsPanel.style.visibility = 'hidden';
                __chartsPanel.style.position = 'absolute';
                __chartsPanel.style.left = '-10000px';
                __chartsPanel.style.top = '0';
                __chartsPanel.style.width = '800px';

                // Trigger chart redraw via the existing delegated listener
                const __trig = document.querySelector('.learning-type-select, .step-group-mode, .place-select, .time-select, .trainer-select');
                if (__trig) __trig.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // --- Capture analysis charts (as embedded images) ---
            const __chartIds = [
                'chart-learning-types',
                'chart-group-modes',
                'chart-place-modes',
                'chart-time-modes',
                'chart-trainer-presence'
            ];

            const __getCanvasPng = (id) => {
                const c = document.getElementById(id);
                if (!c || typeof c.toDataURL !== 'function') return '';
                try { return c.toDataURL('image/png'); } catch (_) { return ''; }
            };

            const __charts = {};
            __chartIds.forEach((id) => { __charts[id] = __getCanvasPng(id); });

            const __legendHtml = (() => {
                const el = document.getElementById('chart-learning-types-legend');
                return el ? __nl2br(el.textContent || '') : '';
            })();

            // Text legends for histogram charts (avoid embedding legends as images)
            const __escapeHtml = (s) => (s == null ? '' : String(s))
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');

            function __getStepDurationSecsFromStep(stepCard) {
                if (!stepCard) return 0;
                const v = Math.max(0, parseFloat(stepCard.querySelector('.duration-input')?.value) || 0);
                const u = Math.max(0, parseFloat(stepCard.querySelector('.duration-unit')?.value) || 0);
                const secs = v * (u || 60);
                return Number.isFinite(secs) ? secs : 0;
            }

            function __tallyHistogramLegend(selector) {
                const first = document.querySelector(selector);
                const options = first && first.options ? Array.from(first.options).filter(o => !o.disabled) : [];

                const sums = new Map();
                options.forEach((o) => {
                    const lab = (o.textContent || '').trim();
                    if (lab) sums.set(lab, 0);
                });

                document.querySelectorAll(selector).forEach((el) => {
                    if (!el) return;
                    const stepCard = el.closest('.step-card');
                    const secs = __getStepDurationSecsFromStep(stepCard);
                    if (secs <= 0) return;
                    const opt = el.options ? el.options[el.selectedIndex] : null;
                    const lab = opt ? (opt.textContent || '').trim() : '';
                    if (!lab) return;
                    if (!sums.has(lab)) sums.set(lab, 0);
                    sums.set(lab, (sums.get(lab) || 0) + secs);
                });

                const total = Array.from(sums.values()).reduce((a, b) => a + (b || 0), 0);
                if (!options.length && !sums.size) return '';

                const orderedLabels = options.length ? options.map(o => (o.textContent || '').trim()).filter(Boolean) : Array.from(sums.keys());

                const items = orderedLabels.map((lab) => {
                    const secs = sums.get(lab) || 0;
                    const pct = total > 0 ? Math.round((secs / total) * 100) : 0;
                    return `<li>${__escapeHtml(lab)} <span style="color:#64748b;">(${pct}%)</span></li>`;
                }).join('');

                return `<div style="margin-top:6px; font-size:12px; color:#334155;"><ul style="margin:0; padding-left:18px;">${items}</ul></div>`;
            }

            const __histLegend = {
                'chart-group-modes': __tallyHistogramLegend('.step-group-mode'),
                'chart-place-modes': __tallyHistogramLegend('.place-select'),
                'chart-time-modes': __tallyHistogramLegend('.time-select'),
                'chart-trainer-presence': __tallyHistogramLegend('.trainer-select')
            };
            // Restore panel styles (do not change the UI state)
            if (__chartsPanel && __chartsPanelPrev) {
                __chartsPanel.style.display = __chartsPanelPrev.display;
                __chartsPanel.style.visibility = __chartsPanelPrev.visibility;
                __chartsPanel.style.position = __chartsPanelPrev.position;
                __chartsPanel.style.left = __chartsPanelPrev.left;
                __chartsPanel.style.top = __chartsPanelPrev.top;
                __chartsPanel.style.width = __chartsPanelPrev.width;
            }


            let html = `
            <!DOCTYPE html>
            <html lang="${currentLang}">
            <head>
                <meta charset="UTF-8">
                <title>${t.rtf_title}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1 { color: #4338ca; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                    h2 { color: #4f46e5; margin-top: 30px; border-left: 4px solid #4f46e5; padding-left: 10px; }
                    h3 { color: #6b7280; margin-top: 20px; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.05em; }
                    h4 { color: #374151; margin-top: 15px; margin-bottom: 5px; }
                    ul { list-style-type: none; padding-left: 0; }
                    li { margin-bottom: 5px; }
                    .meta-item { margin-bottom: 5px; }
                    .meta-label { font-weight: bold; color: #555; }
                    .activity-block { margin-bottom: 40px; border: none; border-radius: 8px; padding: 20px; background-color: #f8fafc; }
                    .step-block { margin-left: 20px; margin-bottom: 20px; padding: 15px; background-color: white; border-left: 4px solid #cbd5e1; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; margin-right: 5px; }
                    .task-box { background-color: #f1f5f9; padding: 10px; border-radius: 4px; margin-top: 10px; font-style: italic; }
                    
                    .type-acquisition { border-color: #a1f5ed; } .bg-none { background-color: #e5e7eb; }
 .bg-acquisition { background-color: #7dded6; color: #0f766e; }
                    .type-collaboration { border-color: #ffd966; } .bg-collaboration { background-color: #f0c953; color: #854d0e; }
                    .type-discussion { border-color: #7aaeea; } .bg-discussion { background-color: #6a9bd6; color: #1e40af; }
                    .type-investigation { border-color: #f8807f; } .bg-investigation { background-color: #e06e6d; color: #991b1b; }
                    .type-practice { border-color: #bb98dc; } .bg-practice { background-color: #a582c6; color: #6b21a8; }
                    .type-production { border-color: #bdea75; } .bg-production { background-color: #a6d15e; color: #3f6212; }
                

  
  #timeline-panel #timeline-activities{ overflow: visible !important; }

</style>
            </head>
            <body>
                <h1>${t.rtf_title}</h1>
                
                <h2 data-i18n="heading_metadata">Métadonnées</h2>
                <div class="meta-item"><span class="meta-label">${t.label_course_name}:</span> ${__esc(document.getElementById('param-name')?.value)}</div>                <div class="meta-item"><span class="meta-label">${t.label_authors}:</span> ${__esc(document.getElementById('param-authors')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_trainers || 'Formateur(s)'}:</span> ${__esc(document.getElementById('param-trainers')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label" data-i18n="label_theme_colon">Thème:</span> ${__esc(document.getElementById('param-topic')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label">${t.label_mode}:</span> ${__selTxt(document.getElementById('param-mode'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_level}:</span> ${__selTxt(document.getElementById('param-level'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_class_size}:</span> ${__esc(document.getElementById('global-class-size')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_total_time}:</span> ${totalDuration}</div>
                <div class="meta-item"><span class="meta-label">${t.label_learning_time}:</span> ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_designed_time}:</span> ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}</div>
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div>
                    ${(__charts['chart-learning-types'] ? `<div style="margin: 10px 0 16px 0;">
                        <h3 style="margin: 10px 0 6px 0;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:8px; font-size: 12px; color:#374151;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__histLegend['chart-group-modes'] || ``)}
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__histLegend['chart-place-modes'] || ``)}
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__histLegend['chart-time-modes'] || ``)}
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__histLegend['chart-trainer-presence'] || ``)}
                    </div>` : ``)}
                </div>

                
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div style="margin: 14px 0 18px 0;">
                    ${(__charts['chart-learning-types'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin-bottom:8px;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:10px; font-size:0.9em; color:#475569;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin-bottom:8px;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin-bottom:8px;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin-bottom:8px;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin-bottom:8px;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px;"/>
                    </div>` : ``)}
                </div>

                <h2>Informations clés</h2>
                <h3>${t.label_description}</h3>
                <p>${__nl2br(document.getElementById('param-description')?.value)}</p>

                <h3>${t.label_target_audience}</h3>
                <p>${__nl2br(document.getElementById('param-target-audience')?.value || '')}</p>

                <h3>${t.label_prerequisites}</h3>
                <p>${__nl2br(document.getElementById('param-prerequisites')?.value || '')}</p>

                <h3>${t.label_tools_materials || 'Outils et matériel'}</h3>
                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <h3>${t.label_aims}</h3>
                <p>${__nl2br(document.getElementById('param-aims')?.value)}</p>

                <h3>${t.label_outcomes_text}</h3>
                <p>${__nl2br(document.getElementById('param-outcomes-text')?.value || '')}</p>

                <h3>${t.label_outcomes}</h3>
                <ul>`;
                
document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomText = "";
                if(level) {
                    bloomText += `<strong>[${__esc(t[`bloom_${level}`] || level.toUpperCase())}`;
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "]</strong> ";
                }
                html += `<li>${bloomText}${__esc(text)}</li>`;
            });

            html += `</ul>

                `;

            

            // --- Analysis charts section ---
            html += `<h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>`;

            // Learning types pie + legend
            if (__charts['chart-learning-types']) {
                html += `
                <h3>Types d'apprentissage</h3>
                <div style="display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap;">
                    <div style="flex:1 1 380px;">
                        <img src="${__charts['chart-learning-types']}" alt="Graphique : types d'apprentissage" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;" />
                    </div>
                    <div style="flex:1 1 240px;">
                        ${__legendHtml ? `<div style="border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:10px;">${__legendHtml}</div>` : ''}
                    </div>
                </div>
                `;
            }

            const __barCharts = [
                ['chart-group-modes', 'Regroupement'],
                ['chart-place-modes', 'Lieu'],
                ['chart-time-modes', 'Temps'],
                ['chart-trainer-presence', 'Présence du formateur']
            ];

            const __barBlocks = __barCharts
                .filter(([id]) => !!__charts[id])
                .map(([id, title]) => `
                    <div style="flex:1 1 320px;">
                        <h4 style="margin-top:10px;">${title}</h4>
                        <img src="${__charts[id]}" alt="Graphique : ${title}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;" />
                    </div>
                `)
                .join('');

            if (__barBlocks) {
                html += `<div style="display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start;">${__barBlocks}</div>`;
            }

            html += `<hr style="border:none; border-top:1px solid #e2e8f0; margin:24px 0;" />`;

            html += `<h2>Structure pédagogique</h2>`;

            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                // Prefix "Module" (FR) without altering any existing translation strings
                let modPrefix = t.md_untitled_activity;
                modPrefix = modPrefix.replace(' sans titre', '');

                html += `<div class="activity-block">
                    <h3 style="color: #1e293b; font-size: 1.2em; border-bottom: 1px solid #cbd5e1; padding-bottom: 10px;">${modPrefix} ${aIdx + 1}: ${__esc(moduleTitle)}</h3>
                    ${moduleDesc ? `<p><em>${__nl2br(moduleDesc)}</em></p>` : ''}`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 6px;"><strong>Durée cible :</strong> ${__esc(moduleTgtVal)} ${__esc(moduleTgtUnitTxt)}</div>`;
                }

                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                    const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                    const __mCs = __idsToLabels(__mCsIds, __compMap);
                    const __mCt = __idsToLabels(__mCtIds, __compTMap);
                    if (__modAims.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 6px;"><strong>Objectifs du module (sélection) :</strong> ${__modAims.map(__esc).join(' ; ')}</div>`;
                    if (__modOut.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Résultats du module (sélection) :</strong> ${__modOut.map(__esc).join(' ; ')}</div>`;
                    if (__mCs.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (sujet) :</strong> ${__mCs.map(__esc).join(', ')}</div>`;
                    if (__mCt.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (transversales) :</strong> ${__mCt.map(__esc).join(', ')}</div>`;
                } catch(_){ __ldSilentErr(_); }

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepsNodeList, momentNumberPrefix) => {
                    stepsNodeList.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title').value || t.md_untitled_step;
                        const groupMode = step.querySelector('.step-group-mode').value;
                        const groupModeEl = step.querySelector('.step-group-mode');
                        const groupModeVal = groupModeEl ? groupModeEl.value : '';
                        const groupModeTxt = groupModeEl && groupModeEl.selectedOptions[0] ? (groupModeEl.selectedOptions[0].innerText || '').trim() : '';
                        const groupSizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const groupCountVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const groupDetailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                        let groupInfo = groupModeTxt;
                        if (groupModeVal === 'groups') {
                            const bits = [];
                            if (groupSizeVal) bits.push(groupSizeVal);
                            if (groupCountVal) bits.push(`nb groupes: ${groupCountVal}`);
                            if (bits.length) groupInfo = `${groupModeTxt} (${bits.join(', ')})`;
                        }
                        if (groupDetailsVal) groupInfo = groupInfo ? `${groupInfo} — ${groupDetailsVal}` : groupDetailsVal;
                        const objective = step.querySelector('.step-input-objective').value || "";
                        const tasks = step.querySelector('.step-input-tasks').value || "";
                        const trainerTasks = step.querySelector('.step-input-trainer-tasks')?.value || "";
                        const evalFollowup = step.querySelector('.step-input-eval-followup')?.value || "";
                        const notes = step.querySelector('.step-input-notes').value || "";

                        const __csSel = step.querySelector('.step-competences-select');
                        const __ctSel = step.querySelector('.step-competences-transversales-select');
                        const __cs = Array.from((__csSel && __csSel.selectedOptions) ? __csSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __ct = Array.from((__ctSel && __ctSel.selectedOptions) ? __ctSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __csTxt = __cs.length ? __cs.map(__esc).join(', ') : '—';
                        const __ctTxt = __ct.length ? __ct.map(__esc).join(', ') : '—';
                        const compSujetHtml = __csTxt;
                        const compTransHtml = __ctTxt;
                        const typeKey = step.querySelector('.learning-type-select').value;
                        const typeLabel = t[`type_${typeKey}`];
                        const trainerText = step.querySelector('.trainer-select').selectedOptions[0].innerText;
                        const placeText = step.querySelector('.place-select').selectedOptions[0].innerText;
                        const timeText = step.querySelector('.time-select').selectedOptions[0].innerText;


                        const durVal = step.querySelector('.duration-input').value;
                        const durUnitTxt = step.querySelector('.duration-unit').selectedOptions[0].innerText;
                        const duration = `${durVal} ${durUnitTxt}`;

                        const activityNumber = `${momentNumberPrefix}.${sIdx + 1}`;

                        html += `<div class="step-block type-${typeKey}">
                            <h4>${activityNumber}. ${__esc(stepTitle)} <span class="tag bg-${typeKey}" style="float: right;">${__esc(typeLabel)}</span></h4>
                            <div style="font-size: 0.9em; color: #64748b; margin-bottom: 10px;">
                                <strong>Durée :</strong> ${duration} | 
                                <strong>Regroupement :</strong> ${groupInfo} | 
                                <strong>Modalité :</strong> ${trainerText}, ${placeText}, ${timeText}<br>
                                <strong>Compétences du sujet :</strong> ${compSujetHtml}<br>
                                <strong>Compétences transversales :</strong> ${compTransHtml}
                                <br><strong>Objectifs ciblés :</strong> ${Array.from(step.querySelector('.step-aims-select')?.selectedOptions || []).map(o => __esc((o.value||'').toString().trim())).filter(Boolean).join(' ; ') || '—'}
                                <br><strong>Résultats ciblés :</strong> ${Array.from(step.querySelector('.step-outcomes-select')?.selectedOptions || []).map(o => __esc((o.value||'').toString().trim())).filter(Boolean).join(' ; ') || '—'}
                                <br><strong>Outils et matériel (activité) :</strong> ${(() => { const parts = (typeof formatSelectedStepToolsMaterialsWithNotes==='function') ? formatSelectedStepToolsMaterialsWithNotes(step) : Array.from(step.querySelector('.step-tools-materials-select')?.selectedOptions || []).map(o => (o.value||'').toString().trim()).filter(Boolean); return parts.map(p => __esc(String(p||'').trim())).filter(Boolean).join(' ; ') || '—'; })()}
                            </div>
                            ${objective ? `<div class="task-box"><strong>Objectif de l'activité:</strong><br>${__nl2br(objective)}</div>` : ''}
                            ${tasks ? `<div class="task-box"><strong>${t.label_tasks}:</strong><br>${__nl2br(tasks)}</div>` : ''}
                            ${trainerTasks ? `<div class="task-box"><strong>Ce que le formateur doit faire :</strong><br>${__nl2br(trainerTasks)}</div>` : ''}
                            ${evalFollowup ? `<div class="task-box"><strong>Évaluation / suivi :</strong><br>${__nl2br(evalFollowup)}</div>` : ''}
                            <div style="margin-top: 10px; font-size: 0.9em; color: #475569;">
                              <strong>Compétences du sujet :</strong> ${__csTxt}<br>
                              <strong>Compétences transversales :</strong> ${__ctTxt}
                            </div>
                            ${notes ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>${t.label_notes}:</strong> ${__nl2br(notes)}</div>` : ''}
                        </div>`;
                    });
                };

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                        const momentSecs = calcMomentSecs(stepCards);

                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;
                        html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                        const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                        const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                        const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        if (mTgtVal) {
                            html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                        }

                        if (mDesc) {
                            html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                        }
                        renderSteps(stepCards, momentPrefix);
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for a complete structure
                    const stepCards = __ldFilterStepNodeList(activity.querySelectorAll('.step-card'));
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;
                    html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                    const mTgtVal0 = (activity.querySelector('.moment-target-time')?.value || '').trim();
                    const mTgtUnitTxt0 = activity.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                    if (mTgtVal0) {
                        html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal0)} ${__esc(mTgtUnitTxt0)}</div>`;
                    }
                    renderSteps(stepCards, momentPrefix);
                }

                html += `</div>`;
            });

            html += `

<!-- Modèles : Export -->




</body></html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('html');
            a.click();
            URL.revokeObjectURL(url);
        }

function __deprecated__exportCSV_2() {
    if (!window.XLSX) {
        showAlert('Erreur', (currentLang === 'en') ? 'Excel export library is not available.' : 'La bibliothèque d’export Excel n’est pas disponible.');
        return;
    }
    // Excel export (.xlsx): modules, moments and activities (activity cards) only.
    // Includes module/moment descriptions and all activity dropdowns + text fields (objectif/tâches/notes).
    const rows = [];
    const header = [
        'Module #',
        'Module titre',
        'Module description',
        'Module durée cible',
        'Moment #',
        'Moment titre',
        'Moment description',
        'Moment durée cible',
        'Activité #',
        'Activité titre',
        'Objectif',
        'Tâches',
        'Notes',
        "Type d'apprentissage",
        'Regroupement',
        'Taille groupe',
        'Détails regroupement',
        'Lieu',
        'Temps',
        'Présence formateur',
        'Durée (min)'
    ];
    rows.push(header);

    const fmtTarget = (timeEl, unitEl) => {
        const v = (timeEl?.value || '').toString().trim();
        const u = unitEl?.selectedOptions?.[0]?.innerText || '';
        if (!v) return '';
        return `${v} ${u}`.trim();
    };

    const getSelectedText = (selectEl) => {
        const opt = selectEl && selectEl.selectedOptions ? selectEl.selectedOptions[0] : null;
        return opt ? (opt.innerText || opt.textContent || '').trim() : '';
    };

    const getGroupingText = (stepEl) => {
        const modeEl = stepEl.querySelector('.step-group-mode');
        const modeTxt = getSelectedText(modeEl);
        const modeVal = modeEl ? modeEl.value : '';
        const sizeVal = (stepEl.querySelector('.step-group-size')?.value || '').toString().trim();
        const detailsVal = (stepEl.querySelector('.step-group-details-notes')?.value || '').toString().trim();
        let txt = modeTxt;
        if (modeVal === 'groups' && sizeVal) txt = `${modeTxt} (${sizeVal})`;
        if (detailsVal) txt = txt ? `${txt} — ${detailsVal}` : detailsVal;
        return { txt, sizeVal, detailsVal };
    };

    const getStepMinutes = (stepEl) => {
        const v = parseFloat(stepEl.querySelector('.duration-input')?.value || 0);
        const unitSecs = parseFloat(stepEl.querySelector('.duration-unit')?.value || 60);
        const secs = (Number.isFinite(v) ? v : 0) * (Number.isFinite(unitSecs) ? unitSecs : 60);
        return Math.round((secs / 60) * 100) / 100;
    };

    let moduleIdx = 0;
    document.querySelectorAll('.activity-group').forEach((moduleEl) => {
        moduleIdx += 1;
        const moduleTitle = (moduleEl.querySelector('.activity-title')?.value || '').trim();
        const moduleDesc = (moduleEl.querySelector('.activity-description')?.value || '').trim();
        const moduleTarget = fmtTarget(moduleEl.querySelector('.activity-target-time'), moduleEl.querySelector('.activity-target-unit'));

        const moments = moduleEl.querySelectorAll('.moment-group');
        if (moments && moments.length) {
            let momentIdx = 0;
            moments.forEach((momentEl) => {
                momentIdx += 1;
                const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                const momentDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                const momentTarget = fmtTarget(momentEl.querySelector('.moment-target-time'), momentEl.querySelector('.moment-target-unit'));

                const steps = momentEl.querySelectorAll('.activity-steps-container .step-card');
                let activityIdx = 0;

                if (steps && steps.length) {
                    steps.forEach((stepEl) => {
                        activityIdx += 1;
                        const stepTitle = (stepEl.querySelector('.step-input-title')?.value || '').trim();
                        const objective = (stepEl.querySelector('.step-input-objective')?.value || '').trim();
                        const tasks = (stepEl.querySelector('.step-input-tasks')?.value || '').trim();
                        const trainerTasks = (stepEl.querySelector('.step-input-trainer-tasks')?.value || '').trim();
                        const evalFollowup = (stepEl.querySelector('.step-input-eval-followup')?.value || '').trim();
                        const notes = (stepEl.querySelector('.step-input-notes')?.value || '').trim();

                        const typeTxt = getSelectedText(stepEl.querySelector('.learning-type-select'));
                        const placeTxt = getSelectedText(stepEl.querySelector('.place-select'));
                        const timeTxt = getSelectedText(stepEl.querySelector('.time-select'));
                        const trainerTxt = getSelectedText(stepEl.querySelector('.trainer-select'));

                        const grouping = getGroupingText(stepEl);
                        const mins = getStepMinutes(stepEl);

                        rows.push([
                            moduleIdx,
                            moduleTitle,
                            moduleDesc,
                            moduleTarget,
                            momentIdx,
                            momentTitle,
                            momentDesc,
                            momentTarget,
                            activityIdx,
                            stepTitle,
                            objective,
                            tasks,
                            notes,
                            typeTxt,
                            grouping.txt,
                            grouping.sizeVal,
                            grouping.detailsVal,
                            placeTxt,
                            timeTxt,
                            trainerTxt,
                            mins
                        ]);
                    });
                } else {
                    // moment with no activities
                    rows.push([
                        moduleIdx, moduleTitle, moduleDesc, moduleTarget,
                        momentIdx, momentTitle, momentDesc, momentTarget,
                        '', '', '', '', '', '', '', '', '', '', '', '', ''
                    ]);
                }
            });
        } else {
            // module with no moments
            rows.push([moduleIdx, moduleTitle, moduleDesc, moduleTarget, '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']);
        }
    });

    if (typeof XLSX === 'undefined' || !XLSX.utils) {
        showAlert('Erreur', "La librairie Excel (XLSX) n'est pas disponible. Vérifiez votre connexion ou le chargement des scripts.");
        return;
    }

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'Export');

    const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([out], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = window.__ldBuildExportFilename('xlsx');
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 500);
}


            


        function __deprecated__exportRichText_2() {
             const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            let html = `
            <!DOCTYPE html>
            <html lang="${currentLang}">
            <head>
                <meta charset="UTF-8">
                <title>${t.rtf_title}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1 { color: #4338ca; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                    h2 { color: #4f46e5; margin-top: 30px; border-left: 4px solid #4f46e5; padding-left: 10px; }
                    h3 { color: #6b7280; margin-top: 20px; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.05em; }
                    h4 { color: #374151; margin-top: 15px; margin-bottom: 5px; }
                    ul { list-style-type: none; padding-left: 0; }
                    li { margin-bottom: 5px; }
                    .meta-item { margin-bottom: 5px; }
                    .meta-label { font-weight: bold; color: #555; }
                    .activity-block { margin-bottom: 40px; border: none; border-radius: 8px; padding: 20px; background-color: #f8fafc; }
                    .step-block { margin-left: 20px; margin-bottom: 20px; padding: 15px; background-color: white; border-left: 4px solid #cbd5e1; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; margin-right: 5px; }
                    .task-box { background-color: #f1f5f9; padding: 10px; border-radius: 4px; margin-top: 10px; font-style: italic; }
                    
                    .type-acquisition { border-color: #a1f5ed; } .bg-none { background-color: #e5e7eb; }
 .bg-acquisition { background-color: #7dded6; color: #0f766e; }
                    .type-collaboration { border-color: #ffd966; } .bg-collaboration { background-color: #f0c953; color: #854d0e; }
                    .type-discussion { border-color: #7aaeea; } .bg-discussion { background-color: #6a9bd6; color: #1e40af; }
                    .type-investigation { border-color: #f8807f; } .bg-investigation { background-color: #e06e6d; color: #991b1b; }
                    .type-practice { border-color: #bb98dc; } .bg-practice { background-color: #a582c6; color: #6b21a8; }
                    .type-production { border-color: #bdea75; } .bg-production { background-color: #a6d15e; color: #3f6212; }
                

  
  #timeline-panel #timeline-activities{ overflow: visible !important; }

</style>
            </head>
            <body>
                <h1>${t.rtf_title}</h1>
                
                <h2 data-i18n="heading_metadata">Métadonnées</h2>
                <div class="meta-item"><span class="meta-label">${t.label_course_name}:</span> ${__esc(document.getElementById('param-name')?.value)}</div>                <div class="meta-item"><span class="meta-label">${t.label_authors}:</span> ${__esc(document.getElementById('param-authors')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_trainers || 'Formateur(s)'}:</span> ${__esc(document.getElementById('param-trainers')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label" data-i18n="label_theme_colon">Thème:</span> ${__esc(document.getElementById('param-topic')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label">${t.label_mode}:</span> ${__selTxt(document.getElementById('param-mode'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_level}:</span> ${__selTxt(document.getElementById('param-level'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_class_size}:</span> ${__esc(document.getElementById('global-class-size')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_total_time}:</span> ${totalDuration}</div>
                <div class="meta-item"><span class="meta-label">${t.label_learning_time}:</span> ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_designed_time}:</span> ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}</div>
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div>
                    ${(__charts['chart-learning-types'] ? `<div style="margin: 10px 0 16px 0;">
                        <h3 style="margin: 10px 0 6px 0;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:8px; font-size: 12px; color:#374151;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                </div>

                
                <h2>Informations clés</h2>
                <h3>${t.label_description}</h3>
                <p>${__nl2br(document.getElementById('param-description')?.value)}</p>

                <h3>${t.label_target_audience}</h3>
                <p>${__nl2br(document.getElementById('param-target-audience')?.value || '')}</p>

                <h3>${t.label_prerequisites}</h3>
                <p>${__nl2br(document.getElementById('param-prerequisites')?.value || '')}</p>

                <h3>${t.label_tools_materials || 'Outils et matériel'}</h3>
                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <h3>${t.label_aims}</h3>
                <p>${__nl2br(document.getElementById('param-aims')?.value)}</p>

                <h3>${t.label_outcomes_text}</h3>
                <p>${__nl2br(document.getElementById('param-outcomes-text')?.value || '')}</p>

                <h3>${t.label_outcomes}</h3>
                <ul>`;
                
document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomText = "";
                if(level) {
                    bloomText += `<strong>[${__esc(t[`bloom_${level}`] || level.toUpperCase())}`;
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "]</strong> ";
                }
                html += `<li>${bloomText}${__esc(text)}</li>`;
            });

            html += `</ul>

                `;

            html += `<h2>Structure pédagogique</h2>`;

            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                // Prefix "Module" (FR) without altering any existing translation strings
                let modPrefix = t.md_untitled_activity;
                modPrefix = modPrefix.replace(' sans titre', '');

                html += `<div class="activity-block">
                    <h3 style="color: #1e293b; font-size: 1.2em; border-bottom: 1px solid #cbd5e1; padding-bottom: 10px;">${modPrefix} ${aIdx + 1}: ${__esc(moduleTitle)}</h3>
                    ${moduleDesc ? `<p><em>${__nl2br(moduleDesc)}</em></p>` : ''}`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 6px;"><strong>Durée cible :</strong> ${__esc(moduleTgtVal)} ${__esc(moduleTgtUnitTxt)}</div>`;
                }

                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                    const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                    const __mCs = __idsToLabels(__mCsIds, __compMap);
                    const __mCt = __idsToLabels(__mCtIds, __compTMap);
                    if (__modAims.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 6px;"><strong>Objectifs du module (sélection) :</strong> ${__modAims.map(__esc).join(' ; ')}</div>`;
                    if (__modOut.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Résultats du module (sélection) :</strong> ${__modOut.map(__esc).join(' ; ')}</div>`;
                    if (__mCs.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (sujet) :</strong> ${__mCs.map(__esc).join(', ')}</div>`;
                    if (__mCt.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (transversales) :</strong> ${__mCt.map(__esc).join(', ')}</div>`;
                } catch(_){ __ldSilentErr(_); }

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepsNodeList, momentNumberPrefix) => {
                    stepsNodeList.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title').value || t.md_untitled_step;
                        const groupMode = step.querySelector('.step-group-mode').value;
                        const groupModeEl = step.querySelector('.step-group-mode');
                        const groupModeVal = groupModeEl ? groupModeEl.value : '';
                        const groupModeTxt = groupModeEl && groupModeEl.selectedOptions[0] ? (groupModeEl.selectedOptions[0].innerText || '').trim() : '';
                        const groupSizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const groupCountVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const groupDetailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                        let groupInfo = groupModeTxt;
                        if (groupModeVal === 'groups') {
                            const bits = [];
                            if (groupSizeVal) bits.push(groupSizeVal);
                            if (groupCountVal) bits.push(`nb groupes: ${groupCountVal}`);
                            if (bits.length) groupInfo = `${groupModeTxt} (${bits.join(', ')})`;
                        }
                        if (groupDetailsVal) groupInfo = groupInfo ? `${groupInfo} — ${groupDetailsVal}` : groupDetailsVal;
                        const objective = step.querySelector('.step-input-objective').value || "";
                        const tasks = step.querySelector('.step-input-tasks').value || "";
                        const trainerTasks = step.querySelector('.step-input-trainer-tasks')?.value || "";
                        const evalFollowup = step.querySelector('.step-input-eval-followup')?.value || "";
                        const notes = step.querySelector('.step-input-notes').value || "";

                        const __csSel = step.querySelector('.step-competences-select');
                        const __ctSel = step.querySelector('.step-competences-transversales-select');
                        const __cs = Array.from((__csSel && __csSel.selectedOptions) ? __csSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __ct = Array.from((__ctSel && __ctSel.selectedOptions) ? __ctSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __csTxt = __cs.length ? __cs.map(__esc).join(', ') : '—';
                        const __ctTxt = __ct.length ? __ct.map(__esc).join(', ') : '—';
                        const compSujetHtml = __csTxt;
                        const compTransHtml = __ctTxt;
                        const typeKey = step.querySelector('.learning-type-select').value;
                        const typeLabel = t[`type_${typeKey}`];
                        const trainerText = step.querySelector('.trainer-select').selectedOptions[0].innerText;
                        const placeText = step.querySelector('.place-select').selectedOptions[0].innerText;
                        const timeText = step.querySelector('.time-select').selectedOptions[0].innerText;

                        const durVal = step.querySelector('.duration-input').value;
                        const durUnitTxt = step.querySelector('.duration-unit').selectedOptions[0].innerText;
                        const duration = `${durVal} ${durUnitTxt}`;

                        const activityNumber = `${momentNumberPrefix}.${sIdx + 1}`;

                        html += `<div class="step-block type-${typeKey}">
                            <h4>${activityNumber}. ${__esc(stepTitle)} <span class="tag bg-${typeKey}" style="float: right;">${__esc(typeLabel)}</span></h4>
                            <div style="font-size: 0.9em; color: #64748b; margin-bottom: 10px;">
                                <strong>Durée :</strong> ${duration} | 
                                <strong>Regroupement :</strong> ${groupInfo} | 
                                <strong>Modalité :</strong> ${trainerText}, ${placeText}, ${timeText}
                            </div>
                            ${objective ? `<div class="task-box"><strong>Objectif de l'activité:</strong><br>${__nl2br(objective)}</div>` : ''}
                            ${tasks ? `<div class="task-box"><strong>${t.label_tasks}:</strong><br>${__nl2br(tasks)}</div>` : ''}
                            ${trainerTasks ? `<div class="task-box"><strong>Ce que le formateur doit faire :</strong><br>${__nl2br(trainerTasks)}</div>` : ''}
                            ${evalFollowup ? `<div class="task-box"><strong>Évaluation / suivi :</strong><br>${__nl2br(evalFollowup)}</div>` : ''}
                            <div style="margin-top: 10px; font-size: 0.9em; color: #475569;">
                              <strong>Compétences du sujet :</strong> ${__csTxt}<br>
                              <strong>Compétences transversales :</strong> ${__ctTxt}
                            </div>
                            ${notes ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>${t.label_notes}:</strong> ${__nl2br(notes)}</div>` : ''}
                        </div>`;
                    });
                };

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                        const momentSecs = calcMomentSecs(stepCards);

                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;
                        html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                        const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                        const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                        const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        if (mTgtVal) {
                            html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                        }

                        if (mDesc) {
                            html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                        }
                        renderSteps(stepCards, momentPrefix);
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for a complete structure
                    const stepCards = __ldFilterStepNodeList(activity.querySelectorAll('.step-card'));
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;
                    html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                    const mTgtVal0 = (activity.querySelector('.moment-target-time')?.value || '').trim();
                    const mTgtUnitTxt0 = activity.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                    if (mTgtVal0) {
                        html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal0)} ${__esc(mTgtUnitTxt0)}</div>`;
                    }
                    renderSteps(stepCards, momentPrefix);
                }

                html += `</div>`;
            });

            html += `
</body></html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('html');
            a.click();
            URL.revokeObjectURL(url);
        }

        function __deprecated__exportRTF_1() {
            const t = translations[currentLang] || translations.fr;
            const totals = getTotals();

            const selText = (el) => (el && el.selectedOptions && el.selectedOptions[0]) ? (el.selectedOptions[0].innerText || '').trim() : '';
            const esc = (s) => escapeRTF((s || '').toString());

            const fmtTarget = (timeEl, unitEl) => {
                const v = (timeEl?.value || '').toString().trim();
                const u = selText(unitEl);
                return v ? `${v} ${u}`.trim() : '';
            };

            const getStepMinutes = (stepEl) => {
                const v = parseFloat(stepEl.querySelector('.duration-input')?.value || 0);
                const unitSecs = parseFloat(stepEl.querySelector('.duration-unit')?.value || 60);
                const secs = (Number.isFinite(v) ? v : 0) * (Number.isFinite(unitSecs) ? unitSecs : 60);
                return Math.round((secs / 60) * 100) / 100;
            };

            const getGroupingText = (stepEl) => {
                const modeEl = stepEl.querySelector('.step-group-mode');
                const modeTxt = selText(modeEl);
                const modeVal = modeEl ? modeEl.value : '';
                const sizeVal = (stepEl.querySelector('.step-group-size')?.value || '').toString().trim();
                const detailsVal = (stepEl.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                let txt = modeTxt;
                if (modeVal === 'groups' && sizeVal) txt = `${modeTxt} (${sizeVal})`;
                if (detailsVal) txt = txt ? `${txt} — ${detailsVal}` : detailsVal;
                return txt;
            };

            let rtf = '{\\rtf1\\ansi\\deff0\n';
            rtf += `{\\b ${esc(t.md_title || 'Plan de formation')}}\\par\n\\par\n`;

            rtf += `{\\b ${esc(t.md_metadata || 'Métadonnées')}}\\par\n`;
            rtf += `${esc(t.label_course_name || 'Nom de la formation')}: ${esc(document.getElementById('param-name')?.value || '')}\\par\n`;
            rtf += `${esc(t.label_authors || 'Auteurs')}: ${esc(document.getElementById('param-authors')?.value || '')}\\par\n`;
            rtf += `${esc(t.label_mode || 'Modalité')}: ${esc(selText(document.getElementById('param-mode')))}\\par\n`;
            rtf += `${esc(t.label_level || 'Niveau')}: ${esc(selText(document.getElementById('param-level')))}\\par\n`;
            rtf += `${esc(t.label_class_size || 'Taille du groupe')}: ${esc(document.getElementById('global-class-size')?.value || '')}\\par\n`;
            rtf += `${esc(t.label_total_time || 'Temps total')}: ${esc(fmtTotalDuration(totals.totalSecs, t))}\\par\n`;
            rtf += `${esc(t.label_learning_time || "Temps d'apprentissage (cible)")}: ${esc(fmtTarget(document.getElementById('param-learning-time'), document.getElementById('param-learning-unit')))}\\par\n`;
            rtf += `${esc(t.label_designed_time || 'Temps conçu (planifié)')}: ${esc(fmtTarget(document.getElementById('param-designed-time'), document.getElementById('param-designed-unit')))}\\par\n`;
            rtf += `Horodatage d'export: ${esc(new Date().toISOString())}\\par\n\\par\n`;

            rtf += `{\\b ${esc(t.md_key_info || 'Informations clés')}}\\par\n`;
            rtf += `{\\b ${esc(t.label_objectives || 'Objectifs')}}\\par\n${esc(document.getElementById('param-aims')?.value || '')}\\par\n\\par\n`;
            rtf += `{\\b ${esc(t.label_outcomes_text || "Résultats d'apprentissage (ce que les apprenants sauront faire)")}}\\par\n${esc(document.getElementById('param-outcomes-text')?.value || '')}\\par\n\\par\n`;

            rtf += `{\\b ${esc(t.label_outcomes || "Résultats d'apprentissage")}}\\par\n`;
            document.querySelectorAll('#outcomes-list li').forEach((li) => {
                const level = (li.querySelector('select')?.value || '').trim();
                const txt = (li.querySelector('input')?.value || '').trim();
                if (txt) rtf += `- ${esc(level)} ${esc(txt)}\\par\n`;
            });
            rtf += '\\par\n';

            rtf += `{\\b ${esc(t.label_description || 'Description générale')}}\\par\n${esc(document.getElementById('param-description')?.value || '')}\\par\n\\par\n`;
            rtf += `{\\b ${esc(t.label_target_audience || 'Public cible')}}\\par\n${esc(document.getElementById('param-audience')?.value || '')}\\par\n\\par\n`;
            rtf += `{\\b ${esc(t.label_prerequisites || 'Prérequis')}}\\par\n${esc(document.getElementById('param-prereq')?.value || '')}\\par\n\\par\n`;

            rtf += `{\\b ${esc(t.md_structure || 'Structure pédagogique')}}\\par\n\\par\n`;

            document.querySelectorAll('.activity-group').forEach((moduleEl, mi) => {
                const moduleTitle = (moduleEl.querySelector('.activity-title')?.value || '').trim() || `Module ${mi+1}`;
                const moduleDesc = (moduleEl.querySelector('.activity-description')?.value || '').trim();
                const moduleTarget = fmtTarget(moduleEl.querySelector('.activity-target-time'), moduleEl.querySelector('.activity-target-unit'));

                rtf += `{\\b Module ${mi+1}: ${esc(moduleTitle)}}\\par\n`;
                if (moduleTarget) rtf += `Durée cible: ${esc(moduleTarget)}\\par\n`;
                if (moduleDesc) rtf += `Description: ${esc(moduleDesc)}\\par\n`;
                rtf += '\\par\n';

                moduleEl.querySelectorAll('.moment-group').forEach((momentEl, mo) => {
                    const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim() || `Moment ${mo+1}`;
                    const momentDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                    const momentTarget = fmtTarget(momentEl.querySelector('.moment-target-time'), momentEl.querySelector('.moment-target-unit'));

                    rtf += `{\\b Moment ${mi+1}.${mo+1}: ${esc(momentTitle)}}\\par\n`;
                    if (momentTarget) rtf += `Durée cible: ${esc(momentTarget)}\\par\n`;
                    if (momentDesc) rtf += `Description: ${esc(momentDesc)}\\par\n`;
                    rtf += '\\par\n';

                    const steps = momentEl.querySelectorAll('.activity-steps-container .step-card');
                    if (!steps || steps.length === 0) {
                        rtf += `(Aucune activité)\\par\n\\par\n`;
                        return;
                    }

                    steps.forEach((stepEl, si) => {
                        const title = (stepEl.querySelector('.step-input-title')?.value || '').trim() || `Activité ${si+1}`;
                        const objective = (stepEl.querySelector('.step-input-objective')?.value || '').trim();
                        const tasks = (stepEl.querySelector('.step-input-tasks')?.value || '').trim();
                        const trainerTasks = (stepEl.querySelector('.step-input-trainer-tasks')?.value || '').trim();
                        const evalFollowup = (stepEl.querySelector('.step-input-eval-followup')?.value || '').trim();
                        const notes = (stepEl.querySelector('.step-input-notes')?.value || '').trim();

                        const typeTxt = selText(stepEl.querySelector('.learning-type-select'));
                        const groupingTxt = getGroupingText(stepEl);
                        const placeTxt = selText(stepEl.querySelector('.place-select'));
                        const timeTxt = selText(stepEl.querySelector('.time-select'));
                        const trainerTxt = selText(stepEl.querySelector('.trainer-select'));
                        const mins = getStepMinutes(stepEl);

                        rtf += `{\\b Activité ${mi+1}.${mo+1}.${si+1}: ${esc(title)}}\\par\n`;
                        rtf += `Durée: ${esc(mins)} min\\par\n`;
                        rtf += `Type d'apprentissage: ${esc(typeTxt)}\\par\n`;
                        rtf += `Regroupement: ${esc(groupingTxt)}\\par\n`;
                        rtf += `Lieu: ${esc(placeTxt)}\\par\n`;
                        rtf += `Temps: ${esc(timeTxt)}\\par\n`;
                        rtf += `Présence formateur: ${esc(trainerTxt)}\\par\n\\par\n`;
                        rtf += `{\\b Objectif:}\\par\n${esc(objective)}\\par\n\\par\n`;
                        rtf += `{\\b Tâches:}\\par\n${esc(tasks)}\\par\n\\par\n`;
                        rtf += `{\\b Notes:}\\par\n${esc(notes)}\\par\n\\par\n`;
                    });
                });
            });

            rtf += '}';
            downloadText(rtf, 'application/rtf;charset=utf-8', `learning-design_${new Date().toISOString().slice(0,10)}.rtf`);
        }

function __deprecated__exportCSV_3() {
    if (!window.XLSX) {
        showAlert('Erreur', (currentLang === 'en') ? 'Excel export library is not available.' : 'La bibliothèque d’export Excel n’est pas disponible.');
        return;
    }
    // Excel export (.xlsx): modules, moments and activities (activity cards) only.
    // Includes module/moment descriptions and all activity dropdowns + text fields (objectif/tâches/notes).
    const rows = [];
    const header = [
        'Module #',
        'Module titre',
        'Module description',
        'Module durée cible',
        'Moment #',
        'Moment titre',
        'Moment description',
        'Moment durée cible',
        'Activité #',
        'Activité titre',
        'Objectif',
        'Tâches',
        'Notes',
        "Type d'apprentissage",
        'Regroupement',
        'Taille groupe',
        'Détails regroupement',
        'Lieu',
        'Temps',
        'Présence formateur',
        'Durée (min)'
    ];
    rows.push(header);

    const fmtTarget = (timeEl, unitEl) => {
        const v = (timeEl?.value || '').toString().trim();
        const u = unitEl?.selectedOptions?.[0]?.innerText || '';
        if (!v) return '';
        return `${v} ${u}`.trim();
    };

    const getSelectedText = (selectEl) => {
        const opt = selectEl && selectEl.selectedOptions ? selectEl.selectedOptions[0] : null;
        return opt ? (opt.innerText || opt.textContent || '').trim() : '';
    };

    const getGroupingText = (stepEl) => {
        const modeEl = stepEl.querySelector('.step-group-mode');
        const modeTxt = getSelectedText(modeEl);
        const modeVal = modeEl ? modeEl.value : '';
        const sizeVal = (stepEl.querySelector('.step-group-size')?.value || '').toString().trim();
        const detailsVal = (stepEl.querySelector('.step-group-details-notes')?.value || '').toString().trim();
        let txt = modeTxt;
        if (modeVal === 'groups' && sizeVal) txt = `${modeTxt} (${sizeVal})`;
        if (detailsVal) txt = txt ? `${txt} — ${detailsVal}` : detailsVal;
        return { txt, sizeVal, detailsVal };
    };

    const getStepMinutes = (stepEl) => {
        const v = parseFloat(stepEl.querySelector('.duration-input')?.value || 0);
        const unitSecs = parseFloat(stepEl.querySelector('.duration-unit')?.value || 60);
        const secs = (Number.isFinite(v) ? v : 0) * (Number.isFinite(unitSecs) ? unitSecs : 60);
        return Math.round((secs / 60) * 100) / 100;
    };

    let moduleIdx = 0;
    document.querySelectorAll('.activity-group').forEach((moduleEl) => {
        moduleIdx += 1;
        const moduleTitle = (moduleEl.querySelector('.activity-title')?.value || '').trim();
        const moduleDesc = (moduleEl.querySelector('.activity-description')?.value || '').trim();
        const moduleTarget = fmtTarget(moduleEl.querySelector('.activity-target-time'), moduleEl.querySelector('.activity-target-unit'));

        const moments = moduleEl.querySelectorAll('.moment-group');
        if (moments && moments.length) {
            let momentIdx = 0;
            moments.forEach((momentEl) => {
                momentIdx += 1;
                const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                const momentDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                const momentTarget = fmtTarget(momentEl.querySelector('.moment-target-time'), momentEl.querySelector('.moment-target-unit'));

                const steps = momentEl.querySelectorAll('.activity-steps-container .step-card');
                let activityIdx = 0;

                if (steps && steps.length) {
                    steps.forEach((stepEl) => {
                        activityIdx += 1;
                        const stepTitle = (stepEl.querySelector('.step-input-title')?.value || '').trim();
                        const objective = (stepEl.querySelector('.step-input-objective')?.value || '').trim();
                        const tasks = (stepEl.querySelector('.step-input-tasks')?.value || '').trim();
                        const trainerTasks = (stepEl.querySelector('.step-input-trainer-tasks')?.value || '').trim();
                        const evalFollowup = (stepEl.querySelector('.step-input-eval-followup')?.value || '').trim();
                        const notes = (stepEl.querySelector('.step-input-notes')?.value || '').trim();

                        const typeTxt = getSelectedText(stepEl.querySelector('.learning-type-select'));
                        const placeTxt = getSelectedText(stepEl.querySelector('.place-select'));
                        const timeTxt = getSelectedText(stepEl.querySelector('.time-select'));
                        const trainerTxt = getSelectedText(stepEl.querySelector('.trainer-select'));

                        const grouping = getGroupingText(stepEl);
                        const mins = getStepMinutes(stepEl);

                        rows.push([
                            moduleIdx,
                            moduleTitle,
                            moduleDesc,
                            moduleTarget,
                            momentIdx,
                            momentTitle,
                            momentDesc,
                            momentTarget,
                            activityIdx,
                            stepTitle,
                            objective,
                            tasks,
                            notes,
                            typeTxt,
                            grouping.txt,
                            grouping.sizeVal,
                            grouping.detailsVal,
                            placeTxt,
                            timeTxt,
                            trainerTxt,
                            mins
                        ]);
                    });
                } else {
                    // moment with no activities
                    rows.push([
                        moduleIdx, moduleTitle, moduleDesc, moduleTarget,
                        momentIdx, momentTitle, momentDesc, momentTarget,
                        '', '', '', '', '', '', '', '', '', '', '', '', ''
                    ]);
                }
            });
        } else {
            // module with no moments
            rows.push([moduleIdx, moduleTitle, moduleDesc, moduleTarget, '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']);
        }
    });

    if (typeof XLSX === 'undefined' || !XLSX.utils) {
        showAlert('Erreur', "La librairie Excel (XLSX) n'est pas disponible. Vérifiez votre connexion ou le chargement des scripts.");
        return;
    }

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'Export');

    const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([out], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = window.__ldBuildExportFilename('xlsx');
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 500);
}


            


        function __deprecated__exportRichText_3() {
             const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            let html = `
            <!DOCTYPE html>
            <html lang="${currentLang}">
            <head>
                <meta charset="UTF-8">
                <title>${t.rtf_title}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1 { color: #4338ca; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                    h2 { color: #4f46e5; margin-top: 30px; border-left: 4px solid #4f46e5; padding-left: 10px; }
                    h3 { color: #6b7280; margin-top: 20px; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.05em; }
                    h4 { color: #374151; margin-top: 15px; margin-bottom: 5px; }
                    ul { list-style-type: none; padding-left: 0; }
                    li { margin-bottom: 5px; }
                    .meta-item { margin-bottom: 5px; }
                    .meta-label { font-weight: bold; color: #555; }
                    .activity-block { margin-bottom: 40px; border: none; border-radius: 8px; padding: 20px; background-color: #f8fafc; }
                    .step-block { margin-left: 20px; margin-bottom: 20px; padding: 15px; background-color: white; border-left: 4px solid #cbd5e1; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; margin-right: 5px; }
                    .task-box { background-color: #f1f5f9; padding: 10px; border-radius: 4px; margin-top: 10px; font-style: italic; }
                    
                    .type-acquisition { border-color: #a1f5ed; } .bg-none { background-color: #e5e7eb; }
 .bg-acquisition { background-color: #7dded6; color: #0f766e; }
                    .type-collaboration { border-color: #ffd966; } .bg-collaboration { background-color: #f0c953; color: #854d0e; }
                    .type-discussion { border-color: #7aaeea; } .bg-discussion { background-color: #6a9bd6; color: #1e40af; }
                    .type-investigation { border-color: #f8807f; } .bg-investigation { background-color: #e06e6d; color: #991b1b; }
                    .type-practice { border-color: #bb98dc; } .bg-practice { background-color: #a582c6; color: #6b21a8; }
                    .type-production { border-color: #bdea75; } .bg-production { background-color: #a6d15e; color: #3f6212; }
                

  
  #timeline-panel #timeline-activities{ overflow: visible !important; }

</style>
            </head>
            <body>
                <h1>${t.rtf_title}</h1>
                
                <h2 data-i18n="heading_metadata">Métadonnées</h2>
                <div class="meta-item"><span class="meta-label">${t.label_course_name}:</span> ${__esc(document.getElementById('param-name')?.value)}</div>                <div class="meta-item"><span class="meta-label">${t.label_authors}:</span> ${__esc(document.getElementById('param-authors')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_trainers || 'Formateur(s)'}:</span> ${__esc(document.getElementById('param-trainers')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label" data-i18n="label_theme_colon">Thème:</span> ${__esc(document.getElementById('param-topic')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label">${t.label_mode}:</span> ${__selTxt(document.getElementById('param-mode'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_level}:</span> ${__selTxt(document.getElementById('param-level'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_class_size}:</span> ${__esc(document.getElementById('global-class-size')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_total_time}:</span> ${totalDuration}</div>
                <div class="meta-item"><span class="meta-label">${t.label_learning_time}:</span> ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_designed_time}:</span> ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}</div>
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div>
                    ${(__charts['chart-learning-types'] ? `<div style="margin: 10px 0 16px 0;">
                        <h3 style="margin: 10px 0 6px 0;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:8px; font-size: 12px; color:#374151;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                </div>

                
                <h2>Informations clés</h2>
                <h3>${t.label_description}</h3>
                <p>${__nl2br(document.getElementById('param-description')?.value)}</p>

                <h3>${t.label_target_audience}</h3>
                <p>${__nl2br(document.getElementById('param-target-audience')?.value || '')}</p>

                <h3>${t.label_prerequisites}</h3>
                <p>${__nl2br(document.getElementById('param-prerequisites')?.value || '')}</p>

                <h3>${t.label_tools_materials || 'Outils et matériel'}</h3>
                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <h3>${t.label_aims}</h3>
                <p>${__nl2br(document.getElementById('param-aims')?.value)}</p>

                <h3>${t.label_outcomes_text}</h3>
                <p>${__nl2br(document.getElementById('param-outcomes-text')?.value || '')}</p>

                <h3>${t.label_outcomes}</h3>
                <ul>`;
                
document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomText = "";
                if(level) {
                    bloomText += `<strong>[${__esc(t[`bloom_${level}`] || level.toUpperCase())}`;
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "]</strong> ";
                }
                html += `<li>${bloomText}${__esc(text)}</li>`;
            });

            html += `</ul>

                `;

            html += `<h2>Structure pédagogique</h2>`;

            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                // Prefix "Module" (FR) without altering any existing translation strings
                let modPrefix = t.md_untitled_activity;
                modPrefix = modPrefix.replace(' sans titre', '');

                html += `<div class="activity-block">
                    <h3 style="color: #1e293b; font-size: 1.2em; border-bottom: 1px solid #cbd5e1; padding-bottom: 10px;">${modPrefix} ${aIdx + 1}: ${__esc(moduleTitle)}</h3>
                    ${moduleDesc ? `<p><em>${__nl2br(moduleDesc)}</em></p>` : ''}`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 6px;"><strong>Durée cible :</strong> ${__esc(moduleTgtVal)} ${__esc(moduleTgtUnitTxt)}</div>`;
                }

                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                    const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                    const __mCs = __idsToLabels(__mCsIds, __compMap);
                    const __mCt = __idsToLabels(__mCtIds, __compTMap);
                    if (__modAims.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 6px;"><strong>Objectifs du module (sélection) :</strong> ${__modAims.map(__esc).join(' ; ')}</div>`;
                    if (__modOut.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Résultats du module (sélection) :</strong> ${__modOut.map(__esc).join(' ; ')}</div>`;
                    if (__mCs.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (sujet) :</strong> ${__mCs.map(__esc).join(', ')}</div>`;
                    if (__mCt.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (transversales) :</strong> ${__mCt.map(__esc).join(', ')}</div>`;
                } catch(_){ __ldSilentErr(_); }

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepsNodeList, momentNumberPrefix) => {
                    stepsNodeList.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title').value || t.md_untitled_step;
                        const groupMode = step.querySelector('.step-group-mode').value;
                        const groupModeEl = step.querySelector('.step-group-mode');
                        const groupModeVal = groupModeEl ? groupModeEl.value : '';
                        const groupModeTxt = groupModeEl && groupModeEl.selectedOptions[0] ? (groupModeEl.selectedOptions[0].innerText || '').trim() : '';
                        const groupSizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const groupCountVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const groupDetailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                        let groupInfo = groupModeTxt;
                        if (groupModeVal === 'groups') {
                            const bits = [];
                            if (groupSizeVal) bits.push(groupSizeVal);
                            if (groupCountVal) bits.push(`nb groupes: ${groupCountVal}`);
                            if (bits.length) groupInfo = `${groupModeTxt} (${bits.join(', ')})`;
                        }
                        if (groupDetailsVal) groupInfo = groupInfo ? `${groupInfo} — ${groupDetailsVal}` : groupDetailsVal;
                        const objective = step.querySelector('.step-input-objective').value || "";
                        const tasks = step.querySelector('.step-input-tasks').value || "";
                        const trainerTasks = step.querySelector('.step-input-trainer-tasks')?.value || "";
                        const evalFollowup = step.querySelector('.step-input-eval-followup')?.value || "";
                        const notes = step.querySelector('.step-input-notes').value || "";

                        const __csSel = step.querySelector('.step-competences-select');
                        const __ctSel = step.querySelector('.step-competences-transversales-select');
                        const __cs = Array.from((__csSel && __csSel.selectedOptions) ? __csSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __ct = Array.from((__ctSel && __ctSel.selectedOptions) ? __ctSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __csTxt = __cs.length ? __cs.map(__esc).join(', ') : '—';
                        const __ctTxt = __ct.length ? __ct.map(__esc).join(', ') : '—';
                        const compSujetHtml = __csTxt;
                        const compTransHtml = __ctTxt;
                        const typeKey = step.querySelector('.learning-type-select').value;
                        const typeLabel = t[`type_${typeKey}`];
                        const trainerText = step.querySelector('.trainer-select').selectedOptions[0].innerText;
                        const placeText = step.querySelector('.place-select').selectedOptions[0].innerText;
                        const timeText = step.querySelector('.time-select').selectedOptions[0].innerText;

                        const durVal = step.querySelector('.duration-input').value;
                        const durUnitTxt = step.querySelector('.duration-unit').selectedOptions[0].innerText;
                        const duration = `${durVal} ${durUnitTxt}`;

                        const activityNumber = `${momentNumberPrefix}.${sIdx + 1}`;

                        html += `<div class="step-block type-${typeKey}">
                            <h4>${activityNumber}. ${__esc(stepTitle)} <span class="tag bg-${typeKey}" style="float: right;">${__esc(typeLabel)}</span></h4>
                            <div style="font-size: 0.9em; color: #64748b; margin-bottom: 10px;">
                                <strong>Durée :</strong> ${duration} | 
                                <strong>Regroupement :</strong> ${groupInfo} | 
                                <strong>Modalité :</strong> ${trainerText}, ${placeText}, ${timeText}
                            </div>
                            ${objective ? `<div class="task-box"><strong>Objectif de l'activité:</strong><br>${__nl2br(objective)}</div>` : ''}
                            ${tasks ? `<div class="task-box"><strong>${t.label_tasks}:</strong><br>${__nl2br(tasks)}</div>` : ''}
                            ${trainerTasks ? `<div class="task-box"><strong>Ce que le formateur doit faire :</strong><br>${__nl2br(trainerTasks)}</div>` : ''}
                            ${evalFollowup ? `<div class="task-box"><strong>Évaluation / suivi :</strong><br>${__nl2br(evalFollowup)}</div>` : ''}
                            <div style="margin-top: 10px; font-size: 0.9em; color: #475569;">
                              <strong>Compétences du sujet :</strong> ${__csTxt}<br>
                              <strong>Compétences transversales :</strong> ${__ctTxt}
                            </div>
                            ${notes ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>${t.label_notes}:</strong> ${__nl2br(notes)}</div>` : ''}
                        </div>`;
                    });
                };

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                        const momentSecs = calcMomentSecs(stepCards);

                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;
                        html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                        const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                        const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                        const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        if (mTgtVal) {
                            html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                        }

                        if (mDesc) {
                            html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                        }
                        renderSteps(stepCards, momentPrefix);
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for a complete structure
                    const stepCards = __ldFilterStepNodeList(activity.querySelectorAll('.step-card'));
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;
                    html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                    const mTgtVal0 = (activity.querySelector('.moment-target-time')?.value || '').trim();
                    const mTgtUnitTxt0 = activity.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                    if (mTgtVal0) {
                        html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal0)} ${__esc(mTgtUnitTxt0)}</div>`;
                    }
                    renderSteps(stepCards, momentPrefix);
                }

                html += `</div>`;
            });

            html += `
</body></html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('html');
            a.click();
            URL.revokeObjectURL(url);
        }

function __deprecated__exportCSV_4() {
    if (!window.XLSX) {
        showAlert('Erreur', (currentLang === 'en') ? 'Excel export library is not available.' : 'La bibliothèque d’export Excel n’est pas disponible.');
        return;
    }
    // Excel export (.xlsx): modules, moments and activities (activity cards) only.
    // Includes module/moment descriptions and all activity dropdowns + text fields (objectif/tâches/notes).
    const rows = [];
    const header = [
        'Module #',
        'Module titre',
        'Module description',
        'Module durée cible',
        'Moment #',
        'Moment titre',
        'Moment description',
        'Moment durée cible',
        'Activité #',
        'Activité titre',
        'Objectif',
        'Tâches',
        'Notes',
        "Type d'apprentissage",
        'Regroupement',
        'Taille groupe',
        'Détails regroupement',
        'Lieu',
        'Temps',
        'Présence formateur',
        'Durée (min)'
    ];
    rows.push(header);

    const fmtTarget = (timeEl, unitEl) => {
        const v = (timeEl?.value || '').toString().trim();
        const u = unitEl?.selectedOptions?.[0]?.innerText || '';
        if (!v) return '';
        return `${v} ${u}`.trim();
    };

    const getSelectedText = (selectEl) => {
        const opt = selectEl && selectEl.selectedOptions ? selectEl.selectedOptions[0] : null;
        return opt ? (opt.innerText || opt.textContent || '').trim() : '';
    };

    const getGroupingText = (stepEl) => {
        const modeEl = stepEl.querySelector('.step-group-mode');
        const modeTxt = getSelectedText(modeEl);
        const modeVal = modeEl ? modeEl.value : '';
        const sizeVal = (stepEl.querySelector('.step-group-size')?.value || '').toString().trim();
        const detailsVal = (stepEl.querySelector('.step-group-details-notes')?.value || '').toString().trim();
        let txt = modeTxt;
        if (modeVal === 'groups' && sizeVal) txt = `${modeTxt} (${sizeVal})`;
        if (detailsVal) txt = txt ? `${txt} — ${detailsVal}` : detailsVal;
        return { txt, sizeVal, detailsVal };
    };

    const getStepMinutes = (stepEl) => {
        const v = parseFloat(stepEl.querySelector('.duration-input')?.value || 0);
        const unitSecs = parseFloat(stepEl.querySelector('.duration-unit')?.value || 60);
        const secs = (Number.isFinite(v) ? v : 0) * (Number.isFinite(unitSecs) ? unitSecs : 60);
        return Math.round((secs / 60) * 100) / 100;
    };

    let moduleIdx = 0;
    document.querySelectorAll('.activity-group').forEach((moduleEl) => {
        moduleIdx += 1;
        const moduleTitle = (moduleEl.querySelector('.activity-title')?.value || '').trim();
        const moduleDesc = (moduleEl.querySelector('.activity-description')?.value || '').trim();
        const moduleTarget = fmtTarget(moduleEl.querySelector('.activity-target-time'), moduleEl.querySelector('.activity-target-unit'));

        const moments = moduleEl.querySelectorAll('.moment-group');
        if (moments && moments.length) {
            let momentIdx = 0;
            moments.forEach((momentEl) => {
                momentIdx += 1;
                const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                const momentDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                const momentTarget = fmtTarget(momentEl.querySelector('.moment-target-time'), momentEl.querySelector('.moment-target-unit'));

                const steps = momentEl.querySelectorAll('.activity-steps-container .step-card');
                let activityIdx = 0;

                if (steps && steps.length) {
                    steps.forEach((stepEl) => {
                        activityIdx += 1;
                        const stepTitle = (stepEl.querySelector('.step-input-title')?.value || '').trim();
                        const objective = (stepEl.querySelector('.step-input-objective')?.value || '').trim();
                        const tasks = (stepEl.querySelector('.step-input-tasks')?.value || '').trim();
                        const trainerTasks = (stepEl.querySelector('.step-input-trainer-tasks')?.value || '').trim();
                        const evalFollowup = (stepEl.querySelector('.step-input-eval-followup')?.value || '').trim();
                        const notes = (stepEl.querySelector('.step-input-notes')?.value || '').trim();

                        const typeTxt = getSelectedText(stepEl.querySelector('.learning-type-select'));
                        const placeTxt = getSelectedText(stepEl.querySelector('.place-select'));
                        const timeTxt = getSelectedText(stepEl.querySelector('.time-select'));
                        const trainerTxt = getSelectedText(stepEl.querySelector('.trainer-select'));

                        const grouping = getGroupingText(stepEl);
                        const mins = getStepMinutes(stepEl);

                        rows.push([
                            moduleIdx,
                            moduleTitle,
                            moduleDesc,
                            moduleTarget,
                            momentIdx,
                            momentTitle,
                            momentDesc,
                            momentTarget,
                            activityIdx,
                            stepTitle,
                            objective,
                            tasks,
                            notes,
                            typeTxt,
                            grouping.txt,
                            grouping.sizeVal,
                            grouping.detailsVal,
                            placeTxt,
                            timeTxt,
                            trainerTxt,
                            mins
                        ]);
                    });
                } else {
                    // moment with no activities
                    rows.push([
                        moduleIdx, moduleTitle, moduleDesc, moduleTarget,
                        momentIdx, momentTitle, momentDesc, momentTarget,
                        '', '', '', '', '', '', '', '', '', '', '', '', ''
                    ]);
                }
            });
        } else {
            // module with no moments
            rows.push([moduleIdx, moduleTitle, moduleDesc, moduleTarget, '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']);
        }
    });

    if (typeof XLSX === 'undefined' || !XLSX.utils) {
        showAlert('Erreur', "La librairie Excel (XLSX) n'est pas disponible. Vérifiez votre connexion ou le chargement des scripts.");
        return;
    }

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'Export');

    const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([out], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = window.__ldBuildExportFilename('xlsx');
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 500);
}


            


        function __deprecated__exportRichText_4() {
             const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            let html = `
            <!DOCTYPE html>
            <html lang="${currentLang}">
            <head>
                <meta charset="UTF-8">
                <title>${t.rtf_title}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1 { color: #4338ca; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                    h2 { color: #4f46e5; margin-top: 30px; border-left: 4px solid #4f46e5; padding-left: 10px; }
                    h3 { color: #6b7280; margin-top: 20px; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.05em; }
                    h4 { color: #374151; margin-top: 15px; margin-bottom: 5px; }
                    ul { list-style-type: none; padding-left: 0; }
                    li { margin-bottom: 5px; }
                    .meta-item { margin-bottom: 5px; }
                    .meta-label { font-weight: bold; color: #555; }
                    .activity-block { margin-bottom: 40px; border: none; border-radius: 8px; padding: 20px; background-color: #f8fafc; }
                    .step-block { margin-left: 20px; margin-bottom: 20px; padding: 15px; background-color: white; border-left: 4px solid #cbd5e1; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; margin-right: 5px; }
                    .task-box { background-color: #f1f5f9; padding: 10px; border-radius: 4px; margin-top: 10px; font-style: italic; }
                    
                    .type-acquisition { border-color: #a1f5ed; } .bg-none { background-color: #e5e7eb; }
 .bg-acquisition { background-color: #7dded6; color: #0f766e; }
                    .type-collaboration { border-color: #ffd966; } .bg-collaboration { background-color: #f0c953; color: #854d0e; }
                    .type-discussion { border-color: #7aaeea; } .bg-discussion { background-color: #6a9bd6; color: #1e40af; }
                    .type-investigation { border-color: #f8807f; } .bg-investigation { background-color: #e06e6d; color: #991b1b; }
                    .type-practice { border-color: #bb98dc; } .bg-practice { background-color: #a582c6; color: #6b21a8; }
                    .type-production { border-color: #bdea75; } .bg-production { background-color: #a6d15e; color: #3f6212; }
                

  
  #timeline-panel #timeline-activities{ overflow: visible !important; }

</style>
            </head>
            <body>
                <h1>${t.rtf_title}</h1>
                
                <h2 data-i18n="heading_metadata">Métadonnées</h2>
                <div class="meta-item"><span class="meta-label">${t.label_course_name}:</span> ${__esc(document.getElementById('param-name')?.value)}</div>                <div class="meta-item"><span class="meta-label">${t.label_authors}:</span> ${__esc(document.getElementById('param-authors')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_trainers || 'Formateur(s)'}:</span> ${__esc(document.getElementById('param-trainers')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label" data-i18n="label_theme_colon">Thème:</span> ${__esc(document.getElementById('param-topic')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label">${t.label_mode}:</span> ${__selTxt(document.getElementById('param-mode'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_level}:</span> ${__selTxt(document.getElementById('param-level'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_class_size}:</span> ${__esc(document.getElementById('global-class-size')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_total_time}:</span> ${totalDuration}</div>
                <div class="meta-item"><span class="meta-label">${t.label_learning_time}:</span> ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_designed_time}:</span> ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}</div>
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div>
                    ${(__charts['chart-learning-types'] ? `<div style="margin: 10px 0 16px 0;">
                        <h3 style="margin: 10px 0 6px 0;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:8px; font-size: 12px; color:#374151;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                </div>

                
                <h2>Informations clés</h2>
                <h3>${t.label_description}</h3>
                <p>${__nl2br(document.getElementById('param-description')?.value)}</p>

                <h3>${t.label_target_audience}</h3>
                <p>${__nl2br(document.getElementById('param-target-audience')?.value || '')}</p>

                <h3>${t.label_prerequisites}</h3>
                <p>${__nl2br(document.getElementById('param-prerequisites')?.value || '')}</p>

                <h3>${t.label_tools_materials || 'Outils et matériel'}</h3>
                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <h3>${t.label_aims}</h3>
                <p>${__nl2br(document.getElementById('param-aims')?.value)}</p>

                <h3>${t.label_outcomes_text}</h3>
                <p>${__nl2br(document.getElementById('param-outcomes-text')?.value || '')}</p>

                <h3>${t.label_outcomes}</h3>
                <ul>`;
                
document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomText = "";
                if(level) {
                    bloomText += `<strong>[${__esc(t[`bloom_${level}`] || level.toUpperCase())}`;
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "]</strong> ";
                }
                html += `<li>${bloomText}${__esc(text)}</li>`;
            });

            html += `</ul>

                `;

            html += `<h2>Structure pédagogique</h2>`;

            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                // Prefix "Module" (FR) without altering any existing translation strings
                let modPrefix = t.md_untitled_activity;
                modPrefix = modPrefix.replace(' sans titre', '');

                html += `<div class="activity-block">
                    <h3 style="color: #1e293b; font-size: 1.2em; border-bottom: 1px solid #cbd5e1; padding-bottom: 10px;">${modPrefix} ${aIdx + 1}: ${__esc(moduleTitle)}</h3>
                    ${moduleDesc ? `<p><em>${__nl2br(moduleDesc)}</em></p>` : ''}`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 6px;"><strong>Durée cible :</strong> ${__esc(moduleTgtVal)} ${__esc(moduleTgtUnitTxt)}</div>`;
                }

                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                    const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                    const __mCs = __idsToLabels(__mCsIds, __compMap);
                    const __mCt = __idsToLabels(__mCtIds, __compTMap);
                    if (__modAims.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 6px;"><strong>Objectifs du module (sélection) :</strong> ${__modAims.map(__esc).join(' ; ')}</div>`;
                    if (__modOut.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Résultats du module (sélection) :</strong> ${__modOut.map(__esc).join(' ; ')}</div>`;
                    if (__mCs.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (sujet) :</strong> ${__mCs.map(__esc).join(', ')}</div>`;
                    if (__mCt.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (transversales) :</strong> ${__mCt.map(__esc).join(', ')}</div>`;
                } catch(_){ __ldSilentErr(_); }

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepsNodeList, momentNumberPrefix) => {
                    stepsNodeList.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title').value || t.md_untitled_step;
                        const groupMode = step.querySelector('.step-group-mode').value;
                        const groupModeEl = step.querySelector('.step-group-mode');
                        const groupModeVal = groupModeEl ? groupModeEl.value : '';
                        const groupModeTxt = groupModeEl && groupModeEl.selectedOptions[0] ? (groupModeEl.selectedOptions[0].innerText || '').trim() : '';
                        const groupSizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const groupCountVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const groupDetailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                        let groupInfo = groupModeTxt;
                        if (groupModeVal === 'groups') {
                            const bits = [];
                            if (groupSizeVal) bits.push(groupSizeVal);
                            if (groupCountVal) bits.push(`nb groupes: ${groupCountVal}`);
                            if (bits.length) groupInfo = `${groupModeTxt} (${bits.join(', ')})`;
                        }
                        if (groupDetailsVal) groupInfo = groupInfo ? `${groupInfo} — ${groupDetailsVal}` : groupDetailsVal;
                        const objective = step.querySelector('.step-input-objective').value || "";
                        const tasks = step.querySelector('.step-input-tasks').value || "";
                        const trainerTasks = step.querySelector('.step-input-trainer-tasks')?.value || "";
                        const evalFollowup = step.querySelector('.step-input-eval-followup')?.value || "";
                        const notes = step.querySelector('.step-input-notes').value || "";

                        const __csSel = step.querySelector('.step-competences-select');
                        const __ctSel = step.querySelector('.step-competences-transversales-select');
                        const __cs = Array.from((__csSel && __csSel.selectedOptions) ? __csSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __ct = Array.from((__ctSel && __ctSel.selectedOptions) ? __ctSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __csTxt = __cs.length ? __cs.map(__esc).join(', ') : '—';
                        const __ctTxt = __ct.length ? __ct.map(__esc).join(', ') : '—';
                        const compSujetHtml = __csTxt;
                        const compTransHtml = __ctTxt;
                        const typeKey = step.querySelector('.learning-type-select').value;
                        const typeLabel = t[`type_${typeKey}`];
                        const trainerText = step.querySelector('.trainer-select').selectedOptions[0].innerText;
                        const placeText = step.querySelector('.place-select').selectedOptions[0].innerText;
                        const timeText = step.querySelector('.time-select').selectedOptions[0].innerText;

                        const durVal = step.querySelector('.duration-input').value;
                        const durUnitTxt = step.querySelector('.duration-unit').selectedOptions[0].innerText;
                        const duration = `${durVal} ${durUnitTxt}`;

                        const activityNumber = `${momentNumberPrefix}.${sIdx + 1}`;

                        html += `<div class="step-block type-${typeKey}">
                            <h4>${activityNumber}. ${__esc(stepTitle)} <span class="tag bg-${typeKey}" style="float: right;">${__esc(typeLabel)}</span></h4>
                            <div style="font-size: 0.9em; color: #64748b; margin-bottom: 10px;">
                                <strong>Durée :</strong> ${duration} | 
                                <strong>Regroupement :</strong> ${groupInfo} | 
                                <strong>Modalité :</strong> ${trainerText}, ${placeText}, ${timeText}
                            </div>
                            ${objective ? `<div class="task-box"><strong>Objectif de l'activité:</strong><br>${__nl2br(objective)}</div>` : ''}
                            ${tasks ? `<div class="task-box"><strong>${t.label_tasks}:</strong><br>${__nl2br(tasks)}</div>` : ''}
                            ${trainerTasks ? `<div class="task-box"><strong>Ce que le formateur doit faire :</strong><br>${__nl2br(trainerTasks)}</div>` : ''}
                            ${evalFollowup ? `<div class="task-box"><strong>Évaluation / suivi :</strong><br>${__nl2br(evalFollowup)}</div>` : ''}
                            <div style="margin-top: 10px; font-size: 0.9em; color: #475569;">
                              <strong>Compétences du sujet :</strong> ${__csTxt}<br>
                              <strong>Compétences transversales :</strong> ${__ctTxt}
                            </div>
                            ${notes ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>${t.label_notes}:</strong> ${__nl2br(notes)}</div>` : ''}
                        </div>`;
                    });
                };

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                        const momentSecs = calcMomentSecs(stepCards);

                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;
                        html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                        const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                        const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                        const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        if (mTgtVal) {
                            html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                        }

                        if (mDesc) {
                            html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                        }
                        renderSteps(stepCards, momentPrefix);
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for a complete structure
                    const stepCards = __ldFilterStepNodeList(activity.querySelectorAll('.step-card'));
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;
                    html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                    const mTgtVal0 = (activity.querySelector('.moment-target-time')?.value || '').trim();
                    const mTgtUnitTxt0 = activity.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                    if (mTgtVal0) {
                        html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal0)} ${__esc(mTgtUnitTxt0)}</div>`;
                    }
                    renderSteps(stepCards, momentPrefix);
                }

                html += `</div>`;
            });

            html += `
</body></html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('html');
            a.click();
            URL.revokeObjectURL(url);
        }

        function __deprecated__exportRTF_2() {
            const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);

            const courseName = (document.getElementById('param-name')?.value || '').trim();

            function readDurationSecs(card) {
                const val = parseFloat(card.querySelector('.duration-input')?.value || '0');
                const unit = card.querySelector('.duration-unit')?.value || 'min';
                return toSeconds(val, unit);
            }

            let rtf = '{\\rtf1\\ansi\\deff0' +
                '{\\fonttbl{\\f0 Segoe UI;}{\\f1 Arial;}}' +
                '\\fs28\\b ' + escapeRtf(t.rtf_title) + '\\b0\\par\\par' +

                '\\fs24\\b ' + escapeRtf('Métadonnées') + '\\b0\\par' +
                '\\fs20 ' +
                '\\b ' + escapeRtf(t.label_course_name) + ':\\b0 ' + escapeRtf(courseName) + '\\par' +
                '\\b ' + escapeRtf(t.label_authors) + ':\\b0 ' + escapeRtf(document.getElementById('param-authors')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_mode) + ':\\b0 ' + escapeRtf(document.getElementById('param-mode')?.selectedOptions[0]?.innerText || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_level) + ':\\b0 ' + escapeRtf(document.getElementById('param-level')?.selectedOptions[0]?.innerText || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_class_size) + ':\\b0 ' + escapeRtf(document.getElementById('global-class-size')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_total_time) + ':\\b0 ' + escapeRtf(totalDuration) + '\\par' +
                '\\b ' + escapeRtf(t.label_learning_time) + ':\\b0 ' + escapeRtf((document.getElementById('param-learning-val')?.value || '') + ' ' + (document.getElementById('param-learning-unit')?.selectedOptions[0]?.innerText || '')) + '\\par' +
                '\\b ' + escapeRtf(t.label_designed_time) + ':\\b0 ' + escapeRtf((document.getElementById('param-designed-val')?.value || '') + ' ' + (document.getElementById('param-designed-unit')?.selectedOptions[0]?.innerText || '')) + '\\par\\par' +

                '\\fs24\\b ' + escapeRtf('Informations clés') + '\\b0\\par' +
                '\\fs20 ' +
                '\\b ' + escapeRtf(t.label_description) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-description')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_target_audience) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-target-audience')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_prerequisites) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-prerequisites')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_tools_materials || 'Outils et matériel') + ':\\b0\\par ' + escapeRtf(document.getElementById('param-tools-materials')?.value || '') + '\\par\\par' +
                (function(){ const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? ('\\b ' + escapeRtf(t.label_notes || 'Notes') + ':\\b0\\par ' + escapeRtf(__n) + '\\par\\par') : ''; })() +
                '\\b ' + escapeRtf(t.label_aims) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-aims')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_outcomes_text) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-outcomes-text')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_outcomes) + ':\\b0\\par ';

            document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomPrefix = '';
                if (level) {
                    bloomPrefix = '[' + (t[`bloom_${level}`] || level.toUpperCase());
                    if (sub) bloomPrefix += ' - ' + (t[`bloom_sub_${sub}`] || sub);
                    bloomPrefix += '] ';
                }
                rtf += '\\bullet ' + escapeRtf(bloomPrefix + text) + '\\par ';
            });

            rtf += '\\par\\fs24\\b ' + escapeRtf('Structure pédagogique') + '\\b0\\par\\fs20 ';

            const moduleCards = document.querySelectorAll('#modules-container .module-card');
            moduleCards.forEach((moduleCard, mIdx) => {
                const mTitle = moduleCard.querySelector('.module-title')?.value || `Module ${mIdx+1}`;
                rtf += '\\par\\b ' + escapeRtf(`MODULE ${mIdx+1} — `) + escapeRtf(mTitle) + '\\b0\\par ';

                const actCards = moduleCard.querySelectorAll('.activity-card');
                actCards.forEach((actCard, aIdx) => {
                    const aTitle = actCard.querySelector('.activity-title')?.value || `Activité ${aIdx+1}`;
                    const aDesc = actCard.querySelector('.activity-description')?.value || '';
                    const aTgtVal = actCard.querySelector('.activity-target-time')?.value || '';
                    const aTgtUnit = actCard.querySelector('.activity-target-unit')?.selectedOptions[0]?.innerText || '';

                    rtf += '\\par\\b ' + escapeRtf(`  Activité ${mIdx+1}.${aIdx+1} — `) + escapeRtf(aTitle) + '\\b0\\par ';
                    if (aDesc.trim()) rtf += escapeRtf('  ' + aDesc) + '\\par ';
                    if (String(aTgtVal).trim()) rtf += escapeRtf(`  Durée cible : ${aTgtVal} ${aTgtUnit}`) + '\\par ';

                    const moments = actCard.querySelectorAll('.moment-card');
                    moments.forEach((momentCard, moIdx) => {
                        const moTitle = momentCard.querySelector('.moment-title')?.value || `Moment ${moIdx+1}`;
                        const moTgtVal = momentCard.querySelector('.moment-target-time')?.value || '';
                        const moTgtUnit = momentCard.querySelector('.moment-target-unit')?.selectedOptions[0]?.innerText || '';
                        const stepCards = __ldFilterStepNodeList(momentCard.querySelectorAll('.step-card'));
                        const momentSecs = sumDurationCardsToSecs(stepCards);

                        rtf += '\\par\\b ' + escapeRtf(`    Moment ${mIdx+1}.${aIdx+1}.${moIdx+1} — `) + escapeRtf(moTitle) + '\\b0\\par ';
                        rtf += escapeRtf(`    Durée conçue : ${formatTimelineDuration(momentSecs)}`) + '\\par ';
                        if (String(moTgtVal).trim()) rtf += escapeRtf(`    Durée cible : ${moTgtVal} ${moTgtUnit}`) + '\\par ';

                        stepCards.forEach((stepCard, sIdx) => {
                            const sTitle = stepCard.querySelector('.step-input-title')?.value || `Étape ${sIdx+1}`;
                            const sObjective = stepCard.querySelector('.step-input-objective')?.value || '';
                            const sTasks = stepCard.querySelector('.step-input-tasks')?.value || '';
                            const sNotes = stepCard.querySelector('.step-input-notes')?.value || '';
                            const sSecs = readDurationSecs(stepCard);

                            const lt = stepCard.querySelector('.learning-type-select')?.selectedOptions[0]?.innerText || '';
                            const grpMode = stepCard.querySelector('.step-group-mode')?.selectedOptions[0]?.innerText || '';
                            const place = stepCard.querySelector('.place-select')?.selectedOptions[0]?.innerText || '';
                            const time = stepCard.querySelector('.time-select')?.selectedOptions[0]?.innerText || '';
                            const trainer = stepCard.querySelector('.trainer-select')?.selectedOptions[0]?.innerText || '';

                            rtf += '\\par\\b ' + escapeRtf(`      Étape ${mIdx+1}.${aIdx+1}.${moIdx+1}.${sIdx+1} — `) + escapeRtf(sTitle) + '\\b0\\par ';
                            rtf += escapeRtf(`      Durée conçue : ${formatTimelineDuration(sSecs)}`) + '\\par ';
                            if (lt) rtf += escapeRtf(`      Type d'apprentissage : ${lt}`) + '\\par ';
                            if (grpMode) rtf += escapeRtf(`      Regroupement : ${grpMode}`) + '\\par ';
                            if (place) rtf += escapeRtf(`      Lieu : ${place}`) + '\\par ';
                            if (time) rtf += escapeRtf(`      Temps : ${time}`) + '\\par ';
                            if (trainer) rtf += escapeRtf(`      Présence formateur : ${trainer}`) + '\\par ';

                            if (sObjective.trim()) rtf += escapeRtf('      Objectif : ' + sObjective) + '\\par ';
                            if (sTasks.trim()) rtf += escapeRtf('      Tâches : ' + sTasks) + '\\par ';
                            if (sNotes.trim()) rtf += escapeRtf('      Notes : ' + sNotes) + '\\par ';
                        });
                    });
                });
            });

            rtf += '}';

            const blob = new Blob([rtf], { type: 'application/rtf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('rtf');
            a.click();
            URL.revokeObjectURL(url);
        }

        function __deprecated__exportRichText_5() {
             const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            let html = `
            <!DOCTYPE html>
            <html lang="${currentLang}">
            <head>
                <meta charset="UTF-8">
                <title>${t.rtf_title}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1 { color: #4338ca; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                    h2 { color: #4f46e5; margin-top: 30px; border-left: 4px solid #4f46e5; padding-left: 10px; }
                    h3 { color: #6b7280; margin-top: 20px; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.05em; }
                    h4 { color: #374151; margin-top: 15px; margin-bottom: 5px; }
                    ul { list-style-type: none; padding-left: 0; }
                    li { margin-bottom: 5px; }
                    .meta-item { margin-bottom: 5px; }
                    .meta-label { font-weight: bold; color: #555; }
                    .activity-block { margin-bottom: 40px; border: none; border-radius: 8px; padding: 20px; background-color: #f8fafc; }
                    .step-block { margin-left: 20px; margin-bottom: 20px; padding: 15px; background-color: white; border-left: 4px solid #cbd5e1; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; margin-right: 5px; }
                    .task-box { background-color: #f1f5f9; padding: 10px; border-radius: 4px; margin-top: 10px; font-style: italic; }
                    
                    .type-acquisition { border-color: #a1f5ed; } .bg-none { background-color: #e5e7eb; }
 .bg-acquisition { background-color: #7dded6; color: #0f766e; }
                    .type-collaboration { border-color: #ffd966; } .bg-collaboration { background-color: #f0c953; color: #854d0e; }
                    .type-discussion { border-color: #7aaeea; } .bg-discussion { background-color: #6a9bd6; color: #1e40af; }
                    .type-investigation { border-color: #f8807f; } .bg-investigation { background-color: #e06e6d; color: #991b1b; }
                    .type-practice { border-color: #bb98dc; } .bg-practice { background-color: #a582c6; color: #6b21a8; }
                    .type-production { border-color: #bdea75; } .bg-production { background-color: #a6d15e; color: #3f6212; }
                

  
  #timeline-panel #timeline-activities{ overflow: visible !important; }

</style>
            </head>
            <body>
                <h1>${t.rtf_title}</h1>
                
                <h2 data-i18n="heading_metadata">Métadonnées</h2>
                <div class="meta-item"><span class="meta-label">${t.label_course_name}:</span> ${__esc(document.getElementById('param-name')?.value)}</div>                <div class="meta-item"><span class="meta-label">${t.label_authors}:</span> ${__esc(document.getElementById('param-authors')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_trainers || 'Formateur(s)'}:</span> ${__esc(document.getElementById('param-trainers')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label" data-i18n="label_theme_colon">Thème:</span> ${__esc(document.getElementById('param-topic')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label">${t.label_mode}:</span> ${__selTxt(document.getElementById('param-mode'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_level}:</span> ${__selTxt(document.getElementById('param-level'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_class_size}:</span> ${__esc(document.getElementById('global-class-size')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_total_time}:</span> ${totalDuration}</div>
                <div class="meta-item"><span class="meta-label">${t.label_learning_time}:</span> ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_designed_time}:</span> ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}</div>
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div>
                    ${(__charts['chart-learning-types'] ? `<div style="margin: 10px 0 16px 0;">
                        <h3 style="margin: 10px 0 6px 0;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:8px; font-size: 12px; color:#374151;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                </div>

                
                <h2>Informations clés</h2>
                <h3>${t.label_description}</h3>
                <p>${__nl2br(document.getElementById('param-description')?.value)}</p>

                <h3>${t.label_target_audience}</h3>
                <p>${__nl2br(document.getElementById('param-target-audience')?.value || '')}</p>

                <h3>${t.label_prerequisites}</h3>
                <p>${__nl2br(document.getElementById('param-prerequisites')?.value || '')}</p>

                <h3>${t.label_tools_materials || 'Outils et matériel'}</h3>
                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <h3>${t.label_aims}</h3>
                <p>${__nl2br(document.getElementById('param-aims')?.value)}</p>

                <h3>${t.label_outcomes_text}</h3>
                <p>${__nl2br(document.getElementById('param-outcomes-text')?.value || '')}</p>

                <h3>${t.label_outcomes}</h3>
                <ul>`;
                
document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomText = "";
                if(level) {
                    bloomText += `<strong>[${__esc(t[`bloom_${level}`] || level.toUpperCase())}`;
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "]</strong> ";
                }
                html += `<li>${bloomText}${__esc(text)}</li>`;
            });

            html += `</ul>

                `;

            html += `<h2>Structure pédagogique</h2>`;

            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                // Prefix "Module" (FR) without altering any existing translation strings
                let modPrefix = t.md_untitled_activity;
                modPrefix = modPrefix.replace(' sans titre', '');

                html += `<div class="activity-block">
                    <h3 style="color: #1e293b; font-size: 1.2em; border-bottom: 1px solid #cbd5e1; padding-bottom: 10px;">${modPrefix} ${aIdx + 1}: ${__esc(moduleTitle)}</h3>
                    ${moduleDesc ? `<p><em>${__nl2br(moduleDesc)}</em></p>` : ''}`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 6px;"><strong>Durée cible :</strong> ${__esc(moduleTgtVal)} ${__esc(moduleTgtUnitTxt)}</div>`;
                }

                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                    const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                    const __mCs = __idsToLabels(__mCsIds, __compMap);
                    const __mCt = __idsToLabels(__mCtIds, __compTMap);
                    if (__modAims.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 6px;"><strong>Objectifs du module (sélection) :</strong> ${__modAims.map(__esc).join(' ; ')}</div>`;
                    if (__modOut.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Résultats du module (sélection) :</strong> ${__modOut.map(__esc).join(' ; ')}</div>`;
                    if (__mCs.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (sujet) :</strong> ${__mCs.map(__esc).join(', ')}</div>`;
                    if (__mCt.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (transversales) :</strong> ${__mCt.map(__esc).join(', ')}</div>`;
                } catch(_){ __ldSilentErr(_); }

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepsNodeList, momentNumberPrefix) => {
                    stepsNodeList.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title').value || t.md_untitled_step;
                        const __modeEl = step.querySelector('.step-group-mode');
                        const __modeVal = __modeEl ? __modeEl.value : '';
                        const __modeTxt = (__modeEl && __modeEl.selectedOptions && __modeEl.selectedOptions[0]) ? ((__modeEl.selectedOptions[0].innerText || '').trim()) : '';
                        const __sizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const __countVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const __detailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                        let groupInfo = __modeTxt || __modeVal;
                        if (__modeVal === 'groups') {
                            const bits = [];
                            if (__sizeVal) bits.push('taille: ' + __sizeVal);
                            if (__countVal) bits.push('nb groupes: ' + __countVal);
                            groupInfo = (__modeTxt || __modeVal) + (bits.length ? ' (' + bits.join(', ') + ')' : '');
                        }
                        if (__detailsVal) groupInfo = groupInfo ? (groupInfo + ' — ' + __detailsVal) : __detailsVal;
                        const objective = step.querySelector('.step-input-objective').value || "";
                        const tasks = step.querySelector('.step-input-tasks').value || "";
                        const trainerTasks = step.querySelector('.step-input-trainer-tasks')?.value || "";
                        const evalFollowup = step.querySelector('.step-input-eval-followup')?.value || "";
                        const notes = step.querySelector('.step-input-notes').value || "";

                        const __csSel = step.querySelector('.step-competences-select');
                        const __ctSel = step.querySelector('.step-competences-transversales-select');
                        const __cs = Array.from((__csSel && __csSel.selectedOptions) ? __csSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __ct = Array.from((__ctSel && __ctSel.selectedOptions) ? __ctSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __csTxt = __cs.length ? __cs.map(__esc).join(', ') : '—';
                        const __ctTxt = __ct.length ? __ct.map(__esc).join(', ') : '—';
                        const compSujetHtml = __csTxt;
                        const compTransHtml = __ctTxt;
                        const typeKey = step.querySelector('.learning-type-select').value;
                        const typeLabel = t[`type_${typeKey}`];
                        const trainerText = step.querySelector('.trainer-select').selectedOptions[0].innerText;
                        const placeText = step.querySelector('.place-select').selectedOptions[0].innerText;
                        const timeText = step.querySelector('.time-select').selectedOptions[0].innerText;

                        const durVal = step.querySelector('.duration-input').value;
                        const durUnitTxt = step.querySelector('.duration-unit').selectedOptions[0].innerText;
                        const duration = `${durVal} ${durUnitTxt}`;

                        const activityNumber = `${momentNumberPrefix}.${sIdx + 1}`;

                        html += `<div class="step-block type-${typeKey}">
                            <h4>${activityNumber}. ${__esc(stepTitle)} <span class="tag bg-${typeKey}" style="float: right;">${__esc(typeLabel)}</span></h4>
                            <div style="font-size: 0.9em; color: #64748b; margin-bottom: 10px;">
                                <strong>Durée :</strong> ${duration} | 
                                <strong>Regroupement :</strong> ${groupInfo} | 
                                <strong>Modalité :</strong> ${trainerText}, ${placeText}, ${timeText}
                            </div>
                            ${objective ? `<div class="task-box"><strong>Objectif de l'activité:</strong><br>${__nl2br(objective)}</div>` : ''}
                            ${tasks ? `<div class="task-box"><strong>${t.label_tasks}:</strong><br>${__nl2br(tasks)}</div>` : ''}
                            ${trainerTasks ? `<div class="task-box"><strong>Ce que le formateur doit faire :</strong><br>${__nl2br(trainerTasks)}</div>` : ''}
                            ${evalFollowup ? `<div class="task-box"><strong>Évaluation / suivi :</strong><br>${__nl2br(evalFollowup)}</div>` : ''}
                            <div style="margin-top: 10px; font-size: 0.9em; color: #475569;">
                              <strong>Compétences du sujet :</strong> ${__csTxt}<br>
                              <strong>Compétences transversales :</strong> ${__ctTxt}
                            </div>
                            ${notes ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>${t.label_notes}:</strong> ${__nl2br(notes)}</div>` : ''}
                        </div>`;
                    });
                };

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                        const momentSecs = calcMomentSecs(stepCards);

                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;
                        html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                        const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                        const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                        const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        if (mTgtVal) {
                            html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                        }

                        if (mDesc) {
                            html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                        }
                        renderSteps(stepCards, momentPrefix);
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for a complete structure
                    const stepCards = __ldFilterStepNodeList(activity.querySelectorAll('.step-card'));
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;
                    html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                    const mTgtVal0 = (activity.querySelector('.moment-target-time')?.value || '').trim();
                    const mTgtUnitTxt0 = activity.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                    if (mTgtVal0) {
                        html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal0)} ${__esc(mTgtUnitTxt0)}</div>`;
                    }
                    renderSteps(stepCards, momentPrefix);
                }

                html += `</div>`;
            });

            html += `
</body></html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('html');
            a.click();
            URL.revokeObjectURL(url);
        }

        function __deprecated__exportRTF_3() {
            const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);

            const courseName = (document.getElementById('param-name')?.value || '').trim();

            function readDurationSecs(card) {
                const val = parseFloat(card.querySelector('.duration-input')?.value || '0');
                const unit = card.querySelector('.duration-unit')?.value || 'min';
                return toSeconds(val, unit);
            }

            let rtf = '{\\rtf1\\ansi\\deff0' +
                '{\\fonttbl{\\f0 Segoe UI;}{\\f1 Arial;}}' +
                '\\fs28\\b ' + escapeRtf(t.rtf_title) + '\\b0\\par\\par' +

                '\\fs24\\b ' + escapeRtf('Métadonnées') + '\\b0\\par' +
                '\\fs20 ' +
                '\\b ' + escapeRtf(t.label_course_name) + ':\\b0 ' + escapeRtf(courseName) + '\\par' +
                '\\b ' + escapeRtf(t.label_authors) + ':\\b0 ' + escapeRtf(document.getElementById('param-authors')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_mode) + ':\\b0 ' + escapeRtf(document.getElementById('param-mode')?.selectedOptions[0]?.innerText || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_level) + ':\\b0 ' + escapeRtf(document.getElementById('param-level')?.selectedOptions[0]?.innerText || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_class_size) + ':\\b0 ' + escapeRtf(document.getElementById('global-class-size')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_total_time) + ':\\b0 ' + escapeRtf(totalDuration) + '\\par' +
                '\\b ' + escapeRtf(t.label_learning_time) + ':\\b0 ' + escapeRtf((document.getElementById('param-learning-val')?.value || '') + ' ' + (document.getElementById('param-learning-unit')?.selectedOptions[0]?.innerText || '')) + '\\par' +
                '\\b ' + escapeRtf(t.label_designed_time) + ':\\b0 ' + escapeRtf((document.getElementById('param-designed-val')?.value || '') + ' ' + (document.getElementById('param-designed-unit')?.selectedOptions[0]?.innerText || '')) + '\\par\\par' +

                '\\fs24\\b ' + escapeRtf('Informations clés') + '\\b0\\par' +
                '\\fs20 ' +
                '\\b ' + escapeRtf(t.label_description) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-description')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_target_audience) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-target-audience')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_prerequisites) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-prerequisites')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_tools_materials || 'Outils et matériel') + ':\\b0\\par ' + escapeRtf(document.getElementById('param-tools-materials')?.value || '') + '\\par\\par' +
                (function(){ const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? ('\\b ' + escapeRtf(t.label_notes || 'Notes') + ':\\b0\\par ' + escapeRtf(__n) + '\\par\\par') : ''; })() +
                '\\b ' + escapeRtf(t.label_aims) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-aims')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_outcomes_text) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-outcomes-text')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_outcomes) + ':\\b0\\par ';

            document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomPrefix = '';
                if (level) {
                    bloomPrefix = '[' + (t[`bloom_${level}`] || level.toUpperCase());
                    if (sub) bloomPrefix += ' - ' + (t[`bloom_sub_${sub}`] || sub);
                    bloomPrefix += '] ';
                }
                rtf += '\\bullet ' + escapeRtf(bloomPrefix + text) + '\\par ';
            });

            rtf += '\\par\\fs24\\b ' + escapeRtf('Structure pédagogique') + '\\b0\\par\\fs20 ';

            const moduleCards = document.querySelectorAll('#modules-container .module-card');
            moduleCards.forEach((moduleCard, mIdx) => {
                const mTitle = moduleCard.querySelector('.module-title')?.value || `Module ${mIdx+1}`;
                rtf += '\\par\\b ' + escapeRtf(`MODULE ${mIdx+1} — `) + escapeRtf(mTitle) + '\\b0\\par ';

                const actCards = moduleCard.querySelectorAll('.activity-card');
                actCards.forEach((actCard, aIdx) => {
                    const aTitle = actCard.querySelector('.activity-title')?.value || `Activité ${aIdx+1}`;
                    const aDesc = actCard.querySelector('.activity-description')?.value || '';
                    const aTgtVal = actCard.querySelector('.activity-target-time')?.value || '';
                    const aTgtUnit = actCard.querySelector('.activity-target-unit')?.selectedOptions[0]?.innerText || '';

                    rtf += '\\par\\b ' + escapeRtf(`  Activité ${mIdx+1}.${aIdx+1} — `) + escapeRtf(aTitle) + '\\b0\\par ';
                    if (aDesc.trim()) rtf += escapeRtf('  ' + aDesc) + '\\par ';
                    if (String(aTgtVal).trim()) rtf += escapeRtf(`  Durée cible : ${aTgtVal} ${aTgtUnit}`) + '\\par ';

                    const moments = actCard.querySelectorAll('.moment-card');
                    moments.forEach((momentCard, moIdx) => {
                        const moTitle = momentCard.querySelector('.moment-title')?.value || `Moment ${moIdx+1}`;
                        const moTgtVal = momentCard.querySelector('.moment-target-time')?.value || '';
                        const moTgtUnit = momentCard.querySelector('.moment-target-unit')?.selectedOptions[0]?.innerText || '';
                        const stepCards = __ldFilterStepNodeList(momentCard.querySelectorAll('.step-card'));
                        const momentSecs = sumDurationCardsToSecs(stepCards);

                        rtf += '\\par\\b ' + escapeRtf(`    Moment ${mIdx+1}.${aIdx+1}.${moIdx+1} — `) + escapeRtf(moTitle) + '\\b0\\par ';
                        rtf += escapeRtf(`    Durée conçue : ${formatTimelineDuration(momentSecs)}`) + '\\par ';
                        if (String(moTgtVal).trim()) rtf += escapeRtf(`    Durée cible : ${moTgtVal} ${moTgtUnit}`) + '\\par ';

                        stepCards.forEach((stepCard, sIdx) => {
                            const sTitle = stepCard.querySelector('.step-input-title')?.value || `Étape ${sIdx+1}`;
                            const sObjective = stepCard.querySelector('.step-input-objective')?.value || '';
                            const sTasks = stepCard.querySelector('.step-input-tasks')?.value || '';
                            const sNotes = stepCard.querySelector('.step-input-notes')?.value || '';
                            const sSecs = readDurationSecs(stepCard);

                            const lt = stepCard.querySelector('.learning-type-select')?.selectedOptions[0]?.innerText || '';
                            const grpMode = stepCard.querySelector('.step-group-mode')?.selectedOptions[0]?.innerText || '';
                            const place = stepCard.querySelector('.place-select')?.selectedOptions[0]?.innerText || '';
                            const time = stepCard.querySelector('.time-select')?.selectedOptions[0]?.innerText || '';
                            const trainer = stepCard.querySelector('.trainer-select')?.selectedOptions[0]?.innerText || '';

                            rtf += '\\par\\b ' + escapeRtf(`      Étape ${mIdx+1}.${aIdx+1}.${moIdx+1}.${sIdx+1} — `) + escapeRtf(sTitle) + '\\b0\\par ';
                            rtf += escapeRtf(`      Durée conçue : ${formatTimelineDuration(sSecs)}`) + '\\par ';
                            if (lt) rtf += escapeRtf(`      Type d'apprentissage : ${lt}`) + '\\par ';
                            if (grpMode) rtf += escapeRtf(`      Regroupement : ${grpMode}`) + '\\par ';
                            if (place) rtf += escapeRtf(`      Lieu : ${place}`) + '\\par ';
                            if (time) rtf += escapeRtf(`      Temps : ${time}`) + '\\par ';
                            if (trainer) rtf += escapeRtf(`      Présence formateur : ${trainer}`) + '\\par ';

                            if (sObjective.trim()) rtf += escapeRtf('      Objectif : ' + sObjective) + '\\par ';
                            if (sTasks.trim()) rtf += escapeRtf('      Tâches : ' + sTasks) + '\\par ';
                            if (sNotes.trim()) rtf += escapeRtf('      Notes : ' + sNotes) + '\\par ';
                        });
                    });
                });
            });

            rtf += '}';

            const blob = new Blob([rtf], { type: 'application/rtf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('rtf');
            a.click();
            URL.revokeObjectURL(url);
        }

        function __deprecated__exportMarkdown_1() {
            const t = translations[currentLang] || translations.fr;
            const totals = getTotals();

            const selText = (el) => (el && el.selectedOptions && el.selectedOptions[0]) ? (el.selectedOptions[0].innerText || '').trim() : '';
            const val = (id) => (document.getElementById(id)?.value || '').toString().trim();

            const fmtTarget = (timeIdOrEl, unitIdOrEl) => {
                const timeEl = typeof timeIdOrEl === 'string' ? document.getElementById(timeIdOrEl) : timeIdOrEl;
                const unitEl = typeof unitIdOrEl === 'string' ? document.getElementById(unitIdOrEl) : unitIdOrEl;
                const v = (timeEl?.value || '').toString().trim();
                const u = selText(unitEl);
                return v ? `${v} ${u}`.trim() : '';
            };

            const getStepMinutes = (stepEl) => {
                const v = parseFloat(stepEl.querySelector('.duration-input')?.value || 0);
                const unitSecs = parseFloat(stepEl.querySelector('.duration-unit')?.value || 60);
                const secs = (Number.isFinite(v) ? v : 0) * (Number.isFinite(unitSecs) ? unitSecs : 60);
                return Math.round((secs / 60) * 100) / 100;
            };

            const getGroupingText = (stepEl) => {
                const modeEl = stepEl.querySelector('.step-group-mode');
                const modeTxt = selText(modeEl);
                const modeVal = modeEl ? modeEl.value : '';
                const sizeVal = (stepEl.querySelector('.step-group-size')?.value || '').toString().trim();
                const detailsVal = (stepEl.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                let txt = modeTxt;
                if (modeVal === 'groups' && sizeVal) txt = `${modeTxt} (${sizeVal})`;
                if (detailsVal) txt = txt ? `${txt} — ${detailsVal}` : detailsVal;
                return txt;
            };

            let md = `# ${t.md_title || 'Plan de formation'}\n\n`;

            md += `## ${t.md_metadata || 'Métadonnées'}\n`;
            md += `- **${t.label_course_name || 'Nom de la formation'} :** ${val('param-name')}\n`;
            md += `- **${t.label_authors || 'Auteurs'} :** ${val('param-authors')}\n`;
            md += `- **${t.label_mode || 'Modalité'} :** ${selText(document.getElementById('param-mode'))}\n`;
            md += `- **${t.label_level || 'Niveau'} :** ${selText(document.getElementById('param-level'))}\n`;
            md += `- **${t.label_class_size || 'Taille du groupe'} :** ${val('global-class-size')}\n`;
            md += `- **${t.label_total_time || 'Temps total'} :** ${fmtTotalDuration(totals.totalSecs, t)}\n`;
            md += `- **${t.label_learning_time || "Temps d'apprentissage (cible)"} :** ${fmtTarget('param-learning-time','param-learning-unit')}\n`;
            md += `- **${t.label_designed_time || 'Temps conçu (planifié)'} :** ${fmtTarget('param-designed-time','param-designed-unit')}\n`;
            md += `- **Horodatage d'export :** ${new Date().toISOString()}\n\n`;

            md += `## ${t.md_key_info || 'Informations clés'}\n\n`;
            md += `### ${t.label_objectives || 'Objectifs'}\n${val('param-aims')}\n\n`;
            md += `### ${t.label_outcomes_text || "Résultats d'apprentissage"}\n${val('param-outcomes-text')}\n\n`;

            // Bloom outcomes (list)
            md += `### ${t.label_outcomes || "Résultats d'apprentissage"}\n`;
            document.querySelectorAll('#outcomes-list li').forEach((li) => {
                const level = (li.querySelector('select')?.value || '').trim();
                const txt = (li.querySelector('input')?.value || '').trim();
                if (txt) md += `- **${level}** ${txt}\n`;
            });
            md += `\n`;

            md += `### ${t.label_description || 'Description générale'}\n${val('param-description')}\n\n`;
            md += `### ${t.label_target_audience || 'Public cible'}\n${val('param-audience')}\n\n`;
            md += `### ${t.label_prerequisites || 'Prérequis'}\n${val('param-prereq')}\n\n`;

            md += `## ${t.md_structure || 'Structure pédagogique'}\n\n`;

            document.querySelectorAll('.activity-group').forEach((moduleEl, mi) => {
                const moduleTitle = (moduleEl.querySelector('.activity-title')?.value || '').trim() || `Module ${mi+1}`;
                const moduleDesc = (moduleEl.querySelector('.activity-description')?.value || '').trim();
                const moduleTarget = fmtTarget(moduleEl.querySelector('.activity-target-time'), moduleEl.querySelector('.activity-target-unit'));

                md += `### Module ${mi+1} — ${moduleTitle}\n`;
                if (moduleTarget) md += `- **Durée cible :** ${moduleTarget}\n`;
                if (moduleDesc) md += `- **Description :** ${moduleDesc}\n`;
                md += `\n`;

                moduleEl.querySelectorAll('.moment-group').forEach((momentEl, mo) => {
                    const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim() || `Moment ${mo+1}`;
                    const momentDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                    const momentTarget = fmtTarget(momentEl.querySelector('.moment-target-time'), momentEl.querySelector('.moment-target-unit'));

                    md += `#### Moment ${mi+1}.${mo+1} — ${momentTitle}\n`;
                    if (momentTarget) md += `- **Durée cible :** ${momentTarget}\n`;
                    if (momentDesc) md += `- **Description :** ${momentDesc}\n`;
                    md += `\n`;

                    const steps = momentEl.querySelectorAll('.activity-steps-container .step-card');
                    if (!steps || steps.length === 0) {
                        md += `*(Aucune activité)*\n\n`;
                        return;
                    }

                    steps.forEach((stepEl, si) => {
                        const title = (stepEl.querySelector('.step-input-title')?.value || '').trim() || `Activité ${si+1}`;
                        const objective = (stepEl.querySelector('.step-input-objective')?.value || '').trim();
                        const tasks = (stepEl.querySelector('.step-input-tasks')?.value || '').trim();
                        const trainerTasks = (stepEl.querySelector('.step-input-trainer-tasks')?.value || '').trim();
                        const evalFollowup = (stepEl.querySelector('.step-input-eval-followup')?.value || '').trim();
                        const notes = (stepEl.querySelector('.step-input-notes')?.value || '').trim();

                        const typeTxt = selText(stepEl.querySelector('.learning-type-select'));
                        const groupingTxt = getGroupingText(stepEl);
                        const placeTxt = selText(stepEl.querySelector('.place-select'));
                        const timeTxt = selText(stepEl.querySelector('.time-select'));
                        const trainerTxt = selText(stepEl.querySelector('.trainer-select'));
                        const mins = getStepMinutes(stepEl);

                        md += `##### Activité ${mi+1}.${mo+1}.${si+1} — ${title}\n`;
                        md += `- **Durée :** ${mins} min\n`;
                        md += `- **Type d'apprentissage :** ${typeTxt}\n`;
                        md += `- **Regroupement :** ${groupingTxt}\n`;
                        md += `- **Lieu :** ${placeTxt}\n`;
                        md += `- **Temps :** ${timeTxt}\n`;
                        md += `- **Présence formateur :** ${trainerTxt}\n`;
                        md += `\n`;
                        md += `**Objectif :**\n${objective || ''}\n\n`;
                        md += `**Tâches :**\n${tasks || ''}\n\n`;
                        md += `**Notes :**\n${notes || ''}\n\n`;
                    });
                });
            });

            downloadText(md, 'text/markdown;charset=utf-8', `learning-design_${new Date().toISOString().slice(0,10)}.md`);
        }

function __deprecated__exportRichText_6() {
             const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            let html = `
            <!DOCTYPE html>
            <html lang="${currentLang}">
            <head>
                <meta charset="UTF-8">
                <title>${t.rtf_title}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1 { color: #4338ca; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                    h2 { color: #4f46e5; margin-top: 30px; border-left: 4px solid #4f46e5; padding-left: 10px; }
                    h3 { color: #6b7280; margin-top: 20px; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.05em; }
                    h4 { color: #374151; margin-top: 15px; margin-bottom: 5px; }
                    ul { list-style-type: none; padding-left: 0; }
                    li { margin-bottom: 5px; }
                    .meta-item { margin-bottom: 5px; }
                    .meta-label { font-weight: bold; color: #555; }
                    .activity-block { margin-bottom: 40px; border: none; border-radius: 8px; padding: 20px; background-color: #f8fafc; }
                    .step-block { margin-left: 20px; margin-bottom: 20px; padding: 15px; background-color: white; border-left: 4px solid #cbd5e1; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; margin-right: 5px; }
                    .task-box { background-color: #f1f5f9; padding: 10px; border-radius: 4px; margin-top: 10px; font-style: italic; }
                    
                    .type-acquisition { border-color: #a1f5ed; } .bg-none { background-color: #e5e7eb; }
 .bg-acquisition { background-color: #7dded6; color: #0f766e; }
                    .type-collaboration { border-color: #ffd966; } .bg-collaboration { background-color: #f0c953; color: #854d0e; }
                    .type-discussion { border-color: #7aaeea; } .bg-discussion { background-color: #6a9bd6; color: #1e40af; }
                    .type-investigation { border-color: #f8807f; } .bg-investigation { background-color: #e06e6d; color: #991b1b; }
                    .type-practice { border-color: #bb98dc; } .bg-practice { background-color: #a582c6; color: #6b21a8; }
                    .type-production { border-color: #bdea75; } .bg-production { background-color: #a6d15e; color: #3f6212; }
                

  
  #timeline-panel #timeline-activities{ overflow: visible !important; }

</style>
            </head>
            <body>
                <h1>${t.rtf_title}</h1>
                
                <h2 data-i18n="heading_metadata">Métadonnées</h2>
                <div class="meta-item"><span class="meta-label">${t.label_course_name}:</span> ${__esc(document.getElementById('param-name')?.value)}</div>                <div class="meta-item"><span class="meta-label">${t.label_authors}:</span> ${__esc(document.getElementById('param-authors')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_trainers || 'Formateur(s)'}:</span> ${__esc(document.getElementById('param-trainers')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label" data-i18n="label_theme_colon">Thème:</span> ${__esc(document.getElementById('param-topic')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label">${t.label_mode}:</span> ${__selTxt(document.getElementById('param-mode'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_level}:</span> ${__selTxt(document.getElementById('param-level'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_class_size}:</span> ${__esc(document.getElementById('global-class-size')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_total_time}:</span> ${totalDuration}</div>
                <div class="meta-item"><span class="meta-label">${t.label_learning_time}:</span> ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_designed_time}:</span> ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}</div>
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div>
                    ${(__charts['chart-learning-types'] ? `<div style="margin: 10px 0 16px 0;">
                        <h3 style="margin: 10px 0 6px 0;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:8px; font-size: 12px; color:#374151;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                </div>

                
                <h2>Informations clés</h2>
                <h3>${t.label_description}</h3>
                <p>${__nl2br(document.getElementById('param-description')?.value)}</p>

                <h3>${t.label_target_audience}</h3>
                <p>${__nl2br(document.getElementById('param-target-audience')?.value || '')}</p>

                <h3>${t.label_prerequisites}</h3>
                <p>${__nl2br(document.getElementById('param-prerequisites')?.value || '')}</p>

                <h3>${t.label_tools_materials || 'Outils et matériel'}</h3>
                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <h3>${t.label_aims}</h3>
                <p>${__nl2br(document.getElementById('param-aims')?.value)}</p>

                <h3>${t.label_outcomes_text}</h3>
                <p>${__nl2br(document.getElementById('param-outcomes-text')?.value || '')}</p>

                <h3>${t.label_outcomes}</h3>
                <ul>`;
                
document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomText = "";
                if(level) {
                    bloomText += `<strong>[${__esc(t[`bloom_${level}`] || level.toUpperCase())}`;
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "]</strong> ";
                }
                html += `<li>${bloomText}${__esc(text)}</li>`;
            });

            html += `</ul>

                `;

            html += `<h2>Structure pédagogique</h2>`;

            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                // Prefix "Module" (FR) without altering any existing translation strings
                let modPrefix = t.md_untitled_activity;
                modPrefix = modPrefix.replace(' sans titre', '');

                html += `<div class="activity-block">
                    <h3 style="color: #1e293b; font-size: 1.2em; border-bottom: 1px solid #cbd5e1; padding-bottom: 10px;">${modPrefix} ${aIdx + 1}: ${__esc(moduleTitle)}</h3>
                    ${moduleDesc ? `<p><em>${__nl2br(moduleDesc)}</em></p>` : ''}`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 6px;"><strong>Durée cible :</strong> ${__esc(moduleTgtVal)} ${__esc(moduleTgtUnitTxt)}</div>`;
                }

                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                    const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                    const __mCs = __idsToLabels(__mCsIds, __compMap);
                    const __mCt = __idsToLabels(__mCtIds, __compTMap);
                    if (__modAims.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 6px;"><strong>Objectifs du module (sélection) :</strong> ${__modAims.map(__esc).join(' ; ')}</div>`;
                    if (__modOut.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Résultats du module (sélection) :</strong> ${__modOut.map(__esc).join(' ; ')}</div>`;
                    if (__mCs.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (sujet) :</strong> ${__mCs.map(__esc).join(', ')}</div>`;
                    if (__mCt.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (transversales) :</strong> ${__mCt.map(__esc).join(', ')}</div>`;
                } catch(_){ __ldSilentErr(_); }

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepsNodeList, momentNumberPrefix) => {
                    stepsNodeList.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title').value || t.md_untitled_step;
                        const groupMode = step.querySelector('.step-group-mode').value;
                        const groupModeEl = step.querySelector('.step-group-mode');
                        const groupModeVal = groupModeEl ? groupModeEl.value : '';
                        const groupModeTxt = groupModeEl && groupModeEl.selectedOptions[0] ? (groupModeEl.selectedOptions[0].innerText || '').trim() : '';
                        const groupSizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const groupCountVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const groupDetailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                        let groupInfo = groupModeTxt;
                        if (groupModeVal === 'groups') {
                            const bits = [];
                            if (groupSizeVal) bits.push(groupSizeVal);
                            if (groupCountVal) bits.push(`nb groupes: ${groupCountVal}`);
                            if (bits.length) groupInfo = `${groupModeTxt} (${bits.join(', ')})`;
                        }
                        if (groupDetailsVal) groupInfo = groupInfo ? `${groupInfo} — ${groupDetailsVal}` : groupDetailsVal;
                        const objective = step.querySelector('.step-input-objective').value || "";
                        const tasks = step.querySelector('.step-input-tasks').value || "";
                        const trainerTasks = step.querySelector('.step-input-trainer-tasks')?.value || "";
                        const evalFollowup = step.querySelector('.step-input-eval-followup')?.value || "";
                        const notes = step.querySelector('.step-input-notes').value || "";

                        const __csSel = step.querySelector('.step-competences-select');
                        const __ctSel = step.querySelector('.step-competences-transversales-select');
                        const __cs = Array.from((__csSel && __csSel.selectedOptions) ? __csSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __ct = Array.from((__ctSel && __ctSel.selectedOptions) ? __ctSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __csTxt = __cs.length ? __cs.map(__esc).join(', ') : '—';
                        const __ctTxt = __ct.length ? __ct.map(__esc).join(', ') : '—';
                        const compSujetHtml = __csTxt;
                        const compTransHtml = __ctTxt;
                        const typeKey = step.querySelector('.learning-type-select').value;
                        const typeLabel = t[`type_${typeKey}`];
                        const trainerText = step.querySelector('.trainer-select').selectedOptions[0].innerText;
                        const placeText = step.querySelector('.place-select').selectedOptions[0].innerText;
                        const timeText = step.querySelector('.time-select').selectedOptions[0].innerText;

                        const durVal = step.querySelector('.duration-input').value;
                        const durUnitTxt = step.querySelector('.duration-unit').selectedOptions[0].innerText;
                        const duration = `${durVal} ${durUnitTxt}`;

                        const activityNumber = `${momentNumberPrefix}.${sIdx + 1}`;

                        html += `<div class="step-block type-${typeKey}">
                            <h4>${activityNumber}. ${__esc(stepTitle)} <span class="tag bg-${typeKey}" style="float: right;">${__esc(typeLabel)}</span></h4>
                            <div style="font-size: 0.9em; color: #64748b; margin-bottom: 10px;">
                                <strong>Durée :</strong> ${duration} | 
                                <strong>Regroupement :</strong> ${groupInfo} | 
                                <strong>Modalité :</strong> ${trainerText}, ${placeText}, ${timeText}
                            </div>
                            ${objective ? `<div class="task-box"><strong>Objectif de l'activité:</strong><br>${__nl2br(objective)}</div>` : ''}
                            ${tasks ? `<div class="task-box"><strong>${t.label_tasks}:</strong><br>${__nl2br(tasks)}</div>` : ''}
                            ${trainerTasks ? `<div class="task-box"><strong>Ce que le formateur doit faire :</strong><br>${__nl2br(trainerTasks)}</div>` : ''}
                            ${evalFollowup ? `<div class="task-box"><strong>Évaluation / suivi :</strong><br>${__nl2br(evalFollowup)}</div>` : ''}
                            <div style="margin-top: 10px; font-size: 0.9em; color: #475569;">
                              <strong>Compétences du sujet :</strong> ${__csTxt}<br>
                              <strong>Compétences transversales :</strong> ${__ctTxt}
                            </div>
                            ${notes ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>${t.label_notes}:</strong> ${__nl2br(notes)}</div>` : ''}
                        </div>`;
                    });
                };

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                        const momentSecs = calcMomentSecs(stepCards);

                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;
                        html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                        const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                        const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                        const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        if (mTgtVal) {
                            html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                        }

                        if (mDesc) {
                            html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                        }
                        renderSteps(stepCards, momentPrefix);
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for a complete structure
                    const stepCards = __ldFilterStepNodeList(activity.querySelectorAll('.step-card'));
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;
                    html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                    const mTgtVal0 = (activity.querySelector('.moment-target-time')?.value || '').trim();
                    const mTgtUnitTxt0 = activity.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                    if (mTgtVal0) {
                        html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal0)} ${__esc(mTgtUnitTxt0)}</div>`;
                    }
                    renderSteps(stepCards, momentPrefix);
                }

                html += `</div>`;
            });

            html += `
</body></html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('html');
            a.click();
            URL.revokeObjectURL(url);
        }


function exportCSV() {
    // Export to Excel (.xlsx) – keeps the existing "CSV" menu entry unchanged.
    // Sheets:
    //  - "Meta" : project-level metadata (incl. Outils et matériel + Notes)
    //  - "Learning design" : tabular structure (Modules/Moments/Sous-moments/Activités)
    if (!window.XLSX) {
        showAlert('Erreur', (currentLang === 'en') ? 'Excel export library is not available.' : 'La bibliothèque d’export Excel n’est pas disponible.');
        return;
    }

    const model = buildExportModel();
    const rows = buildTabularExportRows(model);

    const wb = XLSX.utils.book_new();

    // Meta sheet (key-value)
    const meta = model.meta || {};
    const metaRows = [
        ['Champ', 'Valeur'],
        ['Nom de la formation', meta.courseName || ''],
        ['Concepteurs', meta.authors || ''],
        ['Formateurs', meta.trainers || ''],
        ['Thème', meta.topic || ''],
        ['Niveau', meta.level || ''],
        ['Modalité', meta.mode || ''],
        ['Taille cohorte', meta.cohortSize || ''],
        ['Temps apprentissage', meta.learningTime || ''],
        ['Temps conçu', meta.designedTime || ''],
        ['Description', meta.description || ''],
        ['Public cible', meta.targetAudience || ''],
        ['Prérequis', meta.prerequisites || ''],
        ['Objectifs', meta.aims || ''],
        ['Résultats attendus (texte)', meta.outcomesText || ''],
        ['Outils et matériel', meta.toolsMaterials || ''],
        ['Notes (outils et matériel)', meta.toolsMaterialsNotes || ''],
        ['Généré le', meta.generatedOn || '']
    ];
    const wsMeta = XLSX.utils.aoa_to_sheet(metaRows);
    XLSX.utils.book_append_sheet(wb, wsMeta, 'Meta');

    // Learning design sheet
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'Learning design');

    const filename = window.__ldBuildExportFilename('xlsx');
    XLSX.writeFile(wb, filename);
}



            


        function __deprecated__exportRichText_7() {
             const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            let html = `
            <!DOCTYPE html>
            <html lang="${currentLang}">
            <head>
                <meta charset="UTF-8">
                <title>${t.rtf_title}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1 { color: #4338ca; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                    h2 { color: #4f46e5; margin-top: 30px; border-left: 4px solid #4f46e5; padding-left: 10px; }
                    h3 { color: #6b7280; margin-top: 20px; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.05em; }
                    h4 { color: #374151; margin-top: 15px; margin-bottom: 5px; }
                    ul { list-style-type: none; padding-left: 0; }
                    li { margin-bottom: 5px; }
                    .meta-item { margin-bottom: 5px; }
                    .meta-label { font-weight: bold; color: #555; }
                    .activity-block { margin-bottom: 40px; border: none; border-radius: 8px; padding: 20px; background-color: #f8fafc; }
                    .step-block { margin-left: 20px; margin-bottom: 20px; padding: 15px; background-color: white; border-left: 4px solid #cbd5e1; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; margin-right: 5px; }
                    .task-box { background-color: #f1f5f9; padding: 10px; border-radius: 4px; margin-top: 10px; font-style: italic; }
                    
                    .type-acquisition { border-color: #a1f5ed; } .bg-none { background-color: #e5e7eb; }
 .bg-acquisition { background-color: #7dded6; color: #0f766e; }
                    .type-collaboration { border-color: #ffd966; } .bg-collaboration { background-color: #f0c953; color: #854d0e; }
                    .type-discussion { border-color: #7aaeea; } .bg-discussion { background-color: #6a9bd6; color: #1e40af; }
                    .type-investigation { border-color: #f8807f; } .bg-investigation { background-color: #e06e6d; color: #991b1b; }
                    .type-practice { border-color: #bb98dc; } .bg-practice { background-color: #a582c6; color: #6b21a8; }
                    .type-production { border-color: #bdea75; } .bg-production { background-color: #a6d15e; color: #3f6212; }
                

  
  #timeline-panel #timeline-activities{ overflow: visible !important; }

</style>
            </head>
            <body>
                <h1>${t.rtf_title}</h1>
                
                <h2 data-i18n="heading_metadata">Métadonnées</h2>
                <div class="meta-item"><span class="meta-label">${t.label_course_name}:</span> ${__esc(document.getElementById('param-name')?.value)}</div>                <div class="meta-item"><span class="meta-label">${t.label_authors}:</span> ${__esc(document.getElementById('param-authors')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_trainers || 'Formateur(s)'}:</span> ${__esc(document.getElementById('param-trainers')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label" data-i18n="label_theme_colon">Thème:</span> ${__esc(document.getElementById('param-topic')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label">${t.label_mode}:</span> ${__selTxt(document.getElementById('param-mode'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_level}:</span> ${__selTxt(document.getElementById('param-level'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_class_size}:</span> ${__esc(document.getElementById('global-class-size')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_total_time}:</span> ${totalDuration}</div>
                <div class="meta-item"><span class="meta-label">${t.label_learning_time}:</span> ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_designed_time}:</span> ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}</div>
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div>
                    ${(__charts['chart-learning-types'] ? `<div style="margin: 10px 0 16px 0;">
                        <h3 style="margin: 10px 0 6px 0;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:8px; font-size: 12px; color:#374151;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                </div>

                
                <h2>Informations clés</h2>
                <h3>${t.label_description}</h3>
                <p>${__nl2br(document.getElementById('param-description')?.value)}</p>

                <h3>${t.label_target_audience}</h3>
                <p>${__nl2br(document.getElementById('param-target-audience')?.value || '')}</p>

                <h3>${t.label_prerequisites}</h3>
                <p>${__nl2br(document.getElementById('param-prerequisites')?.value || '')}</p>

                <h3>${t.label_tools_materials || 'Outils et matériel'}</h3>
                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <h3>${t.label_aims}</h3>
                <p>${__nl2br(document.getElementById('param-aims')?.value)}</p>

                <h3>${t.label_outcomes_text}</h3>
                <p>${__nl2br(document.getElementById('param-outcomes-text')?.value || '')}</p>

                <h3>${t.label_outcomes}</h3>
                <ul>`;
                
document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomText = "";
                if(level) {
                    bloomText += `<strong>[${__esc(t[`bloom_${level}`] || level.toUpperCase())}`;
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "]</strong> ";
                }
                html += `<li>${bloomText}${__esc(text)}</li>`;
            });

            html += `</ul>

                `;

            html += `<h2>Structure pédagogique</h2>`;

            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                // Prefix "Module" (FR) without altering any existing translation strings
                let modPrefix = t.md_untitled_activity;
                modPrefix = modPrefix.replace(' sans titre', '');

                html += `<div class="activity-block">
                    <h3 style="color: #1e293b; font-size: 1.2em; border-bottom: 1px solid #cbd5e1; padding-bottom: 10px;">${modPrefix} ${aIdx + 1}: ${__esc(moduleTitle)}</h3>
                    ${moduleDesc ? `<p><em>${__nl2br(moduleDesc)}</em></p>` : ''}`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 6px;"><strong>Durée cible :</strong> ${__esc(moduleTgtVal)} ${__esc(moduleTgtUnitTxt)}</div>`;
                }

                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                    const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                    const __mCs = __idsToLabels(__mCsIds, __compMap);
                    const __mCt = __idsToLabels(__mCtIds, __compTMap);
                    if (__modAims.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 6px;"><strong>Objectifs du module (sélection) :</strong> ${__modAims.map(__esc).join(' ; ')}</div>`;
                    if (__modOut.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Résultats du module (sélection) :</strong> ${__modOut.map(__esc).join(' ; ')}</div>`;
                    if (__mCs.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (sujet) :</strong> ${__mCs.map(__esc).join(', ')}</div>`;
                    if (__mCt.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (transversales) :</strong> ${__mCt.map(__esc).join(', ')}</div>`;
                } catch(_){ __ldSilentErr(_); }

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepsNodeList, momentNumberPrefix) => {
                    stepsNodeList.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title').value || t.md_untitled_step;
                        const groupMode = step.querySelector('.step-group-mode').value;
                        const groupModeEl = step.querySelector('.step-group-mode');
                        const groupModeVal = groupModeEl ? groupModeEl.value : '';
                        const groupModeTxt = groupModeEl && groupModeEl.selectedOptions[0] ? (groupModeEl.selectedOptions[0].innerText || '').trim() : '';
                        const groupSizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const groupCountVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const groupDetailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                        let groupInfo = groupModeTxt;
                        if (groupModeVal === 'groups') {
                            const bits = [];
                            if (groupSizeVal) bits.push(groupSizeVal);
                            if (groupCountVal) bits.push(`nb groupes: ${groupCountVal}`);
                            if (bits.length) groupInfo = `${groupModeTxt} (${bits.join(', ')})`;
                        }
                        if (groupDetailsVal) groupInfo = groupInfo ? `${groupInfo} — ${groupDetailsVal}` : groupDetailsVal;
                        const objective = step.querySelector('.step-input-objective').value || "";
                        const tasks = step.querySelector('.step-input-tasks').value || "";
                        const trainerTasks = step.querySelector('.step-input-trainer-tasks')?.value || "";
                        const evalFollowup = step.querySelector('.step-input-eval-followup')?.value || "";
                        const notes = step.querySelector('.step-input-notes').value || "";

                        const __csSel = step.querySelector('.step-competences-select');
                        const __ctSel = step.querySelector('.step-competences-transversales-select');
                        const __cs = Array.from((__csSel && __csSel.selectedOptions) ? __csSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __ct = Array.from((__ctSel && __ctSel.selectedOptions) ? __ctSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __csTxt = __cs.length ? __cs.map(__esc).join(', ') : '—';
                        const __ctTxt = __ct.length ? __ct.map(__esc).join(', ') : '—';
                        const compSujetHtml = __csTxt;
                        const compTransHtml = __ctTxt;
                        const typeKey = step.querySelector('.learning-type-select').value;
                        const typeLabel = t[`type_${typeKey}`];
                        const trainerText = step.querySelector('.trainer-select').selectedOptions[0].innerText;
                        const placeText = step.querySelector('.place-select').selectedOptions[0].innerText;
                        const timeText = step.querySelector('.time-select').selectedOptions[0].innerText;

                        const durVal = step.querySelector('.duration-input').value;
                        const durUnitTxt = step.querySelector('.duration-unit').selectedOptions[0].innerText;
                        const duration = `${durVal} ${durUnitTxt}`;

                        const activityNumber = `${momentNumberPrefix}.${sIdx + 1}`;

                        html += `<div class="step-block type-${typeKey}">
                            <h4>${activityNumber}. ${__esc(stepTitle)} <span class="tag bg-${typeKey}" style="float: right;">${__esc(typeLabel)}</span></h4>
                            <div style="font-size: 0.9em; color: #64748b; margin-bottom: 10px;">
                                <strong>Durée :</strong> ${duration} | 
                                <strong>Regroupement :</strong> ${groupInfo} | 
                                <strong>Modalité :</strong> ${trainerText}, ${placeText}, ${timeText}
                            </div>
                            ${objective ? `<div class="task-box"><strong>Objectif de l'activité:</strong><br>${__nl2br(objective)}</div>` : ''}
                            ${tasks ? `<div class="task-box"><strong>${t.label_tasks}:</strong><br>${__nl2br(tasks)}</div>` : ''}
                            ${trainerTasks ? `<div class="task-box"><strong>Ce que le formateur doit faire :</strong><br>${__nl2br(trainerTasks)}</div>` : ''}
                            ${evalFollowup ? `<div class="task-box"><strong>Évaluation / suivi :</strong><br>${__nl2br(evalFollowup)}</div>` : ''}
                            <div style="margin-top: 10px; font-size: 0.9em; color: #475569;">
                              <strong>Compétences du sujet :</strong> ${__csTxt}<br>
                              <strong>Compétences transversales :</strong> ${__ctTxt}
                            </div>
                            ${notes ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>${t.label_notes}:</strong> ${__nl2br(notes)}</div>` : ''}
                        </div>`;
                    });
                };

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                        const momentSecs = calcMomentSecs(stepCards);

                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;
                        html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                        const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                        const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                        const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        if (mTgtVal) {
                            html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                        }

                        if (mDesc) {
                            html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                        }
                        renderSteps(stepCards, momentPrefix);
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for a complete structure
                    const stepCards = __ldFilterStepNodeList(activity.querySelectorAll('.step-card'));
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;
                    html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                    const mTgtVal0 = (activity.querySelector('.moment-target-time')?.value || '').trim();
                    const mTgtUnitTxt0 = activity.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                    if (mTgtVal0) {
                        html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal0)} ${__esc(mTgtUnitTxt0)}</div>`;
                    }
                    renderSteps(stepCards, momentPrefix);
                }

                html += `</div>`;
            });

            html += `
</body></html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('html');
            a.click();
            URL.revokeObjectURL(url);
        }

        function __deprecated__exportRTF_4() {
            const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);

            const courseName = (document.getElementById('param-name')?.value || '').trim();

            function readDurationSecs(card) {
                const val = parseFloat(card.querySelector('.duration-input')?.value || '0');
                const unit = card.querySelector('.duration-unit')?.value || 'min';
                return toSeconds(val, unit);
            }

            let rtf = '{\\rtf1\\ansi\\deff0' +
                '{\\fonttbl{\\f0 Segoe UI;}{\\f1 Arial;}}' +
                '\\fs28\\b ' + escapeRtf(t.rtf_title) + '\\b0\\par\\par' +

                '\\fs24\\b ' + escapeRtf('Métadonnées') + '\\b0\\par' +
                '\\fs20 ' +
                '\\b ' + escapeRtf(t.label_course_name) + ':\\b0 ' + escapeRtf(courseName) + '\\par' +
                '\\b ' + escapeRtf(t.label_authors) + ':\\b0 ' + escapeRtf(document.getElementById('param-authors')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_mode) + ':\\b0 ' + escapeRtf(document.getElementById('param-mode')?.selectedOptions[0]?.innerText || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_level) + ':\\b0 ' + escapeRtf(document.getElementById('param-level')?.selectedOptions[0]?.innerText || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_class_size) + ':\\b0 ' + escapeRtf(document.getElementById('global-class-size')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_total_time) + ':\\b0 ' + escapeRtf(totalDuration) + '\\par' +
                '\\b ' + escapeRtf(t.label_learning_time) + ':\\b0 ' + escapeRtf((document.getElementById('param-learning-val')?.value || '') + ' ' + (document.getElementById('param-learning-unit')?.selectedOptions[0]?.innerText || '')) + '\\par' +
                '\\b ' + escapeRtf(t.label_designed_time) + ':\\b0 ' + escapeRtf((document.getElementById('param-designed-val')?.value || '') + ' ' + (document.getElementById('param-designed-unit')?.selectedOptions[0]?.innerText || '')) + '\\par\\par' +

                '\\fs24\\b ' + escapeRtf('Informations clés') + '\\b0\\par' +
                '\\fs20 ' +
                '\\b ' + escapeRtf(t.label_description) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-description')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_target_audience) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-target-audience')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_prerequisites) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-prerequisites')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_tools_materials || 'Outils et matériel') + ':\\b0\\par ' + escapeRtf(document.getElementById('param-tools-materials')?.value || '') + '\\par\\par' +
                (function(){ const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? ('\\b ' + escapeRtf(t.label_notes || 'Notes') + ':\\b0\\par ' + escapeRtf(__n) + '\\par\\par') : ''; })() +
                '\\b ' + escapeRtf(t.label_aims) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-aims')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_outcomes_text) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-outcomes-text')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_outcomes) + ':\\b0\\par ';

            document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomPrefix = '';
                if (level) {
                    bloomPrefix = '[' + (t[`bloom_${level}`] || level.toUpperCase());
                    if (sub) bloomPrefix += ' - ' + (t[`bloom_sub_${sub}`] || sub);
                    bloomPrefix += '] ';
                }
                rtf += '\\bullet ' + escapeRtf(bloomPrefix + text) + '\\par ';
            });

            rtf += '\\par\\fs24\\b ' + escapeRtf('Structure pédagogique') + '\\b0\\par\\fs20 ';

            const moduleCards = document.querySelectorAll('#modules-container .module-card');
            moduleCards.forEach((moduleCard, mIdx) => {
                const mTitle = moduleCard.querySelector('.module-title')?.value || `Module ${mIdx+1}`;
                rtf += '\\par\\b ' + escapeRtf(`MODULE ${mIdx+1} — `) + escapeRtf(mTitle) + '\\b0\\par ';

                const actCards = moduleCard.querySelectorAll('.activity-card');
                actCards.forEach((actCard, aIdx) => {
                    const aTitle = actCard.querySelector('.activity-title')?.value || `Activité ${aIdx+1}`;
                    const aDesc = actCard.querySelector('.activity-description')?.value || '';
                    const aTgtVal = actCard.querySelector('.activity-target-time')?.value || '';
                    const aTgtUnit = actCard.querySelector('.activity-target-unit')?.selectedOptions[0]?.innerText || '';

                    rtf += '\\par\\b ' + escapeRtf(`  Activité ${mIdx+1}.${aIdx+1} — `) + escapeRtf(aTitle) + '\\b0\\par ';
                    if (aDesc.trim()) rtf += escapeRtf('  ' + aDesc) + '\\par ';
                    if (String(aTgtVal).trim()) rtf += escapeRtf(`  Durée cible : ${aTgtVal} ${aTgtUnit}`) + '\\par ';

                    const moments = actCard.querySelectorAll('.moment-card');
                    moments.forEach((momentCard, moIdx) => {
                        const moTitle = momentCard.querySelector('.moment-title')?.value || `Moment ${moIdx+1}`;
                        const moTgtVal = momentCard.querySelector('.moment-target-time')?.value || '';
                        const moTgtUnit = momentCard.querySelector('.moment-target-unit')?.selectedOptions[0]?.innerText || '';
                        const stepCards = __ldFilterStepNodeList(momentCard.querySelectorAll('.step-card'));
                        const momentSecs = sumDurationCardsToSecs(stepCards);

                        rtf += '\\par\\b ' + escapeRtf(`    Moment ${mIdx+1}.${aIdx+1}.${moIdx+1} — `) + escapeRtf(moTitle) + '\\b0\\par ';
                        rtf += escapeRtf(`    Durée conçue : ${formatTimelineDuration(momentSecs)}`) + '\\par ';
                        if (String(moTgtVal).trim()) rtf += escapeRtf(`    Durée cible : ${moTgtVal} ${moTgtUnit}`) + '\\par ';

                        stepCards.forEach((stepCard, sIdx) => {
                            const sTitle = stepCard.querySelector('.step-input-title')?.value || `Étape ${sIdx+1}`;
                            const sObjective = stepCard.querySelector('.step-input-objective')?.value || '';
                            const sTasks = stepCard.querySelector('.step-input-tasks')?.value || '';
                            const sNotes = stepCard.querySelector('.step-input-notes')?.value || '';
                            const sSecs = readDurationSecs(stepCard);

                            const lt = stepCard.querySelector('.learning-type-select')?.selectedOptions[0]?.innerText || '';
                            const grpMode = stepCard.querySelector('.step-group-mode')?.selectedOptions[0]?.innerText || '';
                            const place = stepCard.querySelector('.place-select')?.selectedOptions[0]?.innerText || '';
                            const time = stepCard.querySelector('.time-select')?.selectedOptions[0]?.innerText || '';
                            const trainer = stepCard.querySelector('.trainer-select')?.selectedOptions[0]?.innerText || '';

                            rtf += '\\par\\b ' + escapeRtf(`      Étape ${mIdx+1}.${aIdx+1}.${moIdx+1}.${sIdx+1} — `) + escapeRtf(sTitle) + '\\b0\\par ';
                            rtf += escapeRtf(`      Durée conçue : ${formatTimelineDuration(sSecs)}`) + '\\par ';
                            if (lt) rtf += escapeRtf(`      Type d'apprentissage : ${lt}`) + '\\par ';
                            if (grpMode) rtf += escapeRtf(`      Regroupement : ${grpMode}`) + '\\par ';
                            if (place) rtf += escapeRtf(`      Lieu : ${place}`) + '\\par ';
                            if (time) rtf += escapeRtf(`      Temps : ${time}`) + '\\par ';
                            if (trainer) rtf += escapeRtf(`      Présence formateur : ${trainer}`) + '\\par ';

                            if (sObjective.trim()) rtf += escapeRtf('      Objectif : ' + sObjective) + '\\par ';
                            if (sTasks.trim()) rtf += escapeRtf('      Tâches : ' + sTasks) + '\\par ';
                            if (sNotes.trim()) rtf += escapeRtf('      Notes : ' + sNotes) + '\\par ';
                        });
                    });
                });
            });

            rtf += '}';

            const blob = new Blob([rtf], { type: 'application/rtf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('rtf');
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportRichText() {
             const t = translations[currentLang];
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            

                        const __esc = (v) => escapeHtml(String(v ?? ''));
            const __nl2br = (v) => __esc(v).replace(/\n/g, '<br>');
            const __selTxt = (el) => __esc((el && el.selectedOptions && el.selectedOptions[0]) ? el.selectedOptions[0].innerText : '');

// Ensure charts have a measurable width even if the panel is collapsed (display:none)
            const __chartsPanel = document.getElementById('analysis-pane-modalites');
            const __chartsPanelPrev = __chartsPanel ? {
                display: __chartsPanel.style.display,
                visibility: __chartsPanel.style.visibility,
                position: __chartsPanel.style.position,
                left: __chartsPanel.style.left,
                top: __chartsPanel.style.top,
                width: __chartsPanel.style.width
            } : null;

            if (__chartsPanel && (getComputedStyle(__chartsPanel).display === 'none' || __chartsPanel.clientWidth === 0)) {
                __chartsPanel.style.display = 'block';
                __chartsPanel.style.visibility = 'hidden';
                __chartsPanel.style.position = 'absolute';
                __chartsPanel.style.left = '-10000px';
                __chartsPanel.style.top = '0';
                __chartsPanel.style.width = '800px';

                // Trigger chart redraw via the existing delegated listener
                const __trig = document.querySelector('.learning-type-select, .step-group-mode, .place-select, .time-select, .trainer-select');
                if (__trig) __trig.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // --- Capture analysis charts (as embedded images) ---
            const __chartIds = [
                'chart-learning-types',
                'chart-group-modes',
                'chart-place-modes',
                'chart-time-modes',
                'chart-trainer-presence'
            ];

            const __getCanvasPng = (id) => {
                const c = document.getElementById(id);
                if (!c || typeof c.toDataURL !== 'function') return '';
                try { return c.toDataURL('image/png'); } catch (_) { return ''; }
            };

            const __charts = {};
            __chartIds.forEach((id) => { __charts[id] = __getCanvasPng(id); });

            const __legendHtml = (() => {
                const el = document.getElementById('chart-learning-types-legend');
                return el ? __nl2br(el.textContent || '') : '';
            })();
            // Restore panel styles (do not change the UI state)
            if (__chartsPanel && __chartsPanelPrev) {
                __chartsPanel.style.display = __chartsPanelPrev.display;
                __chartsPanel.style.visibility = __chartsPanelPrev.visibility;
                __chartsPanel.style.position = __chartsPanelPrev.position;
                __chartsPanel.style.left = __chartsPanelPrev.left;
                __chartsPanel.style.top = __chartsPanelPrev.top;
                __chartsPanel.style.width = __chartsPanelPrev.width;
            }

            // Pre-compute project-level competences for inclusion in HTML export
            const __rtCompList = getCompetencesFromUI() || [];
            const __rtCompTList = getCompetencesTransversalesFromUI() || [];

            // Helper to build project-level competences HTML
            const __buildCompListHtml = (title, list) => {
                if (!list || !list.length) return '';
                let s = `<h3>${__esc(title)}</h3><ul>`;
                list.forEach(c => {
                    const label = __esc(String(c.label || c.id || '').trim());
                    const cat = [String(c.categorie || ''), String(c.sousCategorie || '')].filter(Boolean).join(' > ');
                    s += `<li>${label}${cat ? ' <em>(' + __esc(cat) + ')</em>' : ''}</li>`;
                });
                s += `</ul>`;
                return s;
            };

let html = `
            <!DOCTYPE html>
            <html lang="${currentLang}">
            <head>
                <meta charset="UTF-8">
                <title>${t.rtf_title}</title>
                <style>
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1 { color: #4338ca; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
                    h2 { color: #4f46e5; margin-top: 30px; border-left: 4px solid #4f46e5; padding-left: 10px; }
                    h3 { color: #6b7280; margin-top: 20px; text-transform: uppercase; font-size: 0.9em; letter-spacing: 0.05em; }
                    h4 { color: #374151; margin-top: 15px; margin-bottom: 5px; }
                    ul { list-style-type: none; padding-left: 0; }
                    li { margin-bottom: 5px; }
                    .meta-item { margin-bottom: 5px; }
                    .meta-label { font-weight: bold; color: #555; }
                    .activity-block { margin-bottom: 40px; border: none; border-radius: 8px; padding: 20px; background-color: #f8fafc; }
                    .step-block { margin-left: 20px; margin-bottom: 20px; padding: 15px; background-color: white; border-left: 4px solid #cbd5e1; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; margin-right: 5px; }
                    .task-box { background-color: #f1f5f9; padding: 10px; border-radius: 4px; margin-top: 10px; font-style: italic; }

                    .type-acquisition { border-color: #a1f5ed; } .bg-none { background-color: #e5e7eb; }
 .bg-acquisition { background-color: #7dded6; color: #0f766e; }
                    .type-collaboration { border-color: #ffd966; } .bg-collaboration { background-color: #f0c953; color: #854d0e; }
                    .type-discussion { border-color: #7aaeea; } .bg-discussion { background-color: #6a9bd6; color: #1e40af; }
                    .type-investigation { border-color: #f8807f; } .bg-investigation { background-color: #e06e6d; color: #991b1b; }
                    .type-practice { border-color: #bb98dc; } .bg-practice { background-color: #a582c6; color: #6b21a8; }
                    .type-production { border-color: #bdea75; } .bg-production { background-color: #a6d15e; color: #3f6212; }



  #timeline-panel #timeline-activities{ overflow: visible !important; }

</style>
            </head>
            <body>
                <h1>${t.rtf_title}</h1>
                
                <h2 data-i18n="heading_metadata">Métadonnées</h2>
                <div class="meta-item"><span class="meta-label">${t.label_course_name}:</span> ${__esc(document.getElementById('param-name')?.value)}</div>                <div class="meta-item"><span class="meta-label">${t.label_authors}:</span> ${__esc(document.getElementById('param-authors')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_trainers || 'Formateur(s)'}:</span> ${__esc(document.getElementById('param-trainers')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label" data-i18n="label_theme_colon">Thème:</span> ${__esc(document.getElementById('param-topic')?.value || '')}</div>
                <div class="meta-item"><span class="meta-label">${t.label_mode}:</span> ${__selTxt(document.getElementById('param-mode'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_level}:</span> ${__selTxt(document.getElementById('param-level'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_class_size}:</span> ${__esc(document.getElementById('global-class-size')?.value)}</div>
                <div class="meta-item"><span class="meta-label">${t.label_total_time}:</span> ${totalDuration}</div>
                <div class="meta-item"><span class="meta-label">${t.label_learning_time}:</span> ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}</div>
                <div class="meta-item"><span class="meta-label">${t.label_designed_time}:</span> ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}</div>
                <h2 data-i18n="heading_analysis_charts">Graphiques d'analyse</h2>
                <div>
                    ${(__charts['chart-learning-types'] ? `<div style="margin: 10px 0 16px 0;">
                        <h3 style="margin: 10px 0 6px 0;">Types d'apprentissage</h3>
                        <img alt="Types d'apprentissage" src="${__charts['chart-learning-types']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                        ${(__legendHtml ? `<div style="margin-top:8px; font-size: 12px; color:#374151;">${__legendHtml}</div>` : ``)}
                    </div>` : ``)}
                    ${(__charts['chart-group-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de groupes</h3>
                        <img alt="Modes de groupes" src="${__charts['chart-group-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-place-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de lieu</h3>
                        <img alt="Modes de lieu" src="${__charts['chart-place-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-time-modes'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Modes de temps</h3>
                        <img alt="Modes de temps" src="${__charts['chart-time-modes']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                    ${(__charts['chart-trainer-presence'] ? `<div style="margin-bottom:16px;">
                        <h3 style="margin: 10px 0 6px 0;">Présence du formateur</h3>
                        <img alt="Présence du formateur" src="${__charts['chart-trainer-presence']}" style="max-width:100%; height:auto; border:1px solid #e2e8f0; border-radius:8px; background:#fff; padding:8px;"/>
                    </div>` : ``)}
                </div>

                
                <h2>Informations clés</h2>
                <h3>${t.label_description}</h3>
                <p>${__nl2br(document.getElementById('param-description')?.value)}</p>

                <h3>${t.label_target_audience}</h3>
                <p>${__nl2br(document.getElementById('param-target-audience')?.value || '')}</p>

                <h3>${t.label_prerequisites}</h3>
                <p>${__nl2br(document.getElementById('param-prerequisites')?.value || '')}</p>

                <h3>${t.label_tools_materials || 'Outils et matériel'}</h3>
                <p>${__nl2br(document.getElementById('param-tools-materials')?.value || '')}</p>
                ${(() => { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? `<p><strong>${t.label_notes || 'Notes'}:</strong> ${__nl2br(__n)}</p>` : ''; })()}

                <h3>${t.label_aims}</h3>
                <p>${__nl2br(document.getElementById('param-aims')?.value)}</p>

                <h3>${t.label_outcomes_text}</h3>
                <p>${__nl2br(document.getElementById('param-outcomes-text')?.value || '')}</p>

                <h3>${t.label_outcomes}</h3>
                <ul>`;
                
document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomText = "";
                if(level) {
                    bloomText += `<strong>[${__esc(t[`bloom_${level}`] || level.toUpperCase())}`;
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "]</strong> ";
                }
                html += `<li>${bloomText}${__esc(text)}</li>`;
            });

            html += `</ul>

                `;

            html += __buildCompListHtml('Compétences du sujet', __rtCompList);
            html += __buildCompListHtml('Compétences transversales', __rtCompTList);

            html += `<h2>Structure pédagogique</h2>`;

            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                // Prefix "Module" (FR) without altering any existing translation strings
                let modPrefix = t.md_untitled_activity;
                modPrefix = modPrefix.replace(' sans titre', '');

                html += `<div class="activity-block">
                    <h3 style="color: #1e293b; font-size: 1.2em; border-bottom: 1px solid #cbd5e1; padding-bottom: 10px;">${modPrefix} ${aIdx + 1}: ${__esc(moduleTitle)}</h3>
                    ${moduleDesc ? `<p><em>${__nl2br(moduleDesc)}</em></p>` : ''}`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 6px;"><strong>Durée cible :</strong> ${__esc(moduleTgtVal)} ${__esc(moduleTgtUnitTxt)}</div>`;
                }

                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                    const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
                    const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                    const __mCs = __idsToLabels(__mCsIds, __compMap);
                    const __mCt = __idsToLabels(__mCtIds, __compTMap);
                    if (__modAims.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 6px;"><strong>Objectifs du module (sélection) :</strong> ${__modAims.map(__esc).join(' ; ')}</div>`;
                    if (__modOut.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Résultats du module (sélection) :</strong> ${__modOut.map(__esc).join(' ; ')}</div>`;
                    if (__mCs.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (sujet) :</strong> ${__mCs.map(__esc).join(', ')}</div>`;
                    if (__mCt.length) html += `<div style="font-size:0.9em; color:#475569; margin-top: 4px;"><strong>Compétences du module (transversales) :</strong> ${__mCt.map(__esc).join(', ')}</div>`;
                } catch(_){ __ldSilentErr(_); }

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepsNodeList, momentNumberPrefix) => {
                    stepsNodeList.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title')?.value || t.md_untitled_step;

                        // Grouping (mode + optional size + optional details)
                        const groupModeEl = step.querySelector('.step-group-mode');
                        const groupModeVal = groupModeEl ? groupModeEl.value : '';
                        const groupModeTxt = groupModeEl && groupModeEl.selectedOptions && groupModeEl.selectedOptions[0]
                            ? (groupModeEl.selectedOptions[0].innerText || '').trim()
                            : '';
                        const groupSizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const groupCountVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const groupDetailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();
                        let groupInfo = groupModeTxt;
                        if (groupModeVal === 'groups') {
                            const bits = [];
                            if (groupSizeVal) bits.push(groupSizeVal);
                            if (groupCountVal) bits.push(`nb groupes: ${groupCountVal}`);
                            if (bits.length) groupInfo = `${groupModeTxt} (${bits.join(', ')})`;
                        }
                        if (groupDetailsVal) groupInfo = groupInfo ? `${groupInfo} — ${groupDetailsVal}` : groupDetailsVal;

                        // Step content
                        const objective = (step.querySelector('.step-input-objective')?.value || '').trim();
                        const tasks = (step.querySelector('.step-input-tasks')?.value || '').trim();
                        const trainerTasks = (step.querySelector('.step-input-trainer-tasks')?.value || '').trim();
                        const evalFollowup = (step.querySelector('.step-input-eval-followup')?.value || '').trim();
                        const notes = (step.querySelector('.step-input-notes')?.value || '').trim();
                        const linksRefs = (step.querySelector('.step-input-linksrefs')?.value || '').trim();

                        // Competences
                        const csSel = step.querySelector('.step-competences-select');
                        const ctSel = step.querySelector('.step-competences-transversales-select');
                        const cs = Array.from(csSel?.selectedOptions || []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const ct = Array.from(ctSel?.selectedOptions || []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const compSujetHtml = cs.length ? cs.map(__esc).join(', ') : '—';
                        const compTransHtml = ct.length ? ct.map(__esc).join(', ') : '—';

                        // Tags / modality
                        const typeKey = step.querySelector('.learning-type-select')?.value || '';
                        const typeLabel = t[`type_${typeKey}`] || '';
                        const trainerText = step.querySelector('.trainer-select')?.selectedOptions?.[0]?.innerText || '';
                        const placeText = step.querySelector('.place-select')?.selectedOptions?.[0]?.innerText || '';
                        const timeText = step.querySelector('.time-select')?.selectedOptions?.[0]?.innerText || '';
                        const evaluationText = step.querySelector('.evaluation-select')?.value || 'Aucune';

                        const durVal = step.querySelector('.duration-input')?.value || '';
                        const durUnitTxt = step.querySelector('.duration-unit')?.selectedOptions?.[0]?.innerText || '';
                        const duration = `${durVal} ${durUnitTxt}`.trim();

                        const activityNumber = `${momentNumberPrefix}.${sIdx + 1}`;
                        const __ignored = (typeof __ldIsIgnored==='function') ? !!__ldIsIgnored(step) : false;

                        html += `<div class="step-block type-${typeKey}">
                            <h4>${activityNumber}. ${__ignored ? '<span style="color:#b91c1c; font-weight:700;">[IGNORÉ]</span> ' : ''}${__esc(stepTitle)} <span class="tag bg-${typeKey}" style="float: right;">${__esc(typeLabel)}</span></h4>
                            <div style="font-size: 0.9em; color: #64748b; margin-bottom: 10px;">
                                <strong>Durée :</strong> ${__esc(duration)} | <strong>Évaluation :</strong> ${__esc(evaluationText)} |
                                <strong>Regroupement :</strong> ${__esc(groupInfo)} |
                                <strong>Modalité :</strong> ${__esc(trainerText)}, ${__esc(placeText)}, ${__esc(timeText)}<br>
                                <strong>Compétences du sujet :</strong> ${compSujetHtml}<br>
                                <strong>Compétences transversales :</strong> ${compTransHtml}
                                <br><strong>Objectifs ciblés :</strong> ${Array.from(step.querySelector('.step-aims-select')?.selectedOptions || []).map(o => __esc((o.value||'').toString().trim())).filter(Boolean).join(' ; ') || '—'}
                                <br><strong>Résultats ciblés :</strong> ${Array.from(step.querySelector('.step-outcomes-select')?.selectedOptions || []).map(o => __esc((o.value||'').toString().trim())).filter(Boolean).join(' ; ') || '—'}
                                <br><strong>Outils et matériel (activité) :</strong> ${(() => { const parts = (typeof formatSelectedStepToolsMaterialsWithNotes==='function') ? formatSelectedStepToolsMaterialsWithNotes(step) : Array.from(step.querySelector('.step-tools-materials-select')?.selectedOptions || []).map(o => (o.value||'').toString().trim()).filter(Boolean); return parts.map(p => __esc(String(p||'').trim())).filter(Boolean).join(' ; ') || '—'; })()}
                            </div>
                            ${objective ? `<div class="task-box"><strong>Objectif de l'activité :</strong><br>${__nl2br(objective)}</div>` : ''}
                            ${tasks ? `<div class="task-box"><strong>${t.label_tasks}:</strong><br>${__nl2br(tasks)}</div>` : ''}
                            ${trainerTasks ? `<div class="task-box"><strong>Ce que le formateur doit faire :</strong><br>${__nl2br(trainerTasks)}</div>` : ''}
                            ${evalFollowup ? `<div class="task-box"><strong>Évaluation / suivi :</strong><br>${__nl2br(evalFollowup)}</div>` : ''}
                            ${notes ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>${t.label_notes}:</strong> ${__nl2br(notes)}</div>` : ''}
                            ${linksRefs ? `<div style="margin-top: 10px; font-size: 0.9em; color: #475569;"><strong>Liens / références :</strong> ${__nl2br(linksRefs)}</div>` : ''}
                        </div>`;
                    });
                };

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                        try { if (typeof __ldIsIgnored==='function' && __ldIsIgnored(step)) return; } catch(_){ __ldSilentErr(_); }
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;
                        const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                        const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';

                        // Check for sub-moments
                        const submomentEls = momentEl.querySelectorAll('.submoment-card');
                        const hasSubmoments = submomentEls && submomentEls.length > 0;

                        if (hasSubmoments) {
                            // Moment has sub-moments
                            let totalMomentSecs = 0;
                            submomentEls.forEach(smEl => {
                                const smSteps = __ldQueryAllDesignedStepCards(smEl);
                                totalMomentSecs += calcMomentSecs(smSteps);
                            });

                            html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(momentEl)) ? ' [IGNORÉ]' : ''}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(totalMomentSecs)})</span></h3>`;
                            if (mTgtVal) {
                                html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                            }
                            if (mDesc) {
                                html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                            }

                            // Export each sub-moment
                            submomentEls.forEach((smEl, smIdx) => {
                                const smTitle = (smEl.querySelector('.submoment-title')?.value || '').trim();
                                const smSteps = __ldQueryAllDesignedStepCards(smEl);
                                const smSecs = calcMomentSecs(smSteps);
                                const smPrefix = `${momentPrefix}.${smIdx + 1}`;

                                const smTgtVal = (smEl.querySelector('.submoment-target-time')?.value || '').trim();
                                const smTgtUnitTxt = smEl.querySelector('.submoment-target-unit')?.selectedOptions?.[0]?.innerText || '';

                                html += `<h4 style="margin-top: 14px; margin-left: 20px; color: #475569; font-size: 0.95em;">Sous-moment ${smPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(smEl)) ? ' [IGNORÉ]' : ''}${smTitle ? ` : ${__esc(smTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(smSecs)})</span></h4>`;
                                if (smTgtVal) {
                                    html += `<div style="font-size: 0.85em; color: #64748b; margin-left: 20px; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(smTgtVal)} ${__esc(smTgtUnitTxt)}</div>`;
                                }

                                renderSteps(smSteps, smPrefix);
                            });
                        } else {
                            // Moment has direct steps
                            const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                            const momentSecs = calcMomentSecs(stepCards);

                            html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(momentEl)) ? ' [IGNORÉ]' : ''}${momentTitle ? ` : ${__esc(momentTitle)}` : ''} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                            if (mTgtVal) {
                                html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}</div>`;
                            }
                            if (mDesc) {
                                html += `<div style="margin-top: 6px;"><strong>Description :</strong><br>${escapeHtml(mDesc).replace(/\n/g,'<br>')}</div>`;
                            }
                            renderSteps(stepCards, momentPrefix);
                        }
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for a complete structure
                    const stepCards = Array.from(activity.querySelectorAll('.step-card') || []);
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;
                    html += `<h3 style="margin-top: 18px; color: #334155; font-size: 1.05em;">Moment ${momentPrefix} <span style="font-weight: normal; color:#64748b;">(${formatTimelineDuration(momentSecs)})</span></h3>`;
                    const mTgtVal0 = (activity.querySelector('.moment-target-time')?.value || '').trim();
                    const mTgtUnitTxt0 = activity.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                    if (mTgtVal0) {
                        html += `<div style="font-size: 0.9em; color: #64748b; margin-top: 4px; margin-bottom: 6px;"><strong>Durée cible :</strong> ${__esc(mTgtVal0)} ${__esc(mTgtUnitTxt0)}</div>`;
                    }
                    renderSteps(stepCards, momentPrefix);
                }

                html += `</div>`;
            });

            html += `
</body></html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('html');
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportRTF() {
            const t = translations[currentLang] || translations.fr;
            const totals = getTotals();
            const totalDuration = fmtTotalDuration(totals.totalSecs, t);
            const courseName = (document.getElementById('param-name')?.value || '').trim();

            const readDurationSecs = (card) => {
                const v = parseFloat(card.querySelector('.duration-input')?.value || '0');
                const unit = parseFloat(card.querySelector('.duration-unit')?.value || 60);
                const secs = (Number.isFinite(v) ? v : 0) * (Number.isFinite(unit) ? unit : 60);
                return secs;
            };

            const fmtTarget = (timeEl, unitEl) => {
                const v = (timeEl?.value || '').toString().trim();
                const u = unitEl?.selectedOptions?.[0]?.innerText || '';
                if (!v) return '';
                return `${v} ${u}`.trim();
            };

            const getSelectedText = (selectEl) => {
                const opt = selectEl && selectEl.selectedOptions ? selectEl.selectedOptions[0] : null;
                return opt ? (opt.innerText || opt.textContent || '').trim() : '';
            };

            const getGroupingText = (stepEl) => {
                const modeEl = stepEl.querySelector('.step-group-mode');
                const modeVal = modeEl ? modeEl.value : '';
                const modeTxt = getSelectedText(modeEl);
                const sizeVal = (stepEl.querySelector('.step-group-size')?.value || '').toString().trim();
                const countVal = (stepEl.querySelector('.step-group-count')?.value || '').toString().trim();
                const detailsVal = (stepEl.querySelector('.step-group-details-notes')?.value || '').toString().trim();

                let txt = modeTxt;
                if (modeVal === 'groups') {
                    const bits = [];
                    if (sizeVal) bits.push(sizeVal);
                    if (countVal) bits.push('nb groupes: ' + countVal);
                    if (bits.length) txt = `${modeTxt} (${bits.join(', ')})`;
                }
                if (detailsVal) txt = txt ? `${txt} — ${detailsVal}` : detailsVal;
                return txt.trim();
            };

            const sumStepsToSecs = (stepCards) => {
                let secs = 0;
                stepCards.forEach(step => {
                try { if (typeof __ldIsIgnored==='function' && __ldIsIgnored(step)) return; } catch(_){ __ldSilentErr(_); } secs += readDurationSecs(step); });
                return secs;
            };

            // RTF header: use ANSI for compatibility but encode all non-ASCII via \uN? (escapeRtf)
            let rtf = '{\\rtf1\\ansi\\ansicpg1252\\uc1\\deff0' +
                '{\\fonttbl{\\f0 Segoe UI;}{\\f1 Arial;}}' +
                '\\fs28\\b ' + escapeRtf(t.rtf_title) + '\\b0\\par\\par' +

                '\\fs24\\b ' + escapeRtf('Métadonnées') + '\\b0\\par' +
                '\\fs20 ' +
                '\\b ' + escapeRtf(t.label_course_name) + ':\\b0 ' + escapeRtf(courseName) + '\\par' +
                '\\b ' + escapeRtf(t.label_authors) + ':\\b0 ' + escapeRtf(document.getElementById('param-authors')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_trainers || 'Formateur(s)') + ':\\b0 ' + escapeRtf(document.getElementById('param-trainers')?.value || '') + '\\par' +
                '\\b Thème:\\b0 ' + escapeRtf(document.getElementById('param-topic')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_mode) + ':\\b0 ' + escapeRtf(document.getElementById('param-mode')?.selectedOptions?.[0]?.innerText || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_level) + ':\\b0 ' + escapeRtf(document.getElementById('param-level')?.selectedOptions?.[0]?.innerText || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_class_size) + ':\\b0 ' + escapeRtf(document.getElementById('global-class-size')?.value || '') + '\\par' +
                '\\b ' + escapeRtf(t.label_total_time) + ':\\b0 ' + escapeRtf(totalDuration) + '\\par' +
                '\\b ' + escapeRtf(t.label_learning_time) + ':\\b0 ' + escapeRtf(((document.getElementById('param-learning-val')?.value || '').toString().trim()) + ' ' + (document.getElementById('param-learning-unit')?.selectedOptions?.[0]?.innerText || '')) + '\\par' +
                '\\b ' + escapeRtf(t.label_designed_time) + ':\\b0 ' + escapeRtf(((document.getElementById('param-designed-val')?.value || '').toString().trim()) + ' ' + (document.getElementById('param-designed-unit')?.selectedOptions?.[0]?.innerText || '')) + '\\par\\par' +

                '\\fs24\\b ' + escapeRtf('Informations clés') + '\\b0\\par' +
                '\\fs20 ' +
                '\\b ' + escapeRtf(t.label_description) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-description')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_target_audience) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-target-audience')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_prerequisites) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-prerequisites')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_tools_materials || 'Outils et matériel') + ':\\b0\\par ' + escapeRtf(document.getElementById('param-tools-materials')?.value || '') + '\\par\\par' +
                (function(){ const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); return __n ? ('\\b ' + escapeRtf(t.label_notes || 'Notes') + ':\\b0\\par ' + escapeRtf(__n) + '\\par\\par') : ''; })() +
                '\\b ' + escapeRtf(t.label_aims) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-aims')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_outcomes_text) + ':\\b0\\par ' + escapeRtf(document.getElementById('param-outcomes-text')?.value || '') + '\\par\\par' +
                '\\b ' + escapeRtf(t.label_outcomes) + ':\\b0\\par ';

            // Outcomes list
            document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                let bloomPrefix = '';
                if (level) {
                    bloomPrefix = '[' + (t[`bloom_${level}`] || level.toUpperCase());
                    if (sub) bloomPrefix += ' - ' + (t[`bloom_sub_${sub}`] || sub);
                    bloomPrefix += '] ';
                }
                rtf += '\\bullet ' + escapeRtf(bloomPrefix + text) + '\\par ';
            });

            // Project-level competences lists
            const __rtfCompList = getCompetencesFromUI() || [];
            const __rtfCompTList = getCompetencesTransversalesFromUI() || [];
            if (__rtfCompList.length) {
                rtf += '\\par\\b ' + escapeRtf('Compétences du sujet :') + '\\b0\\par ';
                __rtfCompList.forEach(c => {
                    const label = String(c.label || c.id || '').trim();
                    const cat = [String(c.categorie || ''), String(c.sousCategorie || '')].filter(Boolean).join(' > ');
                    rtf += '\\bullet ' + escapeRtf(label + (cat ? ' (' + cat + ')' : '')) + '\\par ';
                });
            }
            if (__rtfCompTList.length) {
                rtf += '\\par\\b ' + escapeRtf('Compétences transversales :') + '\\b0\\par ';
                __rtfCompTList.forEach(c => {
                    const label = String(c.label || c.id || '').trim();
                    const cat = [String(c.categorie || ''), String(c.sousCategorie || '')].filter(Boolean).join(' > ');
                    rtf += '\\bullet ' + escapeRtf(label + (cat ? ' (' + cat + ')' : '')) + '\\par ';
                });
            }

            rtf += '\\par\\fs24\\b ' + escapeRtf('Structure pédagogique') + '\\b0\\par\\fs20 ';

            const __rtfCompMap = new Map((__rtfCompList || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
            const __rtfCompTMap = new Map((__rtfCompTList || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
            const __rtfIdsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);

            // Modules designed (current structure)
            let moduleIdx = 0;
            document.querySelectorAll('.activity-group').forEach((moduleEl) => {
                moduleIdx += 1;
                const moduleTitle = (moduleEl.querySelector('.activity-title')?.value || '').trim() || `${t.md_module} ${moduleIdx}`;
                const moduleDesc = (moduleEl.querySelector('.activity-description')?.value || '').trim();
                const moduleNotes = (moduleEl.querySelector('.module-notes')?.value || '').trim();
                const moduleTarget = fmtTarget(moduleEl.querySelector('.activity-target-time'), moduleEl.querySelector('.activity-target-unit'));

                rtf += '\\par\\b ' + escapeRtf(`MODULE ${moduleIdx} — `) + escapeRtf(moduleTitle) + '\\b0\\par ';
                if (moduleTarget) rtf += escapeRtf(`Durée cible : ${moduleTarget}`) + '\\par ';
                if (moduleDesc) rtf += escapeRtf(`Description : ${moduleDesc}`) + '\\par ';
                if (moduleNotes) rtf += escapeRtf(`Notes : ${moduleNotes}`) + '\\par ';

                // Module-level selections
                try {
                    const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(moduleEl) || []) : [];
                    const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(moduleEl) || []) : [];
                    const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(moduleEl) || []) : [];
                    const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(moduleEl) || []) : [];
                    const __mCs = __rtfIdsToLabels(__mCsIds, __rtfCompMap);
                    const __mCt = __rtfIdsToLabels(__mCtIds, __rtfCompTMap);
                    if (__modAims.length) rtf += escapeRtf(`Objectifs du module (sélection) : ${__modAims.join(' ; ')}`) + '\\par ';
                    if (__modOut.length) rtf += escapeRtf(`Résultats du module (sélection) : ${__modOut.join(' ; ')}`) + '\\par ';
                    if (__mCs.length) rtf += escapeRtf(`Compétences du module (sujet) : ${__mCs.join(', ')}`) + '\\par ';
                    if (__mCt.length) rtf += escapeRtf(`Compétences du module (transversales) : ${__mCt.join(', ')}`) + '\\par ';
                } catch(_){ __ldSilentErr(_); }

                const momentEls = moduleEl.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                const renderSteps = (stepCards, prefix) => {
                    stepCards.forEach((stepEl, sIdx) => {
                        const stepTitle = (stepEl.querySelector('.step-input-title')?.value || '').trim() || `${t.md_step} ${sIdx + 1}`;
                        const __ignored = (typeof __ldIsIgnored==='function') ? !!__ldIsIgnored(stepEl) : false;
                        const objective = (stepEl.querySelector('.step-input-objective')?.value || '').trim();
                        const tasks = (stepEl.querySelector('.step-input-tasks')?.value || '').trim();
                        const trainerTasks = (stepEl.querySelector('.step-input-trainer-tasks')?.value || '').trim();
                        const evalFollowup = (stepEl.querySelector('.step-input-eval-followup')?.value || '').trim();
                        const notes = (stepEl.querySelector('.step-input-notes')?.value || '').trim();

                        const sSecs = readDurationSecs(stepEl);
                        const lt = getSelectedText(stepEl.querySelector('.learning-type-select'));
                        const grouping = getGroupingText(stepEl);
                        const place = getSelectedText(stepEl.querySelector('.place-select'));
                        const time = getSelectedText(stepEl.querySelector('.time-select'));
                        const trainer = getSelectedText(stepEl.querySelector('.trainer-select'));

                        const stepPrefix = `${prefix}.${sIdx + 1}`;
                        rtf += '\\par\\b ' + escapeRtf(`      Activité ${stepPrefix} — `) + escapeRtf((__ignored ? '[IGNORÉ] ' : '') + stepTitle) + '\\b0\\par ';
                        rtf += escapeRtf(`      Durée conçue : ${formatTimelineDuration(sSecs)}`) + '\\par ';
                        if (lt) rtf += escapeRtf(`      Type d'apprentissage : ${lt}`) + '\\par ';
                        if (grouping) rtf += escapeRtf(`      Regroupement : ${grouping}`) + '\\par ';
                        if (trainer || place || time) {
                            const parts = [];
                            if (trainer) parts.push(`Présence formateur : ${trainer}`);
                            if (place) parts.push(`Lieu : ${place}`);
                            if (time) parts.push(`Temps : ${time}`);
                            rtf += escapeRtf(`      Modalité : ${parts.join(' | ')}`) + '\\par ';
                        const evalType = (stepEl.querySelector('.evaluation-select')?.value || 'Aucune');
                        if (evalType) rtf += escapeRtf(`      Évaluation : ${evalType}`) + '\\par ';
                            const __cs = Array.from(stepEl.querySelector('.step-competences-select')?.selectedOptions || []).map(o => (o.textContent || '').trim()).filter(Boolean);
                            const __ct = Array.from(stepEl.querySelector('.step-competences-transversales-select')?.selectedOptions || []).map(o => (o.textContent || '').trim()).filter(Boolean);
                            rtf += escapeRtf(`      Compétences du sujet : ${__cs.length ? __cs.join(', ') : '—'}`) + '\\par ';
                            rtf += escapeRtf(`      Compétences transversales : ${__ct.length ? __ct.join(', ') : '—'}`) + '\\par ';
                            const __aimsSel = Array.from(stepEl.querySelector('.step-aims-select')?.selectedOptions || []).map(o => (o.value||'').toString().trim()).filter(Boolean);
                            const __outsSel = Array.from(stepEl.querySelector('.step-outcomes-select')?.selectedOptions || []).map(o => (o.value||'').toString().trim()).filter(Boolean);
                            const __tmSel = (typeof formatSelectedStepToolsMaterialsWithNotes === 'function') ? formatSelectedStepToolsMaterialsWithNotes(stepEl) : Array.from(stepEl.querySelector('.step-tools-materials-select')?.selectedOptions || []).map(o => (o.value||'').toString().trim()).filter(Boolean);
                            rtf += escapeRtf(`      Objectifs ciblés : ${__aimsSel.length ? __aimsSel.join(' ; ') : '—'}`) + '\\par ';
                            rtf += escapeRtf(`      Résultats ciblés : ${__outsSel.length ? __outsSel.join(' ; ') : '—'}`) + '\\par ';
                            rtf += escapeRtf(`      Outils et matériel (activité) : ${__tmSel.length ? __tmSel.join(' ; ') : '—'}`) + '\\par ';
                        }
                        if (objective) rtf += escapeRtf(`      Objectif : ${objective}`) + '\\par ';
                        if (tasks) rtf += escapeRtf(`      Tâches : ${tasks}`) + '\\par ';
                        if (trainerTasks) rtf += escapeRtf(`      Tâches du formateur : ${trainerTasks}`) + '\\par ';
                        if (evalFollowup) rtf += escapeRtf(`      Évaluation / suivi : ${evalFollowup}`) + '\\par ';
                        if (notes) rtf += escapeRtf(`      Notes : ${notes}`) + '\\par ';
                        const linksRefs = (stepEl.querySelector('.step-input-linksrefs')?.value || '').trim();
                        if (linksRefs) rtf += escapeRtf(`      Liens / références : ${linksRefs}`) + '\\par ';
                    });
                };
                if (hasMoments) {
                    momentEls.forEach((momentEl, moIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const momentDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                        const momentTarget = fmtTarget(momentEl.querySelector('.moment-target-time'), momentEl.querySelector('.moment-target-unit'));
                        const momentPrefix = `${moduleIdx}.${moIdx + 1}`;

                        // Check for sub-moments
                        const submomentEls = momentEl.querySelectorAll('.submoment-card');
                        const hasSubmoments = submomentEls && submomentEls.length > 0;

                        if (hasSubmoments) {
                            // Moment has sub-moments
                            let totalMomentSecs = 0;
                            submomentEls.forEach(smEl => {
                                const smSteps = __ldQueryAllDesignedStepCards(smEl);
                                totalMomentSecs += sumStepsToSecs(smSteps);
                            });

                            rtf += '\\par\\b ' + escapeRtf(`  Moment ${momentPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(momentEl)) ? ' [IGNORÉ]' : ''}`) + escapeRtf(momentTitle ? ` — ${momentTitle}` : '') + '\\b0\\par ';
                            rtf += escapeRtf(`  Durée conçue : ${formatTimelineDuration(totalMomentSecs)}`) + '\\par ';
                            if (momentTarget) rtf += escapeRtf(`  Durée cible : ${momentTarget}`) + '\\par ';
                            if (momentDesc) rtf += escapeRtf(`  Description : ${momentDesc}`) + '\\par ';

                            // Export each sub-moment
                            submomentEls.forEach((smEl, smIdx) => {
                                const smTitle = (smEl.querySelector('.submoment-title')?.value || '').trim();
                                const smTarget = fmtTarget(smEl.querySelector('.submoment-target-time'), smEl.querySelector('.submoment-target-unit'));
                                const smSteps = __ldQueryAllDesignedStepCards(smEl);
                                const smSecs = sumStepsToSecs(smSteps);
                                const smPrefix = `${momentPrefix}.${smIdx + 1}`;

                                rtf += '\\par\\b ' + escapeRtf(`    Sous-moment ${smPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(smEl)) ? ' [IGNORÉ]' : ''}`) + escapeRtf(smTitle ? ` — ${smTitle}` : '') + '\\b0\\par ';
                                rtf += escapeRtf(`    Durée conçue : ${formatTimelineDuration(smSecs)}`) + '\\par ';
                                if (smTarget) rtf += escapeRtf(`    Durée cible : ${smTarget}`) + '\\par ';

                                renderSteps(smSteps, smPrefix);
                            });
                        } else {
                            // Moment has direct steps
                            const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                            const momentSecs = sumStepsToSecs(stepCards);

                            rtf += '\\par\\b ' + escapeRtf(`  Moment ${momentPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(momentEl)) ? ' [IGNORÉ]' : ''}`) + escapeRtf(momentTitle ? ` — ${momentTitle}` : '') + '\\b0\\par ';
                            rtf += escapeRtf(`  Durée conçue : ${formatTimelineDuration(momentSecs)}`) + '\\par ';
                            if (momentTarget) rtf += escapeRtf(`  Durée cible : ${momentTarget}`) + '\\par ';
                            if (momentDesc) rtf += escapeRtf(`  Description : ${momentDesc}`) + '\\par ';

                            renderSteps(stepCards, momentPrefix);
                        }
                    });
                } else {
                    // Legacy designs (no moments): export as a single moment for completeness
                    const stepCards = Array.from(moduleEl.querySelectorAll('.step-card') || []);
                    const momentSecs = sumStepsToSecs(stepCards);
                    const momentPrefix = `${moduleIdx}.1`;

                    rtf += '\\par\\b ' + escapeRtf(`  Moment ${momentPrefix}`) + '\\b0\\par ';
                    rtf += escapeRtf(`  Durée conçue : ${formatTimelineDuration(momentSecs)}`) + '\\par ';

                    const legacyTarget = fmtTarget(moduleEl.querySelector('.moment-target-time'), moduleEl.querySelector('.moment-target-unit'));
                    if (legacyTarget) rtf += escapeRtf(`  Durée cible : ${legacyTarget}`) + '\\par ';

                    renderSteps(stepCards, momentPrefix);
                }
            });

            rtf += '}';

            const blob = new Blob([rtf], { type: 'application/rtf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('rtf');
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportMarkdown() {
            const data = getTotals();
            const t = translations[currentLang];
            const __esc = (v) => escapeHtml(String(v ?? ''));
            const __selTxt = (el) => __esc((el && el.selectedOptions && el.selectedOptions[0]) ? el.selectedOptions[0].innerText : '');
            let md = `# ${t.md_title}\n\n`;
            md += `## métadonnées\n`;
            md += `- **${t.label_course_name}:** ${__esc(document.getElementById('param-name')?.value)}\n`;
            md += `- **${t.label_authors}:** ${__esc(document.getElementById('param-authors')?.value)}\n`;
            md += `- **${t.label_trainers || 'Formateur(s)'}:** ${__esc(document.getElementById('param-trainers')?.value || '')}\n`;
            md += `- **Thème:** ${__esc(document.getElementById('param-topic')?.value || '')}\n`;
            md += `- **${t.label_mode}:** ${__selTxt(document.getElementById('param-mode'))}\n`;
            md += `- **${t.label_level}:** ${__selTxt(document.getElementById('param-level'))}\n`;
            md += `- **${t.label_class_size}:** ${__esc(document.getElementById('global-class-size')?.value)}\n`;
            md += `- **${t.label_total_time}:** ${fmtTotalDuration(data.totalSecs, t)}\n`;
            md += `- **${t.label_learning_time}:** ${__esc(document.getElementById('param-learning-val')?.value)} ${__selTxt(document.getElementById('param-learning-unit'))}\n`;
            md += `- **${t.label_designed_time}:** ${__esc(document.getElementById('param-designed-val')?.value)} ${__selTxt(document.getElementById('param-designed-unit'))}\n`; 
md += `- **Horodatage d'export :** ${new Date().toISOString()}\n\n`;
            
            md += `## informations_clés\n`;
            md += `### ${t.label_target_audience}\n${document.getElementById('param-target-audience')?.value || ''}\n\n`;
            md += `### ${t.label_prerequisites}\n${document.getElementById('param-prerequisites')?.value || ''}\n\n`;
            md += `### ${t.label_tools_materials || 'Outils et matériel'}\n${document.getElementById('param-tools-materials')?.value || ''}\n\n`;
            { const __n=(document.getElementById('param-tools-materials-notes')?.value||'').trim(); if(__n){ md += `### ${t.label_notes || 'Notes'}\n${__n}\n\n`; } }
            md += `### ${t.label_aims}\n${document.getElementById('param-aims').value}\n\n`;
            md += `### ${t.label_outcomes_text}\n${document.getElementById('param-outcomes-text')?.value || ''}\n\n`;
            md += `### ${t.label_outcomes}\n`;
            document.querySelectorAll('#outcomes-list li').forEach(li => {
                const text = li.querySelector('.outcome-text')?.innerText || '';
                const level = li.querySelector('.outcome-bloom-level')?.value || '';
                const sub = li.querySelector('.outcome-bloom-sub')?.value || '';
                
                let bloomText = "";
                if(level) {
                    bloomText += "[" + (t[`bloom_${level}`] || level.toUpperCase());
                    if(sub) bloomText += ` - ${__esc(t[`bloom_sub_${sub}`] || sub)}`;
                    bloomText += "] ";
                }
                
                md += `- ${bloomText}${text}\n`;
            });
            md += `\n### ${t.label_description}\n${document.getElementById('param-description').value}\n\n`;

            const __mdCompList = getCompetencesFromUI() || [];
            const __mdCompTList = getCompetencesTransversalesFromUI() || [];
            if (__mdCompList.length) {
                md += `### Compétences du sujet\n`;
                __mdCompList.forEach(c => {
                    const label = String(c.label || c.id || '').trim();
                    const cat = [String(c.categorie || ''), String(c.sousCategorie || '')].filter(Boolean).join(' > ');
                    md += `- ${label}${cat ? ' (' + cat + ')' : ''}\n`;
                });
                md += `\n`;
            }
            if (__mdCompTList.length) {
                md += `### Compétences transversales\n`;
                __mdCompTList.forEach(c => {
                    const label = String(c.label || c.id || '').trim();
                    const cat = [String(c.categorie || ''), String(c.sousCategorie || '')].filter(Boolean).join(' > ');
                    md += `- ${label}${cat ? ' (' + cat + ')' : ''}\n`;
                });
                md += `\n`;
            }

            md += `## structure_pédagogique

`;

            const __compMap = new Map((getCompetencesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
            const __compTMap = new Map((getCompetencesTransversalesFromUI() || []).map(c => [String(c.id||'').trim(), String(c.label||c.id||'').trim()]));
            const __idsToLabels = (ids, mp) => (Array.isArray(ids) ? ids.map(x => String(x||'').trim()).filter(Boolean).map(id => mp.get(id) || id) : []);
            document.querySelectorAll('.activity-group').forEach((activity, aIdx) => {
                const moduleTitle = activity.querySelector('.activity-title').value || t.md_untitled_activity;
                const moduleDesc = activity.querySelector('.activity-description').value;

                const moduleNotes = (activity.querySelector('.module-notes')?.value || '').trim();

                md += `### MODULE ${aIdx + 1} : ${moduleTitle.toUpperCase()}

`;
                if (moduleDesc) md += `> ${moduleDesc}

`;
                if (moduleNotes) md += `- **Notes du module :** ${moduleNotes}
`;

                const moduleTgtVal = (activity.querySelector('.activity-target-time')?.value || '').trim();
                const moduleTgtUnitTxt = activity.querySelector('.activity-target-unit')?.selectedOptions?.[0]?.innerText || '';
                if (moduleTgtVal) {
                    md += `- **Durée cible :** ${moduleTgtVal} ${moduleTgtUnitTxt}
`;
                    md += `
`;
                }

                // Sélections au niveau du module (objectifs / résultats / compétences)
                const __modAims = (typeof getModuleSelectedAims === 'function') ? (getModuleSelectedAims(activity) || []) : [];
                const __modOut = (typeof getModuleSelectedOutcomes === 'function') ? (getModuleSelectedOutcomes(activity) || []) : [];
                const __mCsIds = (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? (getSelectedModuleTargetCompetencesSujetIds(activity) || []) : [];
                const __mCtIds = (typeof getSelectedModuleTargetCompetencesTransversalesIds === 'function') ? (getSelectedModuleTargetCompetencesTransversalesIds(activity) || []) : [];
                const __mCs = __idsToLabels(__mCsIds, __compMap);
                const __mCt = __idsToLabels(__mCtIds, __compTMap);
                if (__modAims.length) md += `- **Objectifs du module (sélection) :** ${__modAims.join(' ; ')}
`;
                if (__modOut.length) md += `- **Résultats du module (sélection) :** ${__modOut.join(' ; ')}
`;
                if (__mCs.length) md += `- **Compétences du module (sujet) :** ${__mCs.join(', ')}
`;
                if (__mCt.length) md += `- **Compétences du module (transversales) :** ${__mCt.join(', ')}
`;
                if (__modAims.length || __modOut.length || __mCs.length || __mCt.length) md += `
`;

                const calcMomentSecs = (stepCards) => {
                    let secs = 0;
                    stepCards.forEach(step => {
                                try { if (typeof __ldIsIgnored==='function' && __ldIsIgnored(step)) return; } catch(_){ __ldSilentErr(_); }
                        const v = parseFloat(step.querySelector('.duration-input')?.value) || 0;
                        const u = parseFloat(step.querySelector('.duration-unit')?.value) || 60;
                        secs += (v * u);
                    });
                    return secs;
                };

                const renderSteps = (stepCards, momentPrefix) => {
                    stepCards.forEach((step, sIdx) => {
                        const stepTitle = step.querySelector('.step-input-title').value || t.md_untitled_step;
                        const typeKey = step.querySelector('.learning-type-select').value;
                        const typeLabel = t[`type_${typeKey}`] || "";
                        const groupModeEl = step.querySelector('.step-group-mode');
                        const groupModeVal = groupModeEl ? groupModeEl.value : '';
                        const groupModeTxt = (groupModeEl && groupModeEl.selectedOptions && groupModeEl.selectedOptions[0]) ? ((groupModeEl.selectedOptions[0].innerText || '').trim()) : groupModeVal;
                        const groupSizeVal = (step.querySelector('.step-group-size')?.value || '').toString().trim();
                        const groupCountVal = (step.querySelector('.step-group-count')?.value || '').toString().trim();
                        const groupDetailsVal = (step.querySelector('.step-group-details-notes')?.value || '').toString().trim();

                        let groupInfo = groupModeTxt || groupModeVal;
                        if (groupModeVal === 'groups') {
                            const bits = [];
                            if (groupSizeVal) bits.push('taille: ' + groupSizeVal);
                            if (groupCountVal) bits.push('nb groupes: ' + groupCountVal);
                            if (bits.length) groupInfo = `${groupModeTxt} (${bits.join(', ')})`;
                        }
                        if (groupDetailsVal) groupInfo = groupInfo ? `${groupInfo} — ${groupDetailsVal}` : groupDetailsVal;
                        const trainerText = step.querySelector('.trainer-select').selectedOptions[0].innerText;
                        const placeText = step.querySelector('.place-select').selectedOptions[0].innerText;
                        const timeText = step.querySelector('.time-select').selectedOptions[0].innerText;

                        const objective = step.querySelector('.step-input-objective').value || "Non renseigné";
                        const tasks = step.querySelector('.step-input-tasks').value || "Non renseigné";
                        const trainerTasks = step.querySelector('.step-input-trainer-tasks')?.value || "Non renseigné";
                        const evalFollowup = step.querySelector('.step-input-eval-followup')?.value || "Non renseigné";
                        const notes = step.querySelector('.step-input-notes').value || "Non renseigné";

                        const activityNum = `${momentPrefix}.${sIdx + 1}`;
                        const __ignored = (typeof __ldIsIgnored==='function') ? !!__ldIsIgnored(step) : false;

                        md += `##### ACTIVITÉ ${activityNum} : ${__ignored ? '[IGNORÉ] ' : ''}${stepTitle}
`;
                        md += `- **Type :** ${typeLabel}
`;
                        md += `- **Durée :** ${step.querySelector('.duration-input').value} ${step.querySelector('.duration-unit').selectedOptions[0].innerText}
`;
                        md += `- **Regroupement :** ${groupInfo}
`;
                        md += `- **Modalité :** ${trainerText}, ${placeText}, ${timeText}
`;
                                                md += `- **Évaluation :** ${step.querySelector('.evaluation-select')?.value || 'Aucune'}
`;
const __csSel = step.querySelector('.step-competences-select');
                        const __ctSel = step.querySelector('.step-competences-transversales-select');
                        const __cs = Array.from((__csSel && __csSel.selectedOptions) ? __csSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __ct = Array.from((__ctSel && __ctSel.selectedOptions) ? __ctSel.selectedOptions : []).map(o => (o.textContent || '').trim()).filter(Boolean);
                        const __csTxt = __cs.length ? __cs.map(__esc).join(', ') : '—';
                        const __ctTxt = __ct.length ? __ct.map(__esc).join(', ') : '—';
                        const compSujetHtml = __csTxt;
                        const compTransHtml = __ctTxt;
                        md += `- **Compétences du sujet :** ${__csTxt}
`;
                        md += `- **Compétences transversales :** ${__ctTxt}
`;
                        const __aimsT = Array.from(step.querySelector('.step-aims-select')?.selectedOptions || []).map(o => (o.value || '').toString().trim()).filter(Boolean);
                        const __outT = Array.from(step.querySelector('.step-outcomes-select')?.selectedOptions || []).map(o => (o.value || '').toString().trim()).filter(Boolean);
                        const __tmT = (typeof formatSelectedStepToolsMaterialsWithNotes === 'function') ? formatSelectedStepToolsMaterialsWithNotes(step) : Array.from(step.querySelector('.step-tools-materials-select')?.selectedOptions || []).map(o => (o.value || '').toString().trim()).filter(Boolean);
                        md += `- **Objectifs ciblés :** ${__aimsT.length ? __aimsT.join(' ; ') : '—'}
`;
                        md += `- **Résultats ciblés :** ${__outT.length ? __outT.join(' ; ') : '—'}
`;
                        md += `- **Outils et matériel (activité) :** ${__tmT.length ? __tmT.join(' ; ') : '—'}
`;
                        md += `- **Objectif de l'activité :** ${objective}

`;
                        md += `**Ce que les apprenants doivent faire :**
${tasks}

`;
                        md += `**Ce que le formateur doit faire :**
${trainerTasks}

`;
                        md += `**Évaluation / suivi :**
${evalFollowup}

`;
                        md += `**Notes pédagogiques :**
${notes}

`;
                        const linksRefs = (step.querySelector('.step-input-linksrefs')?.value || '').trim();
                        if (linksRefs) {
                            md += `**Liens / références :**
${linksRefs}

`;
                        }
                    });
                };

                const momentEls = activity.querySelectorAll('.moment-group');
                const hasMoments = momentEls && momentEls.length > 0;

                if (hasMoments) {
                    momentEls.forEach((momentEl, mIdx) => {
                        const momentTitle = (momentEl.querySelector('.moment-title')?.value || '').trim();
                        const momentPrefix = `${aIdx + 1}.${mIdx + 1}`;

                        // Vérifier si le moment contient des sous-moments
                        const submomentEls = momentEl.querySelectorAll('.submoment-card');
                        const hasSubmoments = submomentEls && submomentEls.length > 0;

                        if (hasSubmoments) {
                            // Le moment contient des sous-moments
                            // Calculer la durée totale du moment (somme de tous les sous-moments)
                            let totalMomentSecs = 0;
                            submomentEls.forEach(smEl => {
                                const smSteps = __ldQueryAllDesignedStepCards(smEl);
                                totalMomentSecs += calcMomentSecs(smSteps);
                            });

                            md += `#### MOMENT ${momentPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(momentEl)) ? ' [IGNORÉ]' : ''}${momentTitle ? ` : ${__esc(momentTitle)}` : ''}
`;
                            md += `- **Durée conçue :** ${formatTimelineDuration(totalMomentSecs)}
`;

                            const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                            const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                            if (mTgtVal) md += `- **Durée cible :** ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}
`;
                            const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                            if (mDesc) md += `- **Description :**\n${mDesc}\n`;
                            md += `

`;

                            // Exporter chaque sous-moment
                            submomentEls.forEach((smEl, smIdx) => {
                                const smTitle = (smEl.querySelector('.submoment-title')?.value || '').trim();
                                const smSteps = __ldQueryAllDesignedStepCards(smEl);
                                const smSecs = calcMomentSecs(smSteps);
                                const smPrefix = `${momentPrefix}.${smIdx + 1}`;

                                md += `##### SOUS-MOMENT ${smPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(smEl)) ? ' [IGNORÉ]' : ''}${smTitle ? ` : ${__esc(smTitle)}` : ''}
`;
                                md += `- **Durée conçue :** ${formatTimelineDuration(smSecs)}
`;

                                const smTgtVal = (smEl.querySelector('.submoment-target-time')?.value || '').trim();
                                const smTgtUnitTxt = smEl.querySelector('.submoment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                                if (smTgtVal) md += `- **Durée cible :** ${__esc(smTgtVal)} ${__esc(smTgtUnitTxt)}
`;
                                md += `

`;

                                // Rendre les activités du sous-moment
                                renderSteps(smSteps, smPrefix);
                            });
                        } else {
                            // Le moment contient des activités directes (pas de sous-moments)
                            const stepCards = momentEl.querySelectorAll('.activity-steps-container .step-card');
                            const momentSecs = calcMomentSecs(stepCards);

                            md += `#### MOMENT ${momentPrefix}${(typeof __ldIsIgnored==='function' && __ldIsIgnored(momentEl)) ? ' [IGNORÉ]' : ''}${momentTitle ? ` : ${__esc(momentTitle)}` : ''}
`;
                            md += `- **Durée conçue :** ${formatTimelineDuration(momentSecs)}
`;

                            const mTgtVal = (momentEl.querySelector('.moment-target-time')?.value || '').trim();
                            const mTgtUnitTxt = momentEl.querySelector('.moment-target-unit')?.selectedOptions?.[0]?.innerText || '';
                            if (mTgtVal) md += `- **Durée cible :** ${__esc(mTgtVal)} ${__esc(mTgtUnitTxt)}
`;
                            const mDesc = (momentEl.querySelector('.moment-description')?.value || '').trim();
                            if (mDesc) md += `- **Description :**\n${mDesc}\n`;
                            md += `

`;

                            renderSteps(stepCards, momentPrefix);
                        }
                    });
                } else {
                    
                    const stepCards = Array.from(activity.querySelectorAll('.step-card') || []);
                    const momentSecs = calcMomentSecs(stepCards);
                    const momentPrefix = `${aIdx + 1}.1`;

                    md += `#### MOMENT ${momentPrefix}
`;
                    md += `- **Durée conçue :** ${formatTimelineDuration(momentSecs)}

`;

                    renderSteps(stepCards, momentPrefix);
                }

                md += `
---

`;
            });
            const blob = new Blob([md], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.__ldBuildExportFilename('md');
            a.click();
            URL.revokeObjectURL(url);
        }

        

        
        function isHighContrastEnabled() {
            return document.body.classList.contains('hc');
        }

        function setHighContrastEnabled(enabled) {
            document.body.classList.toggle('hc', !!enabled);
            if (enabled) { try { document.body.classList.remove('contrast-plus'); } catch(e) {} }
            try {
                localStorage.setItem('ld_palette', enabled ? 'hc' : 'standard');
            } catch (e) {
                
            }
            updateContrastToggleUI();
            
            try { if (typeof syncViewStyleSelect === 'function') syncViewStyleSelect(); } catch (e) {}
            updateStats();
}

        function updateContrastToggleUI() {
            const btn = document.getElementById('contrast-toggle-btn');
            const txt = document.getElementById('contrast-btn-text');
            if (!btn || !txt) return;
            const enabled = isHighContrastEnabled();
            btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
            btn.title = enabled ? "Passer à la palette standard" : "Passer au haut contraste";
            txt.textContent = enabled ? "HC" : "STD";
        }
        function toggleHighContrast(evt) {
            if (evt) { evt.preventDefault(); evt.stopPropagation(); }
            setHighContrastEnabled(!isHighContrastEnabled());
        }

        /* View: contrast+ toggle */
        function isContrastPlusEnabled() {
            return document.body.classList.contains('contrast-plus');
        }

        function setContrastPlusEnabled(enabled) {
            document.body.classList.toggle('contrast-plus', !!enabled);
            try { localStorage.setItem('ld_view_contrast_plus', enabled ? '1' : '0'); } catch (e) {}
            try { if (typeof syncViewStyleSelect === 'function') syncViewStyleSelect(); } catch (e) {}
            try { if (typeof updateStats === 'function') updateStats(); } catch (e) {}
        }

        /* View: transparent block backgrounds toggle */
        function isTransparentBlocksEnabled() {
            return document.body.classList.contains('view-transparent');
        }

        function setTransparentBlocksEnabled(enabled) {
            document.body.classList.toggle('view-transparent', !!enabled);
            if (enabled) { try { document.body.classList.remove('contrast-plus'); } catch(e) {} }
            try {
                localStorage.setItem('ld_view_transparent', enabled ? '1' : '0');
            } catch (e) {
                // fail silently
            }
            updateTransparentBlocksToggleUI();
try { if (typeof syncViewStyleSelect === 'function') syncViewStyleSelect(); } catch (e) {}
        }

        function updateTransparentBlocksToggleUI() {
            const btn = document.getElementById('transparent-blocks-toggle-btn');
            if (!btn) return;
            const txt = document.getElementById('transparent-blocks-btn-text');
            const enabled = isTransparentBlocksEnabled();
            btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
            btn.title = enabled ? 'Désactiver les fonds transparents' : 'Activer les fonds transparents';
            if (txt) txt.textContent = enabled ? 'ON' : 'OFF';
        }

        function toggleTransparentBlocks(evt) {
            if (evt) { evt.preventDefault(); evt.stopPropagation(); }
            setTransparentBlocksEnabled(!isTransparentBlocksEnabled());
        }

        /* View: unified style select (STD / HC / Transparent) */
        function getCurrentViewStyle() {
            if (isTransparentBlocksEnabled()) return 'transparent';
            if (isHighContrastEnabled()) return 'hc';
            if (typeof isContrastPlusEnabled === 'function' && isContrastPlusEnabled()) return 'contrast';
            return 'std';
        }

        function syncViewStyleSelect() {
            const sel = document.getElementById('view-style-select');
            if (!sel) return;
            const v = getCurrentViewStyle();
            if (sel.value !== v) sel.value = v;
        }

        function setViewStyle(mode) {
            const m = String(mode || 'std');
            try { localStorage.setItem('ld_view_mode', m); } catch (e) {}
            if (m === 'transparent') {
                setHighContrastEnabled(false);
                if (typeof setContrastPlusEnabled === 'function') setContrastPlusEnabled(false);
                setTransparentBlocksEnabled(true);
            } else if (m === 'hc') {
                setTransparentBlocksEnabled(false);
                if (typeof setContrastPlusEnabled === 'function') setContrastPlusEnabled(false);
                setHighContrastEnabled(true);
            } else if (m === 'contrast') {
                setTransparentBlocksEnabled(false);
                setHighContrastEnabled(false);
                if (typeof setContrastPlusEnabled === 'function') setContrastPlusEnabled(true);
            } else {
                setTransparentBlocksEnabled(false);
                setHighContrastEnabled(false);
                if (typeof setContrastPlusEnabled === 'function') setContrastPlusEnabled(false);
            }
            syncViewStyleSelect();
        }

        function handleViewStyleChange(selectEl) {
            try {
                setViewStyle(selectEl && selectEl.value);
            } catch (e) {
                console.error('[ViewStyleChangeError]', e);
            }
        }


        /* UI Theme: light / dark */
        function getCurrentUiTheme() {
            return document.documentElement.classList.contains('ui-dark') ? 'dark' : 'light';
        }

        function syncUiThemeSelect() {
            const sel = document.getElementById('ui-theme-select');
            if (!sel) return;
            const v = getCurrentUiTheme();
            if (sel.value !== v) sel.value = v;
        }

        function setUiTheme(mode) {
            const m = (String(mode || 'light')).toLowerCase();
            const dark = (m === 'dark' || m === 'sombre');
            document.documentElement.classList.toggle('ui-dark', dark);
            try { localStorage.setItem('ld_ui_theme', dark ? 'dark' : 'light'); } catch (e) {}
            syncUiThemeSelect();
        }

        function handleUiThemeChange(selectEl) {
            try {
                setUiTheme(selectEl && selectEl.value);
            } catch (e) {
                console.error('[UiThemeChangeError]', e);
            }
        }

/* --- Autosave (LocalStorage) --- */
const AUTOSAVE_KEY = 'ld_autosave_project_v1';
let __autosaveTimer = null;
let __autosaveSuspended = false;

// Micro-optimisation: classify long text edits to reduce timer churn while typing in large textareas.
function __isLongTextEditTarget(el) {
    if (!el) return false;
    const t = (el.tagName || '').toLowerCase();
    if (t !== 'textarea') return false;
    // Treat these as long-text fields (frequent keystrokes)
    if (el.classList?.contains('step-input-objective')) return true;
    if (el.classList?.contains('step-input-tasks')) return true;
    if (el.classList?.contains('step-input-notes')) return true;
    if (el.classList?.contains('moment-description')) return true;
    if (el.classList?.contains('activity-description')) return true;
    // Parameter long text fields
    if (el.id === 'param-description' || el.id === 'param-aims' || el.id === 'param-outcomes-text' || el.id === 'param-prerequisites' || el.id === 'param-target-audience') return true;
    return false;
}

let __lastInputTargetForTimers = null;
document.addEventListener('input', (e) => { __lastInputTargetForTimers = e.target; }, true);
document.addEventListener('change', (e) => { __lastInputTargetForTimers = e.target; }, true);


function scheduleAutosave() {
    if (__autosaveSuspended) return;
    // Ignore changes during print, etc. Keep lightweight.
    if (__autosaveTimer) clearTimeout(__autosaveTimer);
    __autosaveTimer = setTimeout(() => {
        try {
            const project = buildExportProjectData();
            const payload = {
                savedAt: new Date().toISOString(),
                project
            };
            localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(payload));
        } catch (e) {
            // If storage is unavailable/quota exceeded, fail silently (no UI change).
        }
    }, (__isLongTextEditTarget(__lastInputTargetForTimers) ? 2500 : 2000));
}

function hasAutosave() {
    try { return !!localStorage.getItem(AUTOSAVE_KEY); } catch (e) { return false; }
}

function getAutosavePayload() {
    try {
        const raw = localStorage.getItem(AUTOSAVE_KEY);
        return raw ? JSON.parse(raw) : null;
    } catch (e) {
        return null;
    }
}

function clearAutosave() {
    try { localStorage.removeItem(AUTOSAVE_KEY); } catch (e) {}
}

function isLikelyEmptyProject() {
    const hasModules = document.querySelectorAll('.activity-group').length > 0;
    const hasAnyStep = __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).length > 0;
    const name = (document.getElementById('param-name')?.value || '').trim();
    const desc = (document.getElementById('param-description')?.value || '').trim();
    // If the tool auto-creates an empty module, treat it as empty unless there is any meaningful content.
    return (!hasAnyStep) && (!name) && (!desc);
}

function maybeRestoreAutosave() {
    const payload = getAutosavePayload();
    if (!payload || !payload.project) return false;

    const t = translations[currentLang] || translations.fr || {};
    const savedAt = payload.savedAt ? new Date(payload.savedAt) : null;
    const savedAtTxt = savedAt && !isNaN(savedAt.getTime())
        ? savedAt.toLocaleString()
        : (payload.savedAt || '');

    // Use browser-native confirm to avoid any interface changes.
    const msg = (t.autosave_restore_prompt || "Une sauvegarde automatique a été trouvée ({{date}}). Voulez-vous la restaurer ?")
        .replace('{{date}}', savedAtTxt || '—');

    const restore = window.confirm(msg);
    if (!restore) return false;

    __autosaveSuspended = true;
    try {
        loadProjectFromObject(payload.project);
    } finally {
        // Re-enable autosave after the restore batch has settled
        setTimeout(() => { __autosaveSuspended = false; }, 0);
    }
    return true;
}

function initAutosaveWatchers() {
    // Input-level changes
    document.addEventListener('input', scheduleAutosave, true);
    document.addEventListener('change', scheduleAutosave, true);

    // Structural changes (add/remove/reorder)
    const watchRoot = document.getElementById('activities-root') || document.body;
    try {
        const mo = new MutationObserver(() => scheduleAutosave());
        mo.observe(watchRoot, { childList: true, subtree: true });
    } catch (e) {
        // no-op
    }
}

/* --- Undo/Redo (History Snapshots) --- */
const HISTORY_LIMIT = 50;
let __undoStack = [];
let __redoStack = [];
let __historyDebounce = null;
let __isApplyingHistory = false;
let __pendingDragSnapshot = null;

function snapshotProject() {
    try { return JSON.stringify(buildExportProjectData()); } catch (e) { return null; }
}

function pushUndoSnapshot(snapshot) {
    if (!snapshot) return;
    const last = __undoStack.length ? __undoStack[__undoStack.length - 1] : null;
    if (snapshot === last) return;
    __undoStack.push(snapshot);
    if (__undoStack.length > HISTORY_LIMIT) __undoStack.shift();
    // Any new user change invalidates redo history
    __redoStack = [];
}

function historyCaptureNow() {
    if (__isApplyingHistory) return;
    pushUndoSnapshot(snapshotProject());
}

function scheduleHistoryCapture() {
    if (__isApplyingHistory) return;
    if (__historyDebounce) clearTimeout(__historyDebounce);
    __historyDebounce = setTimeout(() => {
        __historyDebounce = null;
        historyCaptureNow();
    }, (__isLongTextEditTarget(__lastInputTargetForTimers) ? 2500 : 2000));
}

function applySnapshot(snapshotStr) {
    if (!snapshotStr) return;
    let obj = null;
    try { obj = JSON.parse(snapshotStr); } catch (e) { return; }
    __isApplyingHistory = true;
    try {
        loadProjectFromObject(obj);
        updateEmptyState();
        updateStats();
        scheduleAutosave(); // keep autosave consistent with restored state
    } finally {
        // let DOM settle before re-enabling capture (avoids MutationObserver noise)
        setTimeout(() => { __isApplyingHistory = false; }, 0);
    }
}

function undo() {
    if (__undoStack.length <= 1) return; // keep at least initial state
    const current = __undoStack.pop();
    __redoStack.push(current);
    const previous = __undoStack[__undoStack.length - 1];
    applySnapshot(previous);
}

function redo() {
    if (!__redoStack.length) return;
    const next = __redoStack.pop();
    __undoStack.push(next);
    applySnapshot(next);
}

function isEditableTarget(el) {
    if (!el) return false;
    const t = (el.tagName || '').toLowerCase();
    if (t === 'input' || t === 'textarea' || t === 'select') return true;
    return !!el.isContentEditable;
}

function initHistoryWatchers() {
    // Capture text/field changes after inactivity (debounced)
    document.addEventListener('input', scheduleHistoryCapture, true);
    document.addEventListener('change', scheduleHistoryCapture, true);

    // Structural mutations: capture after debounce (covers programmatic edits)
    const watchRoot = document.getElementById('activities-root') || document.body;
    try {
        const mo = new MutationObserver(() => scheduleHistoryCapture());
        mo.observe(watchRoot, { childList: true, subtree: true });
    } catch (e) {
        // no-op
    }

    // Keyboard shortcuts (avoid overriding native text undo in inputs/textarea)
    document.addEventListener('keydown', (e) => {
        const isMac = /Mac|iPhone|iPad|iPod/i.test(navigator.platform);
        const mod = isMac ? e.metaKey : e.ctrlKey;
        if (!mod) return;

        const key = (e.key || '').toLowerCase();
        const editable = isEditableTarget(document.activeElement);

        // Ctrl/Cmd+Z => undo (only when not editing a field)
        if (key === 'z' && !e.shiftKey && !editable) {
            e.preventDefault();
            undo();
            return;
        }

        // Ctrl/Cmd+Shift+Z => redo (common on macOS)
        if (key === 'z' && e.shiftKey && !editable) {
            e.preventDefault();
            redo();
            return;
        }

        // Ctrl/Cmd+Y => redo (common on Windows)
        if (key === 'y' && !editable) {
            e.preventDefault();
            redo();
            return;
        }
    }, true);
}

function initHistory() {
    __undoStack = [];
    __redoStack = [];
    historyCaptureNow(); // initial state
}
/* --- End Undo/Redo --- */

window.onload = () => {
            applyTranslations();
            try { __ldApplyUnitLabelFormat(); } catch(_){ __ldSilentErr(_); }
            // Taxonomy: load any user-defined taxonomy before rendering selectors
            // Taxonomie: interface agnostique. Aucune taxonomie n'est chargée automatiquement.
            resetTaxonomy();
            refreshAllTaxonomySelectors();
            updateTaxonomyStatus('Aucune taxonomie chargée');

            // Taxonomy UI bindings
            try {
                const btnLoad = document.getElementById('btn-load-taxonomy');
                const fileInput = document.getElementById('taxonomy-file-input');
                const btnTpl = document.getElementById('btn-download-taxonomy-template');
                const btnReset = document.getElementById('btn-reset-taxonomy');

                if (btnLoad && fileInput) {
                    btnLoad.addEventListener('click', () => fileInput.click());
                }
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        const f = e.target.files && e.target.files[0];
                        if (f) handleTaxonomyFileImport(f);
                        try { e.target.value = ''; } catch(_){ __ldSilentErr(_); }
                    });
                }
                if (btnTpl) btnTpl.addEventListener('click', downloadTaxonomyTemplate);
                if (btnReset) {
                    btnReset.addEventListener('click', () => {
                        if (confirm("Supprimer la taxonomie chargée ?\n\nLes résultats d’apprentissage déjà saisis seront conservés, mais leurs catégories/sous-catégories pourront ne plus correspondre.")) {
                            resetTaxonomy();
                        }
                    });
                }
            } catch (e) {
                console.error('[TaxonomyInitError]', e);
            }

            // Objectifs: Taxonomie (catégories / sous-catégories) bindings
            try {
                resetAimsTaxonomy();
                refreshAimsTaxonomyHints();

                const btnLoad = document.getElementById('btn-load-aims-taxonomy');
                const btnTemplate = document.getElementById('btn-download-aims-taxonomy-template');
                const btnReset = document.getElementById('btn-reset-aims-taxonomy');
                const fileInput = document.getElementById('aims-taxonomy-file-input');
                const catInput = document.getElementById('new-aim-cat-input');

                if (btnLoad && fileInput) {
                    btnLoad.addEventListener('click', () => { fileInput.value = ''; fileInput.click(); });
                }
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        const f = e.target && e.target.files ? e.target.files[0] : null;
                        if (f) handleAimsTaxonomyFileImport(f);
                        e.target.value = '';
                    });
                }
                if (btnTemplate) {
                    btnTemplate.addEventListener('click', downloadAimsTaxonomyTemplate);
                }
                if (btnReset) {
                    btnReset.addEventListener('click', () => {
                        resetAimsTaxonomy();
                        refreshAimsTaxonomyHints();
                    });
                }

                // Update subcategory suggestions when category changes
                if (catInput) {
                    catInput.addEventListener('input', refreshAimsTaxonomyHints);
                }
            } catch (e) {
                console.warn('Bindings taxonomie objectifs (tab3) échoués:', e);
            }

            

            // Résultats (texte): Taxonomie (catégories / sous-catégories) bindings
            try {
                resetOutcomesTextTaxonomy();
                refreshOutcomesTextTaxonomyHints();

                const btnLoad = document.getElementById('btn-load-outcomes-text-taxonomy');
                const btnTemplate = document.getElementById('btn-download-outcomes-text-taxonomy-template');
                const btnReset = document.getElementById('btn-reset-outcomes-text-taxonomy');
                const fileInput = document.getElementById('outcomes-text-taxonomy-file-input');
                const catInput = document.getElementById('new-outcomes-text-cat-input');

                if (btnLoad && fileInput) {
                    btnLoad.addEventListener('click', () => { fileInput.value = ''; fileInput.click(); });
                }
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        const f = e.target && e.target.files ? e.target.files[0] : null;
                        if (f) handleOutcomesTextTaxonomyFileImport(f);
                        e.target.value = '';
                    });
                }
                if (btnTemplate) {
                    btnTemplate.addEventListener('click', downloadOutcomesTextTaxonomyTemplate);
                }
                if (btnReset) {
                    btnReset.addEventListener('click', () => {
                        resetOutcomesTextTaxonomy();
                        refreshOutcomesTextTaxonomyHints();
                    });
                }

                if (catInput) {
                    catInput.addEventListener('input', refreshOutcomesTextTaxonomyHints);
                }
            } catch (e) {
                console.warn('Bindings taxonomie résultats (tab3) échoués:', e);
            }

// Objectifs & Résultats (texte): CSV import bindings
            try {
                const aimsBtnLoad = document.getElementById('btn-load-aims-csv');
                const aimsFileInput = document.getElementById('aims-csv-file-input');
                const aimsBtnTpl = document.getElementById('btn-download-aims-template');

                if (aimsBtnLoad && aimsFileInput) aimsBtnLoad.addEventListener('click', () => aimsFileInput.click());
                if (aimsFileInput) {
                    aimsFileInput.addEventListener('change', (e) => {
                        const f = e.target.files && e.target.files[0];
                        if (f) handleAimsCsvFileImport(f);
                        try { e.target.value = ''; } catch(_){ __ldSilentErr(_); }
                    });
                }
                if (aimsBtnTpl) aimsBtnTpl.addEventListener('click', downloadAimsTemplateCSV);

                const outBtnLoad = document.getElementById('btn-load-outcomes-text-csv');
                const outFileInput = document.getElementById('outcomes-text-csv-file-input');
                const outBtnTpl = document.getElementById('btn-download-outcomes-text-template');

                if (outBtnLoad && outFileInput) outBtnLoad.addEventListener('click', () => outFileInput.click());
                if (outFileInput) {
                    outFileInput.addEventListener('change', (e) => {
                        const f = e.target.files && e.target.files[0];
                        if (f) handleOutcomesTextCsvFileImport(f);
                        try { e.target.value = ''; } catch(_){ __ldSilentErr(_); }
                    });
                }
                if (outBtnTpl) outBtnTpl.addEventListener('click', downloadOutcomesTextTemplateCSV);
            } catch (e) {
                console.error('[AimsOutcomesCsvInitError]', e);
            }

            // Outils & matériel (onglet 5): CSV import bindings
            try {
                const tmBtnLoad = document.getElementById('btn-load-tools-materials-csv');
                const tmFileInput = document.getElementById('tools-materials-csv-file-input');
                const tmBtnTpl = document.getElementById('btn-download-tools-materials-template');

                if (tmBtnLoad && tmFileInput) tmBtnLoad.addEventListener('click', () => tmFileInput.click());
                if (tmFileInput) {
                    tmFileInput.addEventListener('change', (e) => {
                        const f = e.target.files && e.target.files[0];
                        if (f) handleToolsMaterialsCsvFileImport(f);
                        try { e.target.value = ''; } catch(_){ __ldSilentErr(_); }
                    });
                }
                if (tmBtnTpl) tmBtnTpl.addEventListener('click', downloadToolsMaterialsTemplateCSV);
            } catch (e) {
                console.error('[ToolsMaterialsCsvInitError]', e);
            }

            // Compétences (onglet 4): Taxonomie + CSV import bindings
            try {
                // Taxonomie compétences du sujet
                resetCompetencesTaxonomy();
                refreshCompetencesTaxonomyHints();

                const btnLoad = document.getElementById('btn-load-competences-taxonomy');
                const btnTpl = document.getElementById('btn-download-competences-taxonomy-template');
                const btnReset = document.getElementById('btn-reset-competences-taxonomy');
                const fileInput = document.getElementById('competences-taxonomy-file-input');
                const catInput = document.getElementById('new-competence-cat-input');

                if (btnLoad && fileInput) btnLoad.addEventListener('click', () => { fileInput.value=''; fileInput.click(); });
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        const f = e.target && e.target.files ? e.target.files[0] : null;
                        if (f) handleCompetencesTaxonomyFileImport(f);
                        try { e.target.value=''; } catch(_){ __ldSilentErr(_); }
                    });
                }
                if (btnTpl) btnTpl.addEventListener('click', downloadCompetencesTaxonomyTemplate);
                if (btnReset) btnReset.addEventListener('click', () => { resetCompetencesTaxonomy(); refreshCompetencesTaxonomyHints(); });
                if (catInput) catInput.addEventListener('input', refreshCompetencesTaxonomyHints);

                // CSV compétences du sujet
                const btnLoadCsv = document.getElementById('btn-load-competences-csv');
                const fileCsv = document.getElementById('competences-csv-file-input');
                const btnTplCsv = document.getElementById('btn-download-competences-template');
                if (btnLoadCsv && fileCsv) btnLoadCsv.addEventListener('click', () => fileCsv.click());
                if (fileCsv) {
                    fileCsv.addEventListener('change', (e) => {
                        const f = e.target.files && e.target.files[0];
                        if (f) handleCompetencesCsvFileImport(f, false);
                        try { e.target.value=''; } catch(_){ __ldSilentErr(_); }
                    });
                }
                if (btnTplCsv) btnTplCsv.addEventListener('click', downloadCompetencesTemplateCSV);

                // Taxonomie compétences transversales
                resetCompetencesTransTaxonomy();
                refreshCompetencesTransTaxonomyHints();

                const btnLoadT = document.getElementById('btn-load-competences-trans-taxonomy');
                const btnTplT = document.getElementById('btn-download-competences-trans-taxonomy-template');
                const btnResetT = document.getElementById('btn-reset-competences-trans-taxonomy');
                const fileInputT = document.getElementById('competences-trans-taxonomy-file-input');
                const catInputT = document.getElementById('new-competence-trans-cat-input');

                if (btnLoadT && fileInputT) btnLoadT.addEventListener('click', () => { fileInputT.value=''; fileInputT.click(); });
                if (fileInputT) {
                    fileInputT.addEventListener('change', (e) => {
                        const f = e.target && e.target.files ? e.target.files[0] : null;
                        if (f) handleCompetencesTransTaxonomyFileImport(f);
                        try { e.target.value=''; } catch(_){ __ldSilentErr(_); }
                    });
                }
                if (btnTplT) btnTplT.addEventListener('click', downloadCompetencesTransTaxonomyTemplate);
                if (btnResetT) btnResetT.addEventListener('click', () => { resetCompetencesTransTaxonomy(); refreshCompetencesTransTaxonomyHints(); });
                if (catInputT) catInputT.addEventListener('input', refreshCompetencesTransTaxonomyHints);

                // CSV compétences transversales
                const btnLoadCsvT = document.getElementById('btn-load-competences-trans-csv');
                const fileCsvT = document.getElementById('competences-trans-csv-file-input');
                const btnTplCsvT = document.getElementById('btn-download-competences-trans-template');
                if (btnLoadCsvT && fileCsvT) btnLoadCsvT.addEventListener('click', () => fileCsvT.click());
                if (fileCsvT) {
                    fileCsvT.addEventListener('change', (e) => {
                        const f = e.target.files && e.target.files[0];
                        if (f) handleCompetencesCsvFileImport(f, true);
                        try { e.target.value=''; } catch(_){ __ldSilentErr(_); }
                    });
                }
                if (btnTplCsvT) btnTplCsvT.addEventListener('click', downloadCompetencesTransTemplateCSV);

            } catch (e) {
                console.warn('[CompetencesTab4InitError]', e);
            }


            initTimelineZoomControls();
            // View mode preference (STD / HC / Transparent)
            try {
                const m = localStorage.getItem('ld_view_mode');
                if (m) {
                    if (typeof setViewStyle === 'function') setViewStyle(m);
                } else {
                    // Backward compatibility
                    const pref = localStorage.getItem('ld_palette');
                    if (pref === 'standard') document.body.classList.remove('hc');
                    if (pref === 'hc') document.body.classList.add('hc');
                    const v = localStorage.getItem('ld_view_transparent');
                    if (v === '1') document.body.classList.add('view-transparent');
                    if (v === '0') document.body.classList.remove('view-transparent');
                    const cp = localStorage.getItem('ld_view_contrast_plus');
                    if (cp === '1') document.body.classList.add('contrast-plus');
                    if (cp === '0') document.body.classList.remove('contrast-plus');
                }
            } catch (e) {
                // ignore
            }

            

            // UI theme preference (Clair / Sombre)
            try {
                const t = localStorage.getItem('ld_ui_theme');
                if (t) {
                    if (typeof setUiTheme === 'function') setUiTheme(t);
                } else {
                    // Default view requirement: STD + Clair unless user explicitly chose otherwise.
                    if (typeof setUiTheme === 'function') setUiTheme('light');
                }
            } catch (e) {
                // ignore
            }
// Autosave: offer restore if available; otherwise start with a fresh module
            let restored = false;
            if (hasAutosave()) {
                // If the page starts empty, restore without additional checks; otherwise still allow restore.
                restored = maybeRestoreAutosave();
            }
            if (!restored) {
                addActivity();
            }

            initAutosaveWatchers();
            initHistory();
            initHistoryWatchers();
updateContrastToggleUI();
updateTransparentBlocksToggleUI();
try { if (typeof syncViewStyleSelect === 'function') syncViewStyleSelect(); } catch (e) {}
try { if (typeof syncUiThemeSelect === 'function') syncUiThemeSelect(); } catch (e) {}
        };
  
document.addEventListener('DOMContentLoaded', setupTimelineHScroll);

/* --- Charts panel (non-intrusive) --- */
(function () {
  const rootEl = document.getElementById('activities-root');

  function getSelectedLabel(selectEl) {
    const opt = selectEl && selectEl.options ? selectEl.options[selectEl.selectedIndex] : null;
    const txt = opt ? (opt.textContent || '').trim() : '';
    const val = (selectEl && selectEl.value ? String(selectEl.value).trim() : '');
    return txt || val || '—';
  }

  function getStepDurationSecs(stepCard) {
  if (!stepCard) return 0;
  const v = Math.max(0, parseFloat(stepCard.querySelector('.duration-input')?.value) || 0);
  const rawUnit = stepCard.querySelector('.duration-unit')?.value;
  const u = mapUnitToSecs(rawUnit || 60);
  // unit is stored as seconds-per-unit in option value (e.g., 60 for minutes)
  const secs = v * (u || 60);
  return Number.isFinite(secs) ? secs : 0;
}

// Count occurrences (kept for potential future use)
// Sum designed duration (seconds) by a select's chosen label, using the enclosing step card duration.
function tallyDuration(selector) {
  const sums = new Map();
  document.querySelectorAll(selector).forEach((el) => {
    if (!el) return;
    const val = (el.value ?? '').toString().trim();
    if (!val) return;
    const label = (el.tagName === 'SELECT') ? getSelectedLabel(el) : val;
    const stepCard = el.closest('.step-card');
    const secs = getStepDurationSecs(stepCard);
    if (secs <= 0) return;
    sums.set(label, (sums.get(label) || 0) + secs);
  });
  return sums;
}
function tallyDurationMeta(selector, kind) {
  const sums = new Map();

  // Ensure "Regroupement" histogram always shows the 3 expected bars, even if a category is unused.
  if ((kind || '').toLowerCase() === 'group') {
    const first = document.querySelector('.step-group-mode');
    const getLabelForValue = (v, fallback) => {
      try {
        if (first && first.options) {
          const opt = Array.from(first.options).find(o => (o.value || '').toString() === v);
          const txt = opt ? (opt.textContent || '').trim() : '';
          if (txt) return txt;
        }
      } catch(_){ __ldSilentErr(_); }
      return fallback;
    };

    const presets = [
      { val: 'class', label: getLabelForValue('class', 'Groupe entier') },
      { val: 'groups', label: getLabelForValue('groups', 'Sous-groupe') },
      { val: 'individual', label: getLabelForValue('individual', 'Individuel') }
    ];

    presets.forEach((p) => {
      const meta = getHistogramBarMeta('group', p.val);
      sums.set(p.label, { secs: 0, color: meta.color, pattern: meta.pattern });
    });
  }

  document.querySelectorAll(selector).forEach((el) => {
    if (!el) return;
    const val = (el.value ?? '').toString().trim();
    if (!val) return;

    const label = (el.tagName === 'SELECT') ? getSelectedLabel(el) : val;
    const stepCard = el.closest('.step-card');
    const secs = getStepDurationSecs(stepCard);
    if (secs <= 0) return;

    const meta = getHistogramBarMeta(kind, val);
    const prev = sums.get(label) || { secs: 0, color: meta.color, pattern: meta.pattern };
    prev.secs += secs;
    // Keep initial style chosen for this label
    sums.set(label, prev);
  });

  return Array.from(sums.entries()).map(([label, obj]) => ({
    label,
    secs: obj.secs || 0,
    color: obj.color,
    pattern: obj.pattern
  }));
}

function getHistogramBarMeta(kind, val) {
  // These match the legend logic and the "Visualisations des séquences" tracks:
  // plein = greySolid, rayé = greyStriped + stripes.
  const greySolid = '#64748b';   // slate-500
  const greyStriped = '#94a3b8'; // slate-400

  const k = (kind || '').toLowerCase();
  const v = (val || '').toLowerCase();

  if (k === 'group') {
    if (v === 'class') return { color: greySolid, pattern: '' };
    if (v === 'groups') return { color: greyStriped, pattern: 'stripes' };
    if (v === 'individual') return { color: greySolid, pattern: 'dots' };
    return { color: greyStriped, pattern: 'stripes' };
  }

  if (k === 'place') {
    // timeline legend: plein = présentiel, rayé = en ligne (hybride treated as rayé in timeline)
    if (v === 'situ') return { color: greySolid, pattern: '' };
    return { color: greyStriped, pattern: 'stripes' };
  }

  if (k === 'time') {
    // timeline legend: plein = synchrone, rayé = asynchrone
    if (v === 'sync') return { color: greySolid, pattern: '' };
    return { color: greyStriped, pattern: 'stripes' };
  }

  if (k === 'trainer') {
    // timeline legend: plein = présent, rayé = absent
    if (v === 'present') return { color: greySolid, pattern: '' };
    return { color: greyStriped, pattern: 'stripes' };
  }

  return { color: greySolid, pattern: '' };
}


  function clearCanvas(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
  }

    function palette(n) {
    // deterministic greys-to-blues palette
    const cols = [];
    for (let i = 0; i < n; i++) {
      const t = n <= 1 ? 0.5 : i / (n - 1);
      const r = Math.round(30 + 50 * (1 - t));
      const g = Math.round(80 + 80 * (1 - t));
      const b = Math.round(180 + 60 * t);
      cols.push(`rgb(${r},${g},${b})`);
    }
    return cols;
  }

    function drawPie(canvasId, countsMap) {
    const c = document.getElementById(canvasId);
    if (!c) return;
    const ctx = c.getContext('2d');
    const w = c.width = c.clientWidth || c.width;
    const h = c.height = c.getAttribute('height') ? parseInt(c.getAttribute('height'), 10) : (c.clientHeight || 180);
    clearCanvas(ctx, w, h);

    const entries = Array.from(countsMap.entries()).sort((a, b) => b[1] - a[1]);
    if (!entries.length) {
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Aucune donnée', 10, 20);
      // Clear legend if present
      if (canvasId === 'chart-learning-types') {
        const lg = document.getElementById('chart-learning-types-legend');
        if (lg) lg.innerHTML = '';
      }
      return;
    }

    const total = entries.reduce((s, [, v]) => s + v, 0);
    if (total <= 0) {
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Aucune donnée', 10, 20);
      if (canvasId === 'chart-learning-types') {
        const lg = document.getElementById('chart-learning-types-legend');
        if (lg) lg.innerHTML = '';
      }
      return;
    }

    function learningTypeColor(label) {
      const k = (label || '').toString().toLowerCase();
      if (k.includes('acquisition')) return '#a1f5ed';
      if (k.includes('collaboration')) return '#ffd966';
      if (k.includes('discussion')) return '#7aaeea';
      if (k.includes('investigation') || k.includes('enquête') || k.includes('enquete')) return '#f8807f';
      if (k.includes('practice') || k.includes('pratique')) return '#bb98dc';
      if (k.includes('production')) return '#bdea75';
      if (k.includes('none') || k.includes('aucun') || k.includes('—')) return '#e5e7eb';
      return '#cbd5e1';
    }

    const cols = (canvasId === 'chart-learning-types')
      ? entries.map(([label]) => learningTypeColor(label))
      : palette(entries.length);

    // Draw pie only (legend is rendered as text beside the canvas for accessibility and to avoid overlap)
    const cx = w * 0.5;
    const cy = h * 0.5;

    // Make the pie large within its own canvas (the canvas itself is 50% of the dedicated frame)
    let radius = Math.min(w, h) * 0.44;
    radius = Math.max(24, Math.min(radius, (w / 2) - 10, (h / 2) - 10));

    let angle = -Math.PI / 2;
    entries.forEach(([label, value], i) => {
      const slice = (value / total) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.fillStyle = cols[i];
      ctx.arc(cx, cy, radius, angle, angle + slice);
      ctx.closePath();
      ctx.fill();
      angle += slice;
    });

    // Update legend as text in a dedicated DOM container (never overlaps the pie)
    if (canvasId === 'chart-learning-types') {
      const lg = document.getElementById('chart-learning-types-legend');
      if (lg) {
        // Build legend with DOM APIs (prevents HTML injection)
        lg.textContent = '';
        entries.forEach(([label, value], i) => {
          const pct = (value / total) * 100;
          const pctStr = (pct >= 9.95 || pct === 0) ? `${Math.round(pct)}%` : `${pct.toFixed(1)}%`;
          const safeLabel = (label || '—').toString();

          const row = document.createElement('div');
          row.className = "flex items-center justify-between gap-2";

          const left = document.createElement('div');
          left.className = "flex items-center gap-2 min-w-0";

          const swatch = document.createElement('span');
          swatch.className = "inline-block w-3 h-3 rounded-sm border border-slate-200 flex-none";
          swatch.style.background = cols[i];

          const lab = document.createElement('span');
          lab.className = "truncate";
          lab.textContent = safeLabel;

          const right = document.createElement('div');
          right.className = "text-slate-900 font-semibold tabular-nums flex-none";
          right.textContent = pctStr;

          left.appendChild(swatch);
          left.appendChild(lab);
          row.appendChild(left);
          row.appendChild(right);
          lg.appendChild(row);
        });
      }
    }
  }

  function drawBars(canvasId, rows) {
  const c = document.getElementById(canvasId);
  if (!c) return;
  const ctx = c.getContext('2d');
  const w = (c.width = c.clientWidth || c.width);
  let h = (c.height = c.getAttribute('height') ? parseInt(c.getAttribute('height'), 10) : (c.clientHeight || 180));
  clearCanvas(ctx, w, h);

  const entries = (rows || []).slice().sort((a, b) => (b.secs || 0) - (a.secs || 0));
  if (!entries.length) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Aucune donnée', 10, 20);
    return;
  }

  // Ensure the canvas is tall enough to display all bars (e.g., 3 rows for Regroupement)
  const __minH = (10 + 8) + (entries.length * 22) + 10;
  if (h < __minH) {
    h = (c.height = __minH);
    clearCanvas(ctx, w, h);
  }

  const pad = 10;
  const rowH = 22;
  const top = pad + 8;

  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textBaseline = 'middle';

  const total = entries.reduce((acc, e) => acc + (e.secs || 0), 0);

  // Measure label widths
  let maxLabelPx = 0;
  entries.forEach((e) => { maxLabelPx = Math.max(maxLabelPx, ctx.measureText(e.label || '').width); });

  // Fixed right column for values
  const valueExample = '100%';
  const valueW = ctx.measureText(valueExample).width;
  const valueX = w - pad - valueW;

  // Keep label column generous so labels never sit under bars
  const labelW = Math.min(Math.max(110, maxLabelPx + 16), Math.min(260, w * 0.48));
  const barX = pad + labelW + 10;
  const barW = Math.max(30, (valueX - 10) - barX);

  function fitText(text, maxWidth) {
    const s = (text || '').toString();
    if (ctx.measureText(s).width <= maxWidth) return s;
    let lo = 0, hi = s.length;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      const t = s.slice(0, mid) + '…';
      if (ctx.measureText(t).width <= maxWidth) lo = mid + 1;
      else hi = mid;
    }
    const cut = Math.max(1, lo - 1);
    return s.slice(0, cut) + '…';
  }

  function roundRectPath(x, y, ww, hh, r) {
    const rr = Math.max(0, Math.min(r, hh / 2, ww / 2));
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + ww, y, x + ww, y + hh, rr);
    ctx.arcTo(x + ww, y + hh, x, y + hh, rr);
    ctx.arcTo(x, y + hh, x, y, rr);
    ctx.arcTo(x, y, x + ww, y, rr);
    ctx.closePath();
  }

  function drawTrack(x, y, ww, hh) {
    // Track background + border (matches timeline bars: bg-slate-100 + border-slate-200 + rounded)
    ctx.save();
    roundRectPath(x, y, ww, hh, 7);
    ctx.fillStyle = '#f1f5f9'; // slate-100
    ctx.fill();
    ctx.strokeStyle = '#e2e8f0'; // slate-200
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  function drawFill(x, y, ww, hh, color, pattern) {
    if (ww <= 0.5) return;

    ctx.save();
    roundRectPath(x, y, ww, hh, 7);
    ctx.clip();

    // Base fill
    ctx.fillStyle = color || '#64748b';
    ctx.fillRect(x, y, ww, hh);

    // Overlay patterns to mimic "plein / rayé" style from Visualisations des séquences
    if (pattern === 'stripes') {
      ctx.strokeStyle = 'rgba(255,255,255,0.45)';
      ctx.lineWidth = 2;
      const step = 8;
      // diagonal stripes
      for (let i = -hh; i < ww + hh; i += step) {
        ctx.beginPath();
        ctx.moveTo(x + i, y + hh);
        ctx.lineTo(x + i + hh, y);
        ctx.stroke();
      }
    } else if (pattern === 'dots') {
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      const step = 8;
      for (let yy = y + 4; yy < y + hh; yy += step) {
        for (let xx = x + 4; xx < x + ww; xx += step) {
          ctx.beginPath();
          ctx.arc(xx, yy, 1.3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    ctx.restore();

    // Subtle separator line at end of filled portion (like segment boundaries)
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + ww + 0.5, y + 2);
    ctx.lineTo(x + ww + 0.5, y + hh - 2);
    ctx.stroke();
    ctx.restore();
  }

  const maxRows = Math.floor((h - pad * 2) / rowH);
  entries.slice(0, maxRows).forEach((e, i) => {
    const yMid = top + i * rowH + rowH / 2;
    const trackH = 12;
    const trackY = yMid - trackH / 2;

    // Label
    ctx.fillStyle = '#334155'; // slate-700
    ctx.fillText(fitText(e.label || '', labelW - 8), pad, yMid);

    // Track and fill
    drawTrack(barX, trackY, barW, trackH);

    const pct = total > 0 ? (e.secs / total) * 100 : 0;
    const bw = Math.round((barW * pct) / 100);

    drawFill(barX, trackY, bw, trackH, e.color, e.pattern);

    // Value column (right-aligned, never overlaps bars)
    ctx.fillStyle = '#0f172a';
    const pctStr = (pct >= 9.95 || pct === 0) ? `${Math.round(pct)}%` : `${pct.toFixed(1)}%`;
    ctx.fillText(pctStr, valueX, yMid);
  });
}


// Draw horizontal bars with absolute counts (not %). Used for competence Top lists.
function drawCountBars(canvasId, rows, style) {
  const c = document.getElementById(canvasId);
  if (!c) return;
  const ctx = c.getContext('2d');
  const w = (c.width = (c.clientWidth || c.width || 300));
  let h = (c.height = c.getAttribute('height') ? parseInt(c.getAttribute('height'), 10) : (c.clientHeight || 200));
  clearCanvas(ctx, w, h);

  const entries = (rows || []).slice();
  if (!entries.length) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Aucune sélection', 10, 20);
    return;
  }

  const __minH = (10 + 8) + (entries.length * 22) + 10;
  if (h < __minH) {
    h = (c.height = __minH);
    clearCanvas(ctx, w, h);
  }

  const pad = 10;
  const rowH = 22;
  const top = pad + 8;

  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textBaseline = 'middle';

  const maxV = Math.max(1, ...entries.map(e => Number(e.value) || 0));

  // Measure label widths
  let maxLabelPx = 0;
  entries.forEach((e) => { maxLabelPx = Math.max(maxLabelPx, ctx.measureText(e.label || '').width); });

  // Right column for absolute values
  const valueExample = String(maxV);
  const valueW = ctx.measureText(valueExample).width;
  const valueX = w - pad - valueW;

  const labelW = Math.min(Math.max(110, maxLabelPx + 16), Math.min(260, w * 0.48));
  const barX = pad + labelW + 10;
  const barW = Math.max(30, (valueX - 10) - barX);

  const subjectColor = '#64748b';   // slate-500
  const transColor = '#94a3b8';     // slate-400
  const isTrans = (style && style.kind === 'trans') || /\btrans\b/i.test(canvasId);
  const fillColor = isTrans ? transColor : subjectColor;
  const fillPattern = isTrans ? 'stripes' : '';

  function fitText(text, maxWidth) {
    const s = (text || '').toString();
    if (ctx.measureText(s).width <= maxWidth) return s;
    let lo = 0, hi = s.length;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      const t = s.slice(0, mid) + '…';
      if (ctx.measureText(t).width <= maxWidth) lo = mid + 1;
      else hi = mid;
    }
    const cut = Math.max(1, lo - 1);
    return s.slice(0, cut) + '…';
  }

  function roundRectPath(x, y, ww, hh, r) {
    const rr = Math.max(0, Math.min(r, hh / 2, ww / 2));
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + ww, y, x + ww, y + hh, rr);
    ctx.arcTo(x + ww, y + hh, x, y + hh, rr);
    ctx.arcTo(x, y + hh, x, y, rr);
    ctx.arcTo(x, y, x + ww, y, rr);
    ctx.closePath();
  }

  function drawTrack(x, y, ww, hh) {
    ctx.save();
    roundRectPath(x, y, ww, hh, 7);
    ctx.fillStyle = '#f1f5f9';
    ctx.fill();
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  function drawFill(x, y, ww, hh, color, pattern) {
    if (ww <= 0.5) return;
    ctx.save();
    roundRectPath(x, y, ww, hh, 7);
    ctx.clip();
    ctx.fillStyle = color || '#64748b';
    ctx.fillRect(x, y, ww, hh);
    if (pattern === 'stripes') {
      ctx.strokeStyle = 'rgba(255,255,255,0.45)';
      ctx.lineWidth = 2;
      const step = 8;
      for (let i = -hh; i < ww + hh; i += step) {
        ctx.beginPath();
        ctx.moveTo(x + i, y + hh);
        ctx.lineTo(x + i + hh, y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  entries.forEach((e, i) => {
    const yMid = top + i * rowH + rowH / 2;
    const trackH = 12;
    const trackY = yMid - trackH / 2;

    ctx.fillStyle = '#334155';
    ctx.fillText(fitText(e.label || '', labelW - 8), pad, yMid);

    drawTrack(barX, trackY, barW, trackH);

    const v = Math.max(0, Number(e.value) || 0);
    const bw = Math.round(barW * (v / maxV));
    drawFill(barX, trackY, bw, trackH, fillColor, fillPattern);

    ctx.fillStyle = '#0f172a';
    ctx.fillText(String(v), valueX, yMid);
  });
}


// Render horizontal bars as real DOM text (not canvas). Used for competence Top lists.
function renderCountBarsText(containerId, rows, style) {
  const host = document.getElementById(containerId);
  if (!host) return;
  const entries = (rows || []).slice();
  host.innerHTML = '';

  if (!entries.length) {
    const empty = document.createElement('div');
    empty.className = 'text-[11px] text-slate-400 italic px-1';
    empty.textContent = 'Aucune sélection';
    host.appendChild(empty);
    return;
  }

  const maxV = Math.max(1, ...entries.map(e => Number(e.value) || 0));
  const isTrans = (style && style.kind === 'trans') || /\btrans\b/i.test(containerId);

  entries.forEach((e) => {
    const v = Math.max(0, Number(e.value) || 0);
    const pct = Math.max(0, Math.min(100, (v / maxV) * 100));

    const row = document.createElement('div');
    row.className = 'grid grid-cols-[minmax(110px,1fr)_minmax(120px,1.2fr)_auto] gap-2 items-center py-0.5';

    const lab = document.createElement('div');
    lab.className = 'text-[11px] text-slate-700 truncate';
    lab.title = (e.label || '').toString();
    lab.textContent = (e.label || '').toString();

    const track = document.createElement('div');
    track.className = 'h-3 rounded-full border border-slate-200 bg-slate-100 overflow-hidden';

    const fill = document.createElement('div');
    fill.className = 'h-full ' + (isTrans ? 'bg-slate-400 pattern-stripes' : 'bg-slate-500');
    fill.style.width = pct.toFixed(2) + '%';
    track.appendChild(fill);

    const val = document.createElement('div');
    val.className = 'text-[11px] text-slate-900 font-mono tabular-nums text-right';
    val.textContent = String(v);

    row.appendChild(lab);
    row.appendChild(track);
    row.appendChild(val);

    host.appendChild(row);
  });
}

// Render stacked module bars as real DOM text (not canvas). Used for competence distribution.
function renderStackedModuleBarsText(containerId, rows) {
  const host = document.getElementById(containerId);
  if (!host) return;
  const entries = (rows || []).slice();
  host.innerHTML = '';

  if (!entries.length) {
    const empty = document.createElement('div');
    empty.className = 'text-[11px] text-slate-400 italic px-1';
    empty.textContent = 'Aucun module';
    host.appendChild(empty);
    return;
  }

  entries.forEach((e) => {
    const s = Math.max(0, Number(e.sujet) || 0);
    const t = Math.max(0, Number(e.trans) || 0);
    const denom = s + t;
    const pctS = denom ? (s / denom) * 100 : 0;
    const pctT = denom ? (t / denom) * 100 : 0;
    const pctSujetRounded = denom ? Math.round((s / denom) * 100) : 0;

    const row = document.createElement('div');
    row.className = 'grid grid-cols-[minmax(130px,1fr)_minmax(140px,1.2fr)_auto] gap-2 items-center py-0.5';

    const lab = document.createElement('div');
    lab.className = 'text-[11px] text-slate-700 truncate';
    lab.title = (e.label || '').toString();
    lab.textContent = (e.label || '').toString();

    const track = document.createElement('div');
    track.className = 'h-3 rounded-full border border-slate-200 bg-slate-100 overflow-hidden flex';

    const segS = document.createElement('div');
    segS.className = 'h-full bg-slate-500';
    segS.style.width = pctS.toFixed(2) + '%';

    const segT = document.createElement('div');
    segT.className = 'h-full bg-slate-400 pattern-stripes';
    segT.style.width = pctT.toFixed(2) + '%';

    track.appendChild(segS);
    track.appendChild(segT);

    const val = document.createElement('div');
    val.className = 'text-[11px] text-slate-900 font-mono tabular-nums text-right whitespace-nowrap';
    val.textContent = `${s}/${t} ${pctSujetRounded}%`;

    row.appendChild(lab);
    row.appendChild(track);
    row.appendChild(val);

    host.appendChild(row);
  });
}

// Draw stacked bars by module (Sujet + Transversales). Used for competence distribution.
function drawStackedModuleBars(canvasId, rows) {
  const c = document.getElementById(canvasId);
  if (!c) return;
  const ctx = c.getContext('2d');
  const w = (c.width = (c.clientWidth || c.width || 420));
  // Respect the available vertical space while preserving drawing proportions:
  // - We set the internal canvas size to match the rendered size (no CSS scaling distortions)
  // - We shrink/grow the height based on the number of modules, so the chart integrates better.
  const baseH = c.getAttribute('height') ? parseInt(c.getAttribute('height'), 10) : (c.clientHeight || 240);
  let h = (c.height = baseH);
  clearCanvas(ctx, w, h);

  const entries = (rows || []).slice();
  if (!entries.length) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Aucun module', 10, 20);
    return;
  }

  const __minH = (10 + 8) + (entries.length * 22) + 10;
  // Target height: enough for all rows, but avoid a large empty canvas when there are few modules.
  // Keep a small minimum so the chart remains legible.
  const __targetH = Math.max(120, __minH);
  if (h !== __targetH) {
    h = (c.height = __targetH);
    clearCanvas(ctx, w, h);
  }

  const pad = 10;
  const rowH = 22;
  const top = pad + 8;

  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textBaseline = 'middle';

  // Measure label widths
  let maxLabelPx = 0;
  entries.forEach((e) => { maxLabelPx = Math.max(maxLabelPx, ctx.measureText(e.label || '').width); });

  const valueExample = '999/999 100%';
  const valueW = ctx.measureText(valueExample).width;
  const valueX = w - pad - valueW;

  const labelW = Math.min(Math.max(130, maxLabelPx + 16), Math.min(300, w * 0.48));
  const barX = pad + labelW + 10;
  const barW = Math.max(60, (valueX - 10) - barX);

  const sujetColor = '#64748b';
  const transColor = '#94a3b8';

  function fitText(text, maxWidth) {
    const s = (text || '').toString();
    if (ctx.measureText(s).width <= maxWidth) return s;
    let lo = 0, hi = s.length;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      const t = s.slice(0, mid) + '…';
      if (ctx.measureText(t).width <= maxWidth) lo = mid + 1;
      else hi = mid;
    }
    const cut = Math.max(1, lo - 1);
    return s.slice(0, cut) + '…';
  }

  function roundRectPath(x, y, ww, hh, r) {
    const rr = Math.max(0, Math.min(r, hh / 2, ww / 2));
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + ww, y, x + ww, y + hh, rr);
    ctx.arcTo(x + ww, y + hh, x, y + hh, rr);
    ctx.arcTo(x, y + hh, x, y, rr);
    ctx.arcTo(x, y, x + ww, y, rr);
    ctx.closePath();
  }

  function drawTrack(x, y, ww, hh) {
    ctx.save();
    roundRectPath(x, y, ww, hh, 7);
    ctx.fillStyle = '#f1f5f9';
    ctx.fill();
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  function drawFill(x, y, ww, hh, color, pattern) {
    if (ww <= 0.5) return;
    ctx.save();
    roundRectPath(x, y, ww, hh, 7);
    ctx.clip();
    ctx.fillStyle = color || '#64748b';
    ctx.fillRect(x, y, ww, hh);
    if (pattern === 'stripes') {
      ctx.strokeStyle = 'rgba(255,255,255,0.45)';
      ctx.lineWidth = 2;
      const step = 8;
      for (let i = -hh; i < ww + hh; i += step) {
        ctx.beginPath();
        ctx.moveTo(x + i, y + hh);
        ctx.lineTo(x + i + hh, y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  entries.forEach((e, i) => {
    const yMid = top + i * rowH + rowH / 2;
    const trackH = 12;
    const trackY = yMid - trackH / 2;

    ctx.fillStyle = '#334155';
    ctx.fillText(fitText(e.label || '', labelW - 8), pad, yMid);

    drawTrack(barX, trackY, barW, trackH);

    const s = Math.max(0, Number(e.sujet) || 0);
    const t = Math.max(0, Number(e.trans) || 0);
    const denom = s + t;
    const bwS = denom ? Math.round(barW * (s / denom)) : 0;
    const bwT = denom ? Math.round(barW * (t / denom)) : 0;

    // Sujet (plein), puis Transversal (rayé) à la suite
    drawFill(barX, trackY, bwS, trackH, sujetColor, '');
    drawFill(barX + bwS, trackY, bwT, trackH, transColor, 'stripes');

    const pctSujet = denom ? Math.round((s / denom) * 100) : 0;
    ctx.fillStyle = '#0f172a';
    ctx.fillText(`${s}/${t} ${pctSujet}%`, valueX, yMid);
  });
}

function __escapeHtmlLite(s) {
  if (s == null) return '';
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

// ------------------------------------------------------------
// Competence bipartite network (Activities ↔ Competences)
// ------------------------------------------------------------
function drawCompetenceBipartite(svgId, payload) {
  const svg = document.getElementById(svgId);
  if (!svg) return;

  const wrap = svg.parentElement;
  const w = Math.max(520, (wrap?.clientWidth || svg.clientWidth || 900));

  const activities = Array.isArray(payload?.activities) ? payload.activities : [];
  const sujetById = (payload?.sujetById instanceof Map) ? payload.sujetById : new Map(Object.entries(payload?.sujetById || {}));
  const transById = (payload?.transById instanceof Map) ? payload.transById : new Map(Object.entries(payload?.transById || {}));
  const freqSujet = (payload?.freqSujet instanceof Map) ? payload.freqSujet : new Map(Object.entries(payload?.freqSujet || {}));
  const freqTrans = (payload?.freqTrans instanceof Map) ? payload.freqTrans : new Map(Object.entries(payload?.freqTrans || {}));

  const usedSujet = new Set();
  const usedTrans = new Set();
  activities.forEach(a => {
    (a?.sujetIds || []).forEach(id => { if (id) usedSujet.add(String(id)); });
    (a?.transIds || []).forEach(id => { if (id) usedTrans.add(String(id)); });
  });

  const sujetNodes = Array.from(usedSujet).map(id => ({
    id,
    label: sujetById.get(String(id)) || `[Inconnue] ${id}`,
    count: Number(freqSujet.get(String(id)) || 0)
  })).sort((a, b) => (b.count - a.count) || a.label.localeCompare(b.label, 'fr'));

  const transNodes = Array.from(usedTrans).map(id => ({
    id,
    label: transById.get(String(id)) || `[Inconnue] ${id}`,
    count: Number(freqTrans.get(String(id)) || 0)
  })).sort((a, b) => (b.count - a.count) || a.label.localeCompare(b.label, 'fr'));

  // Clear
  while (svg.firstChild) svg.removeChild(svg.firstChild);

  const mk = (tag) => document.createElementNS('http://www.w3.org/2000/svg', tag);
  const truncate = (s, n) => {
    const str = String(s || '');
    return str.length > n ? (str.slice(0, Math.max(0, n - 1)) + '…') : str;
  };

  // Sizing (dynamic height; scroll is handled by wrapper)
  const rowH = 18;
  const startY = 34;
  const nRows = Math.max(activities.length, sujetNodes.length, transNodes.length, 1);
  const h = startY + nRows * rowH + 18;

  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  svg.setAttribute('height', String(h));
  svg.setAttribute('width', '100%');
  svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

  // Empty state
  if (!activities.length || (!sujetNodes.length && !transNodes.length)) {
    const t = mk('text');
    t.setAttribute('x', '12');
    t.setAttribute('y', '22');
    t.setAttribute('font-size', '12');
    t.setAttribute('fill', '#94a3b8');
    t.textContent = 'Aucune sélection de compétences à visualiser.';
    svg.appendChild(t);
    return;
  }

  // Columns (scale down if needed)
  const margin = 12;
  const gap = 18;
  let colA = Math.max(220, Math.min(340, Math.floor(w * 0.38)));
  let colS = Math.max(200, Math.min(300, Math.floor(w * 0.31)));
  let colT = Math.max(200, Math.min(300, Math.floor(w * 0.31)));

  const available = Math.max(260, w - margin * 2 - gap * 2);
  const total = colA + colS + colT;
  if (total > available) {
    const scale = available / total;
    colA = Math.floor(colA * scale);
    colS = Math.floor(colS * scale);
    colT = Math.floor(colT * scale);
  }

  const xA0 = margin;
  const xA1 = xA0 + colA;
  const xS0 = xA1 + gap;
  const xS1 = xS0 + colS;
  const xT0 = xS1 + gap;
  const xT1 = xT0 + colT;

  const xANode = xA1 - 6;
  const xSNode = xS0 + 6;
  const xTNode = xT0 + 6;

  // Separators
  const sep1 = mk('line');
  sep1.setAttribute('x1', String(xA1 + gap / 2));
  sep1.setAttribute('x2', String(xA1 + gap / 2));
  sep1.setAttribute('y1', '6');
  sep1.setAttribute('y2', String(h - 6));
  sep1.setAttribute('stroke', 'rgba(148,163,184,0.35)');
  svg.appendChild(sep1);

  const sep2 = mk('line');
  sep2.setAttribute('x1', String(xS1 + gap / 2));
  sep2.setAttribute('x2', String(xS1 + gap / 2));
  sep2.setAttribute('y1', '6');
  sep2.setAttribute('y2', String(h - 6));
  sep2.setAttribute('stroke', 'rgba(148,163,184,0.35)');
  svg.appendChild(sep2);

  // Headers
  const header = (label, x) => {
    const t = mk('text');
    t.setAttribute('x', String(x));
    t.setAttribute('y', '18');
    t.setAttribute('font-size', '11');
    t.setAttribute('font-weight', '700');
    t.setAttribute('fill', '#475569');
    t.textContent = label;
    svg.appendChild(t);
  };
  header('Activités', xA0);
  header('Sujet', xS0);
  header('Transversales', xT0);

  // Position maps
  const yAct = new Map();
  activities.forEach((_, i) => yAct.set(i, startY + i * rowH));
  const yS = new Map();
  sujetNodes.forEach((n, i) => yS.set(String(n.id), startY + i * rowH));
  const yT = new Map();
  transNodes.forEach((n, i) => yT.set(String(n.id), startY + i * rowH));

  const linkPath = (x1, y1, x2, y2) => {
    const dx = Math.max(30, Math.abs(x2 - x1) * 0.35);
    return `M ${x1} ${y1} C ${x1 + dx} ${y1}, ${x2 - dx} ${y2}, ${x2} ${y2}`;
  };

  // Links (draw behind nodes)
  activities.forEach((a, i) => {
    const y1 = yAct.get(i);
    if (y1 == null) return;

    // Sujet (solid)
    (a?.sujetIds || []).forEach(id => {
      const y2 = yS.get(String(id));
      if (y2 == null) return;
      const p = mk('path');
      p.setAttribute('d', linkPath(xANode, y1, xSNode, y2));
      p.setAttribute('fill', 'none');
      p.setAttribute('stroke', 'rgba(100,116,139,0.32)');
      p.setAttribute('stroke-width', '1.2');
      p.setAttribute('stroke-linecap', 'round');
      svg.appendChild(p);
    });

    // Transversales (dashed)
    (a?.transIds || []).forEach(id => {
      const y2 = yT.get(String(id));
      if (y2 == null) return;
      const p = mk('path');
      p.setAttribute('d', linkPath(xANode, y1, xTNode, y2));
      p.setAttribute('fill', 'none');
      p.setAttribute('stroke', 'rgba(100,116,139,0.32)');
      p.setAttribute('stroke-width', '1.2');
      p.setAttribute('stroke-dasharray', '3 3');
      p.setAttribute('stroke-linecap', 'round');
      svg.appendChild(p);
    });
  });

  // Activity nodes + labels
  activities.forEach((a, i) => {
    const y = yAct.get(i);
    if (y == null) return;

    const label = truncate(a?.label || `Activité ${i + 1}`, 56);
    const t = mk('text');
    t.setAttribute('x', String(xA0));
    t.setAttribute('y', String(y));
    t.setAttribute('dominant-baseline', 'middle');
    t.setAttribute('font-size', '11');
    t.setAttribute('fill', '#334155');
    t.textContent = label;
    svg.appendChild(t);

    const c = mk('circle');
    c.setAttribute('cx', String(xANode));
    c.setAttribute('cy', String(y));
    c.setAttribute('r', '2.7');
    c.setAttribute('fill', '#64748b');
    svg.appendChild(c);
  });

  // Subject competence nodes + labels
  sujetNodes.forEach((n, i) => {
    const y = startY + i * rowH;

    const c = mk('circle');
    c.setAttribute('cx', String(xSNode));
    c.setAttribute('cy', String(y));
    c.setAttribute('r', '2.7');
    c.setAttribute('fill', '#64748b');
    svg.appendChild(c);

    const t = mk('text');
    t.setAttribute('x', String(xSNode + 8));
    t.setAttribute('y', String(y));
    t.setAttribute('dominant-baseline', 'middle');
    t.setAttribute('font-size', '11');
    t.setAttribute('fill', '#334155');
    t.textContent = truncate(n.label, 34);
    svg.appendChild(t);

    const m = mk('text');
    m.setAttribute('x', String(xS1 - 4));
    m.setAttribute('y', String(y));
    m.setAttribute('dominant-baseline', 'middle');
    m.setAttribute('text-anchor', 'end');
    m.setAttribute('font-size', '11');
    m.setAttribute('fill', '#64748b');
    m.setAttribute('font-family', 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace');
    m.textContent = String(n.count || 0);
    svg.appendChild(m);
  });

  // Transversal competence nodes + labels
  transNodes.forEach((n, i) => {
    const y = startY + i * rowH;

    const c = mk('circle');
    c.setAttribute('cx', String(xTNode));
    c.setAttribute('cy', String(y));
    c.setAttribute('r', '2.7');
    c.setAttribute('fill', '#64748b');
    svg.appendChild(c);

    const t = mk('text');
    t.setAttribute('x', String(xTNode + 8));
    t.setAttribute('y', String(y));
    t.setAttribute('dominant-baseline', 'middle');
    t.setAttribute('font-size', '11');
    t.setAttribute('fill', '#334155');
    t.textContent = truncate(n.label, 34);
    svg.appendChild(t);

    const m = mk('text');
    m.setAttribute('x', String(xT1 - 4));
    m.setAttribute('y', String(y));
    m.setAttribute('dominant-baseline', 'middle');
    m.setAttribute('text-anchor', 'end');
    m.setAttribute('font-size', '11');
    m.setAttribute('fill', '#64748b');
    m.setAttribute('font-family', 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace');
    m.textContent = String(n.count || 0);
    svg.appendChild(m);
  });
}


function updateCompetenceStats() {
  try {
    const grid = document.getElementById('competences-analysis-grid');
    if (!grid) return;

    const catSujet = (typeof getCompetencesFromUI === 'function') ? (getCompetencesFromUI() || []) : [];
    const catTrans = (typeof getCompetencesTransversalesFromUI === 'function') ? (getCompetencesTransversalesFromUI() || []) : [];

    const sujetById = new Map(catSujet.map(c => [String(c.id || ''), String(c.label || '')]));
    const transById = new Map(catTrans.map(c => [String(c.id || ''), String(c.label || '')]));

    const usedSujet = new Set();
    const usedTrans = new Set();
    const freqSujet = new Map();
    const freqTrans = new Map();

    const activityData = [];

    const steps = Array.from(__ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))))
    steps.forEach((step, idx) => {
      const sSel = step.querySelector('.step-competences-select');
      const tSel = step.querySelector('.step-competences-transversales-select');

      const sIds = new Set(Array.from(sSel?.selectedOptions || []).map(o => String(o.value || '')).filter(Boolean));
      const tIds = new Set(Array.from(tSel?.selectedOptions || []).map(o => String(o.value || '')).filter(Boolean));

      // For competence visualisations: collect a minimal activity→competence mapping
      try {
        const stepTitle = (step.querySelector('.step-input-title')?.value || '').trim() || `Activité ${idx + 1}`;
        const modEl = step.closest('.activity-group');
        const modTitle = (modEl?.querySelector('.activity-title')?.value || '').trim();
        const label = modTitle ? `${modTitle} — ${stepTitle}` : stepTitle;
        activityData.push({ label, module: modTitle || '', sujetIds: Array.from(sIds), transIds: Array.from(tIds) });
      } catch(_){ __ldSilentErr(_); }


      sIds.forEach(id => {
        usedSujet.add(id);
        freqSujet.set(id, (freqSujet.get(id) || 0) + 1);
      });
      tIds.forEach(id => {
        usedTrans.add(id);
        freqTrans.set(id, (freqTrans.get(id) || 0) + 1);
      });
    });

    const sujetDefined = catSujet.length;
    const transDefined = catTrans.length;
    const sujetUsed = catSujet.filter(c => usedSujet.has(String(c.id || ''))).length;
    const transUsed = catTrans.filter(c => usedTrans.has(String(c.id || ''))).length;

    const sujetPct = sujetDefined ? Math.round((sujetUsed / sujetDefined) * 100) : 0;
    const transPct = transDefined ? Math.round((transUsed / transDefined) * 100) : 0;

    const covS = document.getElementById('comp-coverage-sujet');
    const covT = document.getElementById('comp-coverage-trans');
    if (covS) covS.textContent = `${sujetUsed}/${sujetDefined} (${sujetPct}%)`;
    if (covT) covT.textContent = `${transUsed}/${transDefined} (${transPct}%)`;

    function renderUnused(listId, catalogue, usedSet) {
      const ul = document.getElementById(listId);
      if (!ul) return 0;
      const unused = (catalogue || []).filter(c => !usedSet.has(String(c.id || '')));
      ul.innerHTML = '';
      if (!unused.length) {
        const li = document.createElement('li');
        li.className = 'text-slate-400 italic list-none ml-0';
        li.textContent = 'Aucune';
        ul.appendChild(li);
        return 0;
      }
      unused.slice(0, 30).forEach(c => {
        const li = document.createElement('li');
        li.textContent = (c.label || c.id || '').toString();
        ul.appendChild(li);
      });
      if (unused.length > 30) {
        const li = document.createElement('li');
        li.className = 'text-slate-400 italic list-none ml-0';
        li.textContent = `… +${unused.length - 30} autres`;
        ul.appendChild(li);
      }
      return unused.length;
    }

    const nUnusedS = renderUnused('comp-unused-sujet', catSujet, usedSujet);
    const nUnusedT = renderUnused('comp-unused-trans', catTrans, usedTrans);
    const unusedCountEl = document.getElementById('comp-unused-count');
    if (unusedCountEl) unusedCountEl.textContent = `${nUnusedS + nUnusedT}`;

    function renderTop(tbodyId, freqMap, labelById) {
      const tb = document.getElementById(tbodyId);
      if (!tb) return;
      const rows = Array.from(freqMap.entries())
        .filter(([id, n]) => id && n > 0)
        .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])))
        .slice(0, 10);

      tb.innerHTML = '';
      if (!rows.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="px-2 py-1 text-slate-400 italic" colspan="2">Aucune sélection</td>`;
        tb.appendChild(tr);
        return;
      }

      rows.forEach(([id, n]) => {
        const label = labelById.get(String(id)) || `[Inconnue] ${id}`;
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="px-2 py-1 border-t border-slate-100">${__escapeHtmlLite(label)}</td><td class="px-2 py-1 border-t border-slate-100 text-right font-mono">${n}</td>`;
        tb.appendChild(tr);
      });
    }

    renderTop('comp-top-sujet', freqSujet, sujetById);
    renderTop('comp-top-trans', freqTrans, transById);

    // Visual charts (compact option): Top lists as bar charts
    try {
      const topSujetRows = Array.from(freqSujet.entries())
        .filter(([id, n]) => id && (n || 0) > 0)
        .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])))
        .slice(0, 10)
        .map(([id, n]) => ({ label: (sujetById.get(String(id)) || `[Inconnue] ${id}`), value: n }));

      const topTransRows = Array.from(freqTrans.entries())
        .filter(([id, n]) => id && (n || 0) > 0)
        .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])))
        .slice(0, 10)
        .map(([id, n]) => ({ label: (transById.get(String(id)) || `[Inconnue] ${id}`), value: n }));

      if (document.getElementById('chart-comp-top-sujet-html')) {
        renderCountBarsText('chart-comp-top-sujet-html', topSujetRows, { kind: 'sujet' });
      } else {
        drawCountBars('chart-comp-top-sujet', topSujetRows, { kind: 'sujet' });
      }
      if (document.getElementById('chart-comp-top-trans-html')) {
        renderCountBarsText('chart-comp-top-trans-html', topTransRows, { kind: 'trans' });
      } else {
        drawCountBars('chart-comp-top-trans', topTransRows, { kind: 'trans' });
      }
    } catch(_){ __ldSilentErr(_); }


    const tbody = document.getElementById('comp-by-module');
    const __moduleRowsForChart = [];

    if (tbody) {
      const modules = Array.from(document.querySelectorAll('#activities-root .activity-group'));
      tbody.innerHTML = '';
      if (!modules.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="px-2 py-1 text-slate-400 italic" colspan="4">Aucun module</td>`;
        tbody.appendChild(tr);
        try {
          if (document.getElementById('chart-comp-by-module-html')) renderStackedModuleBarsText('chart-comp-by-module-html', []);
          else drawStackedModuleBars('chart-comp-by-module', []);
        } catch(_){ __ldSilentErr(_); }
      } else {
        modules.forEach((mod, i) => {
          const title = (mod.querySelector('.activity-title')?.value || '').trim() || `Module ${i + 1}`;
          const steps = Array.from(__ldFilterStepNodeList(mod.querySelectorAll('.step-card')));
          let totalS = 0;
          let totalT = 0;
          steps.forEach(step => {
            totalS += Array.from(step.querySelector('.step-competences-select')?.selectedOptions || []).map(o => o.value).filter(Boolean).length;
            totalT += Array.from(step.querySelector('.step-competences-transversales-select')?.selectedOptions || []).map(o => o.value).filter(Boolean).length;
          });
          __moduleRowsForChart.push({ label: title, sujet: totalS, trans: totalT });
          const denom = totalS + totalT;
          const pctSujet = denom ? Math.round((totalS / denom) * 100) : 0;
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td class="px-2 py-1 border-t border-slate-100">${__escapeHtmlLite(title)}</td>
            <td class="px-2 py-1 border-t border-slate-100 text-right font-mono">${totalS}</td>
            <td class="px-2 py-1 border-t border-slate-100 text-right font-mono">${totalT}</td>
            <td class="px-2 py-1 border-t border-slate-100 text-right font-mono">${pctSujet}%</td>
          `;
          tbody.appendChild(tr);
        });
        // Keep the latest dataset available for responsive redraws (e.g., width slider / window resize)
        window.__compByModuleRows = __moduleRowsForChart;
        // Visual chart (compact option): stacked distribution by module
        try {
          if (document.getElementById('chart-comp-by-module-html')) renderStackedModuleBarsText('chart-comp-by-module-html', __moduleRowsForChart);
          else drawStackedModuleBars('chart-comp-by-module', __moduleRowsForChart);
        } catch(_){ __ldSilentErr(_); }

      }
    }

    // Visual chart: bipartite network (Activities ↔ Competences)
    try {
      window.__compBipartitePayload = { activities: activityData, sujetById, transById, freqSujet, freqTrans };
      drawCompetenceBipartite('chart-comp-bipartite', window.__compBipartitePayload);
    } catch(_){ __ldSilentErr(_); }

  } catch (err) {
    console.error('updateCompetenceStats failed', err);
  }
}


function updateAimsStats() {
  try {
    const grid = document.getElementById('aims-analysis-grid');
    if (!grid) return;

    // Catalogue (from UI list with Catégorie/Sous-catégorie)
    const items = (typeof getAimsItemsFromUI === 'function') ? (getAimsItemsFromUI() || []) : [];
    const fmt = (typeof _formatCatSubItemLine === 'function') ? _formatCatSubItemLine : function(cat, sub, item){
      const c = String(cat||'').trim();
      const s = String(sub||'').trim();
      const it = String(item||'').trim();
      if (!it) return '';
      if (!c && !s) return it;
      if (c && !s) return `${c} — ${it}`;
      if (!c && s) return `${s} — ${it}`;
      return `${c} / ${s} — ${it}`;
    };

    const defined = (typeof getGlobalLearningAimsOptions === 'function') ? (getGlobalLearningAimsOptions() || []) : items.map(o => fmt(o.categorie, o.sousCategorie, o.item)).filter(Boolean);
    const definedSet = new Set(defined.map(s => String(s||'').trim()).filter(Boolean));

    const metaByLine = new Map();
    items.forEach(o => {
      const line = fmt(o.categorie, o.sousCategorie, o.item);
      if (!line) return;
      metaByLine.set(line, { cat: String(o.categorie||'').trim(), sub: String(o.sousCategorie||'').trim(), item: String(o.item||'').trim() });
    });

    // Scan activities (use hidden select selections)
    const used = new Set();
    const freq = new Map();

    const steps = Array.from(__ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))));
    steps.forEach((step) => {
      const sel = step.querySelector('.step-aims-select');
      const ids = new Set(Array.from(sel?.selectedOptions || []).map(o => String(o.value||'').trim()).filter(Boolean));
      ids.forEach(v => {
        used.add(v);
        freq.set(v, (freq.get(v) || 0) + 1);
      });
    });

    // Coverage
    const definedCount = definedSet.size;
    const usedCount = Array.from(definedSet).filter(v => used.has(v)).length;
    const pct = definedCount ? Math.round((usedCount / definedCount) * 100) : 0;
    const covEl = document.getElementById('aim-coverage');
    if (covEl) covEl.textContent = `${usedCount}/${definedCount} (${pct}%)`;

    // Unused list
    const ul = document.getElementById('aim-unused');
    let unusedCount = 0;
    if (ul) {
      const unused = Array.from(definedSet).filter(v => !used.has(v));
      unusedCount = unused.length;
      ul.innerHTML = '';
      if (!unused.length) {
        const li = document.createElement('li');
        li.className = 'text-slate-400 italic list-none ml-0';
        li.textContent = 'Aucun';
        ul.appendChild(li);
      } else {
        unused.slice(0, 30).forEach(v => {
          const li = document.createElement('li');
          li.textContent = v;
          ul.appendChild(li);
        });
        if (unused.length > 30) {
          const li = document.createElement('li');
          li.className = 'text-slate-400 italic list-none ml-0';
          li.textContent = `… +${unused.length - 30} autres`;
          ul.appendChild(li);
        }
      }
    }
    const unusedCountEl = document.getElementById('aim-unused-count');
    if (unusedCountEl) unusedCountEl.textContent = String(unusedCount);

    // Top aims table + bars
    const topRows = Array.from(freq.entries())
      .filter(([k, n]) => k && (n || 0) > 0)
      .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])))
      .slice(0, 10)
      .map(([k, n]) => ({ label: k, value: n }));

    try { renderCountBarsText('chart-aim-top-html', topRows, { kind: 'aims' }); } catch(_){ __ldSilentErr(_); }

    const tb = document.getElementById('aim-top-table');
    if (tb) {
      tb.innerHTML = '';
      if (!topRows.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="px-2 py-1 text-slate-400 italic" colspan="2">Aucune sélection</td>`;
        tb.appendChild(tr);
      } else {
        topRows.forEach(r => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td class="px-2 py-1 border-t border-slate-100">${__escapeHtmlLite(String(r.label||''))}</td><td class="px-2 py-1 border-t border-slate-100 text-right font-mono">${__escapeHtmlLite(String(r.value||0))}</td>`;
          tb.appendChild(tr);
        });
      }
    }

    // By category (based on catalogue metadata)
    function catForLine(line) {
      const m = metaByLine.get(line);
      if (m) return (m.cat || 'Sans catégorie');
      // Fallback: try parse "Cat / Sub — Item" or "Cat — Item"
      const s = String(line || '').trim();
      if (!s) return 'Sans catégorie';
      const parts = s.split('—');
      if (parts.length < 2) return 'Sans catégorie';
      const left = parts[0].trim();
      if (!left) return 'Sans catégorie';
      // If "Cat / Sub" keep Cat
      return left.split('/')[0].trim() || 'Sans catégorie';
    }

    const catFreq = new Map();
    used.forEach(line => {
      const c = catForLine(line);
      catFreq.set(c, (catFreq.get(c) || 0) + 1);
    });

    const catRows = Array.from(catFreq.entries())
      .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])))
      .slice(0, 12)
      .map(([label, value]) => ({ label, value }));
    try { renderCountBarsText('chart-aim-by-category-html', catRows, { kind: 'aims' }); } catch(_){ __ldSilentErr(_); }

    // By module (count of selected aims across activities)
    const moduleRows = [];
    const modules = Array.from(document.querySelectorAll('#activities-root .activity-group'));
    modules.forEach((mod, i) => {
      const title = (mod.querySelector('.activity-title')?.value || '').trim() || `Module ${i + 1}`;
      const steps = Array.from(__ldFilterStepNodeList(mod.querySelectorAll('.step-card')));
      let total = 0;
      steps.forEach(step => {
        total += Array.from(step.querySelector('.step-aims-select')?.selectedOptions || []).map(o => String(o.value||'').trim()).filter(Boolean).length;
      });
      moduleRows.push({ label: title, value: total });
    });
    // Sort by value descending for readability
    moduleRows.sort((a, b) => (b.value - a.value) || String(a.label).localeCompare(String(b.label)));
    try { renderCountBarsText('chart-aim-by-module-html', moduleRows.slice(0, 12), { kind: 'aims' }); } catch(_){ __ldSilentErr(_); }

  } catch (err) {
    console.error('updateAimsStats failed', err);
  }
}

function updateOutcomesStats() {
  try {
    const grid = document.getElementById('outcomes-analysis-grid');
    if (!grid) return;

    // Catalogue (from UI list with Catégorie/Sous-catégorie)
    const items = (typeof getOutcomesTextItemsFromUI === 'function') ? (getOutcomesTextItemsFromUI() || []) : [];
    const fmt = (typeof _formatCatSubItemLine === 'function') ? _formatCatSubItemLine : function(cat, sub, item){
      const c = String(cat||'').trim();
      const s = String(sub||'').trim();
      const it = String(item||'').trim();
      if (!it) return '';
      if (!c && !s) return it;
      if (c && !s) return `${c} — ${it}`;
      if (!c && s) return `${s} — ${it}`;
      return `${c} / ${s} — ${it}`;
    };

    const defined = (typeof getGlobalLearningOutcomesOptions === 'function') ? (getGlobalLearningOutcomesOptions() || []) : items.map(o => fmt(o.categorie, o.sousCategorie, o.item)).filter(Boolean);
    const definedSet = new Set(defined.map(s => String(s||'').trim()).filter(Boolean));

    const metaByLine = new Map();
    items.forEach(o => {
      const line = fmt(o.categorie, o.sousCategorie, o.item);
      if (!line) return;
      metaByLine.set(line, { cat: String(o.categorie||'').trim(), sub: String(o.sousCategorie||'').trim(), item: String(o.item||'').trim() });
    });

    // Scan activities
    const used = new Set();
    const freq = new Map();

    const steps = Array.from(__ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))));
    steps.forEach((step) => {
      const sel = step.querySelector('.step-outcomes-select');
      const ids = new Set(Array.from(sel?.selectedOptions || []).map(o => String(o.value||'').trim()).filter(Boolean));
      ids.forEach(v => {
        used.add(v);
        freq.set(v, (freq.get(v) || 0) + 1);
      });
    });

    // Coverage
    const definedCount = definedSet.size;
    const usedCount = Array.from(definedSet).filter(v => used.has(v)).length;
    const pct = definedCount ? Math.round((usedCount / definedCount) * 100) : 0;
    const covEl = document.getElementById('out-coverage');
    if (covEl) covEl.textContent = `${usedCount}/${definedCount} (${pct}%)`;

    // Unused list
    const ul = document.getElementById('out-unused');
    let unusedCount = 0;
    if (ul) {
      const unused = Array.from(definedSet).filter(v => !used.has(v));
      unusedCount = unused.length;
      ul.innerHTML = '';
      if (!unused.length) {
        const li = document.createElement('li');
        li.className = 'text-slate-400 italic list-none ml-0';
        li.textContent = 'Aucun';
        ul.appendChild(li);
      } else {
        unused.slice(0, 30).forEach(v => {
          const li = document.createElement('li');
          li.textContent = v;
          ul.appendChild(li);
        });
        if (unused.length > 30) {
          const li = document.createElement('li');
          li.className = 'text-slate-400 italic list-none ml-0';
          li.textContent = `… +${unused.length - 30} autres`;
          ul.appendChild(li);
        }
      }
    }
    const unusedCountEl = document.getElementById('out-unused-count');
    if (unusedCountEl) unusedCountEl.textContent = String(unusedCount);

    // Top outcomes table + bars
    const topRows = Array.from(freq.entries())
      .filter(([k, n]) => k && (n || 0) > 0)
      .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])))
      .slice(0, 10)
      .map(([k, n]) => ({ label: k, value: n }));

    try { renderCountBarsText('chart-out-top-html', topRows, { kind: 'outcomes' }); } catch(_){ __ldSilentErr(_); }

    const tb = document.getElementById('out-top-table');
    if (tb) {
      tb.innerHTML = '';
      if (!topRows.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="px-2 py-1 text-slate-400 italic" colspan="2">Aucune sélection</td>`;
        tb.appendChild(tr);
      } else {
        topRows.forEach(r => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td class="px-2 py-1 border-t border-slate-100">${__escapeHtmlLite(String(r.label||''))}</td><td class="px-2 py-1 border-t border-slate-100 text-right font-mono">${__escapeHtmlLite(String(r.value||0))}</td>`;
          tb.appendChild(tr);
        });
      }
    }

    // By category
    function catForLine(line) {
      const m = metaByLine.get(line);
      if (m) return (m.cat || 'Sans catégorie');
      const s = String(line || '').trim();
      if (!s) return 'Sans catégorie';
      const parts = s.split('—');
      if (parts.length < 2) return 'Sans catégorie';
      const left = parts[0].trim();
      if (!left) return 'Sans catégorie';
      return left.split('/')[0].trim() || 'Sans catégorie';
    }

    const catFreq = new Map();
    used.forEach(line => {
      const c = catForLine(line);
      catFreq.set(c, (catFreq.get(c) || 0) + 1);
    });

    const catRows = Array.from(catFreq.entries())
      .sort((a, b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0])))
      .slice(0, 12)
      .map(([label, value]) => ({ label, value }));
    try { renderCountBarsText('chart-out-by-category-html', catRows, { kind: 'outcomes' }); } catch(_){ __ldSilentErr(_); }

    // By module
    const moduleRows = [];
    const modules = Array.from(document.querySelectorAll('#activities-root .activity-group'));
    modules.forEach((mod, i) => {
      const title = (mod.querySelector('.activity-title')?.value || '').trim() || `Module ${i + 1}`;
      const steps = Array.from(__ldFilterStepNodeList(mod.querySelectorAll('.step-card')));
      let total = 0;
      steps.forEach(step => {
        total += Array.from(step.querySelector('.step-outcomes-select')?.selectedOptions || []).map(o => String(o.value||'').trim()).filter(Boolean).length;
      });
      moduleRows.push({ label: title, value: total });
    });
    moduleRows.sort((a, b) => (b.value - a.value) || String(a.label).localeCompare(String(b.label)));
    try { renderCountBarsText('chart-out-by-module-html', moduleRows.slice(0, 12), { kind: 'outcomes' }); } catch(_){ __ldSilentErr(_); }

  } catch (err) {
    console.error('updateOutcomesStats failed', err);
  }
}

function updateCharts() {
    drawPie('chart-learning-types', tallyDuration('.learning-type-select'));
    drawBars('chart-group-modes', tallyDurationMeta('.step-group-mode', 'group'));
    drawBars('chart-place-modes', tallyDurationMeta('.place-select', 'place'));
    drawBars('chart-time-modes', tallyDurationMeta('.time-select', 'time'));
    drawBars('chart-trainer-presence', tallyDurationMeta('.trainer-select', 'trainer'));
    updateCompetenceStats();
    updateAimsStats();
    updateOutcomesStats();
  }

  // Throttled scheduling (avoid chart recompute storms on large DOM mutations / imports)
  let __chartsSuspended = false;
  let __chartsRaf = null;
  function requestUpdateCharts() {
    if (__chartsSuspended) return;
    if (__chartsRaf) return;
    __chartsRaf = requestAnimationFrame(() => {
      __chartsRaf = null;
      if (__chartsSuspended) return;
      updateCharts();
    });
  }
  window.__setChartsSuspended = function(v){
    __chartsSuspended = !!v;
    if (!__chartsSuspended) requestUpdateCharts();
  };

  // Update on value changes (delegated, minimal footprint)
  document.addEventListener('change', (e) => {
    const t = e.target;
    if (!t) return;
    if (t.matches('.learning-type-select, .step-group-mode, .place-select, .time-select, .trainer-select, .step-competences-select, .step-competences-transversales-select, .step-aims-select, .step-outcomes-select')) {
      requestUpdateCharts();
    }
  }, true);

  // Update on DOM changes (activities added/removed)
  if (rootEl && window.MutationObserver) {
    const mo = new MutationObserver(() => requestUpdateCharts());
    mo.observe(rootEl, { childList: true, subtree: true });
  }


  // Also refresh charts when the competence catalogues change
  try {
    const c1 = document.getElementById('competences-list');
    const c2 = document.getElementById('competences-transversales-list');
    if (window.MutationObserver) {
      const mo2 = new MutationObserver(() => requestUpdateCharts());
      if (c1) mo2.observe(c1, { childList: true, subtree: true });
      if (c2) mo2.observe(c2, { childList: true, subtree: true });
    }
  } catch(_){ __ldSilentErr(_); }

  // Also refresh charts when the aims/outcomes catalogues change
  try {
    const a1 = document.getElementById('aims-list');
    const o1 = document.getElementById('outcomes-text-list');
    if (window.MutationObserver) {
      const mo3 = new MutationObserver(() => requestUpdateCharts());
      if (a1) mo3.observe(a1, { childList: true, subtree: true });
      if (o1) mo3.observe(o1, { childList: true, subtree: true });
    }
  } catch(_){ __ldSilentErr(_); }


  // Keep the "Répartition par module" chart crisp and proportionally correct when its container width changes
  // (e.g., window resize or the global width slider). This avoids CSS stretching of an already-drawn canvas.
  try {
    const byModCard = document.getElementById('competences-by-module-card');
    if (byModCard && window.ResizeObserver) {
      let __roRaf = null;
      const ro = new ResizeObserver(() => {
        if (__roRaf) return;
        __roRaf = requestAnimationFrame(() => {
          __roRaf = null;
          try {
            if (document.getElementById('chart-comp-by-module-html')) renderStackedModuleBarsText('chart-comp-by-module-html', window.__compByModuleRows || []);
            else drawStackedModuleBars('chart-comp-by-module', window.__compByModuleRows || []);
          } catch(_){ __ldSilentErr(_); }
        });
      });
      ro.observe(byModCard);
    } else if (byModCard) {
      window.addEventListener('resize', () => {
        try {
            if (document.getElementById('chart-comp-by-module-html')) renderStackedModuleBarsText('chart-comp-by-module-html', window.__compByModuleRows || []);
            else drawStackedModuleBars('chart-comp-by-module', window.__compByModuleRows || []);
          } catch(_){ __ldSilentErr(_); }
      }, { passive: true });
    }
  } catch(_){ __ldSilentErr(_); }

  

  // Keep the bipartite network crisp when its container width changes
  try {
    const bipCard = document.getElementById('competences-bipartite-card');
    if (bipCard && window.ResizeObserver) {
      let __bipRaf = null;
      const roBip = new ResizeObserver(() => {
        if (__bipRaf) return;
        __bipRaf = requestAnimationFrame(() => {
          __bipRaf = null;
          try { drawCompetenceBipartite('chart-comp-bipartite', window.__compBipartitePayload || {}); } catch(_){ __ldSilentErr(_); }
        });
      });
      roBip.observe(bipCard);
    } else if (bipCard) {
      window.addEventListener('resize', () => {
        try { drawCompetenceBipartite('chart-comp-bipartite', window.__compBipartitePayload || {}); } catch(_){ __ldSilentErr(_); }
      }, { passive: true });
    }
  } catch(_){ __ldSilentErr(_); }
// Initial render (after current call stack so layout has widths)
  setTimeout(requestUpdateCharts, 0);
})();
// ------------------------------
// Namespaces (organisation layer)
// ------------------------------
// This groups existing global functions under window.App.* without changing the UI
// or breaking inline event handlers that still reference legacy global names.
(function initNamespaces(){
  window.App = window.App || {};
  const App = window.App;

  const ensure = (k) => (App[k] = App[k] || {});
  const UI = ensure('UI');
  const Data = ensure('Data');
  const Export = ensure('Export');
  const Timeline = ensure('Timeline');
  const History = ensure('History');
  ensure('State');

  const pick = (target, mapping) => {
    for (const [name, fn] of Object.entries(mapping)) {
      if (typeof fn === 'function') target[name] = fn;
    }
  };

  // UI helpers (tooltips, focus, highlighting, contrast)
  pick(UI, {
    showTooltip,
    hideTooltip,
    updateTooltipPos,
    flashHighlight,
    scrollToEditor,
    updateFocusButtons,
    setHighContrastEnabled,
    updateContrastToggleUI,
    showJsErrorBanner
  });

  // Timeline rendering / stats
  pick(Timeline, {
    updateStats,
    updateStatsDebounced,
    getTotals,
    formatTimelineDuration,
    applyTimelineZoom,
    setTimelineZoom,
    bumpTimelineZoom,
    setupTimelineHScroll,
    updateTimelineHScroll,
    updateTimelineHScrollThumb
  });

  // Data (snapshot/restore/autosave)
  pick(Data, {
    snapshotProject,
    applySnapshot,
    buildExportProjectData,
    addActivityFromData,
    addStepToContainerFromData,
    saveProject,
    getAutosavePayload,
    hasAutosave,
    clearAutosave,
    scheduleAutosave
  });

  // History (undo/redo)
  pick(History, {
    undo,
    redo,
    scheduleHistoryCapture,
    historyCaptureNow
  });

  // Export routing
  pick(Export, {
    handleExport
  });

  // Seal namespaces to reduce accidental mutation.
  try {
    Object.seal(UI);
    Object.seal(Data);
    Object.seal(Export);
    Object.seal(Timeline);
    Object.seal(History);
  } catch(_){ __ldSilentErr(_); }
})();


// =========================
// Modèles (templates) - Export / Import
// =========================
(function initTemplatesFeature() {
  const $ = (id) => document.getElementById(id);

  const root = document.getElementById('activities-root');

  let loadedTemplate = null; // {type, payload}

  function ensureInBody(el) {
    if (!el) return;
    try {
      if (!document.body.contains(el)) document.body.appendChild(el);
    } catch(_){ __ldSilentErr(_); }
  }

  function show(el) {
    if (!el) return;
    ensureInBody(el);
    el.classList.remove('hidden');
    // Force visible display immediately (avoid "affichage retardé" sur certains WebView)
    const disp = el.dataset && el.dataset.display ? el.dataset.display : (el.classList.contains('items-center') ? 'flex' : 'block');
    el.style.display = disp;
    el.style.visibility = 'visible';
    el.style.pointerEvents = 'auto';
    // Force reflow to commit styles before returning
    void el.offsetHeight;
  }

  function hide(el) {
    if (!el) return;
    el.classList.add('hidden');
    el.style.display = 'none';
  }
  function setError(id, msg) {
    const el = $(id);
    if (!el) return;
    if (msg) { el.textContent = msg; show(el); } else { el.textContent = ''; hide(el); }
  }

  function safeText(v, fallback) {
    const s = (v ?? '').toString().trim();
    return s ? s : fallback;
  }

  function listModules() {
    return Array.from(document.querySelectorAll('.activity-group'));
  }

  function listMoments() {
    const modules = listModules();
    const out = [];
    modules.forEach((modEl, mi) => {
      const mt = safeText(modEl.querySelector('.activity-title')?.value, `Module ${mi + 1}`);
      const moments = Array.from(modEl.querySelectorAll('.moment-group'));
      moments.forEach((momEl, mosi) => {
        const tt = safeText(momEl.querySelector('.moment-title')?.value, `Moment ${mosi + 1}`);
        out.push({ modIndex: mi, momentIndex: mosi, modTitle: mt, momentTitle: tt, el: momEl, moduleEl: modEl });
      });
    });
    return out;
  }

  function listActivities() {
    const moments = listMoments();
    const out = [];
    moments.forEach((m) => {
      const steps = Array.from(m.__ldFilterStepNodeList(el.querySelectorAll('.step-card')));
      steps.forEach((stepEl, si) => {
        const st = safeText(stepEl.querySelector('.step-input-title')?.value, `Activité ${si + 1}`);
        out.push({
          modIndex: m.modIndex, momentIndex: m.momentIndex, stepIndex: si,
          label: `${m.modTitle} — ${m.momentTitle} — ${st}`,
          el: stepEl, momentEl: m.el, moduleEl: m.moduleEl
        });
      });
    });
    return out;
  }

  function buildStepDataFromEl(stepEl) {
    return {
      title: stepEl.querySelector('.step-input-title')?.value || "",
      type: stepEl.querySelector('.learning-type-select')?.value || "acquisition",
      duration: parseFloat(stepEl.querySelector('.duration-input')?.value || "0") || 0,
      unit: stepEl.querySelector('.duration-unit')?.value || getDefaultDurationUnitKey?.() || "60",
      status: getStepStatus(stepEl)
    };
  }

  function buildMomentDataFromEl(momentEl) {
    const stepsContainer = momentEl.querySelector('.activity-steps-container');
    const stepEls = stepsContainer ? Array.from(__ldFilterStepNodeList(stepsContainer.querySelectorAll('.step-card'))) : [];
    return {
      title: momentEl.querySelector('.moment-title')?.value || "",
      description: momentEl.querySelector('.moment-description')?.value || "",
      targetTime: momentEl.querySelector('.moment-target-time')?.value || "",
      targetUnit: momentEl.querySelector('.moment-target-unit')?.value || (typeof getDefaultDurationUnitSecs === 'function' ? getDefaultDurationUnitSecs() : "60"),
      steps: stepEls.map(buildStepDataFromEl)
    };
  }

  function buildModuleDataFromEl(modEl) {
    const momentsRoot = modEl.querySelector('.activity-moments-container');
    const momentEls = momentsRoot ? Array.from(momentsRoot.querySelectorAll('.moment-group')) : [];
    return {
      title: modEl.querySelector('.activity-title')?.value || "",
      description: modEl.querySelector('.activity-description')?.value || "",
      targetTime: modEl.querySelector('.activity-target-time')?.value || "",
      targetUnit: modEl.querySelector('.activity-target-unit')?.value || (typeof getDefaultDurationUnitKey === 'function' ? getDefaultDurationUnitKey() : "60"),
      moments: momentEls.map(buildMomentDataFromEl),
      competencesModuleSujet: (typeof getSelectedModuleTargetCompetencesSujetIds === 'function') ? getSelectedModuleTargetCompetencesSujetIds(modEl) : [],
      competencesModuleTransversales: (typeof getSelectedModuleTargetCompetencesTransvIds === 'function') ? getSelectedModuleTargetCompetencesTransvIds(modEl) : []
    };
  }

  function downloadJSON(filename, obj) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 0);
  }

  function populateExportItems() {
    const type = $('template-export-type')?.value || 'module';
    const sel = $('template-export-item');
    if (!sel) return;
    sel.innerHTML = '';
    if (type === 'module') {
      const mods = listModules();
      mods.forEach((modEl, i) => {
        const label = safeText(modEl.querySelector('.activity-title')?.value, `Module ${i + 1}`);
        const opt = document.createElement('option');
        opt.value = JSON.stringify({ modIndex: i });
        opt.textContent = label;
        sel.appendChild(opt);
      });
    } else if (type === 'moment') {
      const moms = listMoments();
      moms.forEach((m) => {
        const opt = document.createElement('option');
        opt.value = JSON.stringify({ modIndex: m.modIndex, momentIndex: m.momentIndex });
        opt.textContent = `${m.modTitle} — ${m.momentTitle}`;
        sel.appendChild(opt);
      });
    } else {
      const acts = listActivities();
      acts.forEach((a) => {
        const opt = document.createElement('option');
        opt.value = JSON.stringify({ modIndex: a.modIndex, momentIndex: a.momentIndex, stepIndex: a.stepIndex });
        opt.textContent = a.label;
        sel.appendChild(opt);
      });
    }
  }

  function openExport() {
    setError('template-export-error', '');
    populateExportItems();
    show($('template-export-modal'));
  }
  function closeExport() { hide($('template-export-modal')); }

  function openImport() {
    setError('template-import-error', '');
    const _tplLab = $('template-import-filelabel');
    if (_tplLab) _tplLab.textContent = '';
    loadedTemplate = null;
    hide($('template-import-placements'));
    hide($('tpl-place-module')); hide($('tpl-place-moment')); hide($('tpl-place-activity'));
    show($('template-import-modal'));
  }
  function closeImport() { hide($('template-import-modal')); }

  // API publique (utilisée par les attributs onclick des boutons "Modèles")
  // On expose volontairement des wrappers stables afin d'éviter toute dépendance au routeur global.
  function openTemplateExportModal() { return openExport(); }
  function openTemplateImportModal() { return openImport(); }
  window.__realOpenTemplateExport = openTemplateExportModal;
  window.__realOpenTemplateImport = openTemplateImportModal;
  if (typeof window.__flushPendingTemplateModal === 'function') window.__flushPendingTemplateModal();


  function exportTemplateNow() {
    setError('template-export-error', '');
    const type = $('template-export-type')?.value || 'module';
    const itemVal = $('template-export-item')?.value;
    if (!itemVal) { setError('template-export-error', "Aucun élément sélectionné."); return; }

    let path;
    try { path = JSON.parse(itemVal); } catch { setError('template-export-error', "Sélection invalide."); return; }

    let payload;
    try {
      if (type === 'module') {
        const modEl = listModules()[path.modIndex];
        if (!modEl) throw new Error("Module introuvable.");
        payload = buildModuleDataFromEl(modEl);
      } else if (type === 'moment') {
        const modEl = listModules()[path.modIndex];
        const momentEl = modEl?.querySelectorAll('.moment-group')?.[path.momentIndex];
        if (!momentEl) throw new Error("Moment introuvable.");
        payload = buildMomentDataFromEl(momentEl);
      } else {
        const modEl = listModules()[path.modIndex];
        const momentEl = modEl?.querySelectorAll('.moment-group')?.[path.momentIndex];
        const stepEl = momentEl?.querySelectorAll('.step-card')?.[path.stepIndex];
        if (!stepEl) throw new Error("Activité introuvable.");
        payload = buildStepDataFromEl(stepEl);
      }
    } catch (e) {
      setError('template-export-error', e?.message || "Erreur lors de l’export.");
      return;
    }

    const tpl = {
      templateVersion: "1.0",
      exportedAt: new Date().toISOString(),
      type,
      payload
    };
    const fn = `modele_${type}_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
    downloadJSON(fn, tpl);
    closeExport();
  }

  function populateModuleAfterSelect() {
    const sel = $('tpl-module-after');
    if (!sel) return;
    sel.innerHTML = '';
    listModules().forEach((modEl, i) => {
      const label = safeText(modEl.querySelector('.activity-title')?.value, `Module ${i + 1}`);
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = label;
      sel.appendChild(opt);
    });
  }

  function populateMomentPlacement() {
    const modSel = $('tpl-moment-module');
    const afterSel = $('tpl-moment-after');
    if (!modSel || !afterSel) return;

    modSel.innerHTML = '';
    listModules().forEach((modEl, i) => {
      const label = safeText(modEl.querySelector('.activity-title')?.value, `Module ${i + 1}`);
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = label;
      modSel.appendChild(opt);
    });

    const fillAfter = () => {
      afterSel.innerHTML = '';
      const mi = parseInt(modSel.value || "0", 10);
      const modEl = listModules()[mi];
      const moments = modEl ? Array.from(modEl.querySelectorAll('.moment-group')) : [];
      moments.forEach((momEl, j) => {
        const label = safeText(momEl.querySelector('.moment-title')?.value, `Moment ${j + 1}`);
        const opt = document.createElement('option');
        opt.value = String(j);
        opt.textContent = label;
        afterSel.appendChild(opt);
      });
    };
    modSel.onchange = fillAfter;
    fillAfter();
  }

  function populateActivityPlacement() {
    const modSel = $('tpl-act-module');
    const momSel = $('tpl-act-moment');
    const afterSel = $('tpl-act-after');
    if (!modSel || !momSel || !afterSel) return;

    modSel.innerHTML = '';
    listModules().forEach((modEl, i) => {
      const label = safeText(modEl.querySelector('.activity-title')?.value, `Module ${i + 1}`);
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = label;
      modSel.appendChild(opt);
    });

    const fillMoments = () => {
      momSel.innerHTML = '';
      const mi = parseInt(modSel.value || "0", 10);
      const modEl = listModules()[mi];
      const moments = modEl ? Array.from(modEl.querySelectorAll('.moment-group')) : [];
      moments.forEach((momEl, j) => {
        const label = safeText(momEl.querySelector('.moment-title')?.value, `Moment ${j + 1}`);
        const opt = document.createElement('option');
        opt.value = String(j);
        opt.textContent = label;
        momSel.appendChild(opt);
      });
      fillAfter();
    };

    const fillAfter = () => {
      afterSel.innerHTML = '';
      const mi = parseInt(modSel.value || "0", 10);
      const mosi = parseInt(momSel.value || "0", 10);
      const modEl = listModules()[mi];
      const momEl = modEl ? Array.from(modEl.querySelectorAll('.moment-group'))[mosi] : null;
      const steps = momEl ? Array.from(__ldFilterStepNodeList(momEl.querySelectorAll('.step-card'))) : [];
      steps.forEach((stepEl, k) => {
        const label = safeText(stepEl.querySelector('.step-input-title')?.value, `Activité ${k + 1}`);
        const opt = document.createElement('option');
        opt.value = String(k);
        opt.textContent = label;
        afterSel.appendChild(opt);
      });
    };

    modSel.onchange = fillMoments;
    momSel.onchange = fillAfter;
    fillMoments();
  }

  function applyPlacementUI(type) {
    const _tplType = $('template-import-type');
    if (_tplType) _tplType.textContent = type === 'module' ? 'Module' : (type === 'moment' ? 'Moment' : 'Activité');

    hide($('tpl-place-module')); hide($('tpl-place-moment')); hide($('tpl-place-activity'));

    if (type === 'module') {
      populateModuleAfterSelect();
      show($('tpl-place-module'));
    } else if (type === 'moment') {
      populateMomentPlacement();
      show($('tpl-place-moment'));
    } else {
      populateActivityPlacement();
      show($('tpl-place-activity'));
    }

    show($('template-import-placements'));
  }

  function readTemplateFile(file) {
    setError('template-import-error', '');
    if (!file) return;
    const label = $('template-import-filelabel');
    if (label) label.textContent = file.name;

    const reader = new FileReader();
    reader.onload = () => {
      try {
        const obj = JSON.parse(reader.result);
        if (!obj || typeof obj !== 'object') throw new Error("Fichier invalide.");
        if (!obj.type || !obj.payload) throw new Error("Modèle invalide (type/payload manquants).");
        if (!['module', 'moment', 'activity'].includes(obj.type)) throw new Error("Type de modèle inconnu.");
        loadedTemplate = { type: obj.type, payload: obj.payload };
        applyPlacementUI(obj.type);
      } catch (e) {
        loadedTemplate = null;
        hide($('template-import-placements'));
        setError('template-import-error', e?.message || "Impossible de lire le modèle.");
      }
    };
    reader.readAsText(file);
  }
function insertModule(payload, position, refIndex) {
  if (typeof window.App?.Data?.addActivityFromData !== 'function') throw new Error("Fonction d'ajout de module introuvable.");
  window.App.Data.addActivityFromData(payload);
  const newEl = root?.lastElementChild;
  if (!newEl) return;

  const modules = listModules();
  const targetIndex = (() => {
    if (position === 'start') return 0;
    if (position === 'end') return modules.length - 1; // already end
    if (position === 'before') return Math.max(refIndex ?? 0, 0);
    if (position === 'after') return Math.min((refIndex ?? 0) + 1, modules.length - 1);
    return modules.length - 1;
  })();

  // If already at end and target is end, nothing to do
  if (position === 'end') return;

  const ref = root.children[targetIndex];
  if (ref && ref !== newEl) root.insertBefore(newEl, ref);
}
function insertMoment(payload, moduleIndex, position, refMomentIndex) {
  const modules = listModules();
  const modEl = modules[moduleIndex];
  if (!modEl) throw new Error("Module cible introuvable.");
  const momentsRoot = modEl.querySelector('.activity-moments-container');
  if (!momentsRoot) throw new Error("Conteneur de moments introuvable.");
  if (!window.momentTemplate) {
    // momentTemplate is a const in the outer scope, but in some builds it is not global; fallback to DOM lookup
  }
  const tpl = document.getElementById('moment-template');
  if (!tpl) throw new Error("Template de moment introuvable.");
  const clone = tpl.content.cloneNode(true);
  const momentEl = clone.querySelector('.moment-group') || clone.firstElementChild;
  // Fill fields
  momentEl.querySelector('.moment-title').value = payload.title || "";
  momentEl.querySelector('.moment-description').value = payload.description || "";
  momentEl.querySelector('.moment-target-time').value = payload.targetTime || "";
  const unitSel = momentEl.querySelector('.moment-target-unit');
  if (unitSel) unitSel.value = payload.targetUnit || (typeof getDefaultDurationUnitSecs === 'function' ? getDefaultDurationUnitSecs() : "60");

  const stepsContainer = momentEl.querySelector('.activity-steps-container');
  if (stepsContainer) {
    stepsContainer.innerHTML = '';
    if (Array.isArray(payload.steps)) {
      payload.steps.forEach(s => {
        if (typeof window.App?.Data?.addStepToContainerFromData === 'function') window.App.Data.addStepToContainerFromData(stepsContainer, s);
      });
    }
    if (typeof initSortableSteps === 'function') initSortableSteps(stepsContainer);
  
  try { setupCompactTextareas(stepsContainer); } catch(_){ __ldSilentErr(_); }
}

  // Insert at right place
  const existing = Array.from(momentsRoot.querySelectorAll('.moment-group'));
  if (position === 'start') {
    momentsRoot.insertBefore(momentEl, existing[0] || null);
  } else if (position === 'before') {
    const ref = existing[refMomentIndex] || null;
    if (ref) momentsRoot.insertBefore(momentEl, ref);
    else momentsRoot.appendChild(momentEl);
  } else if (position === 'after') {
    const ref = existing[refMomentIndex] || null;
    if (ref && ref.nextSibling) momentsRoot.insertBefore(momentEl, ref.nextSibling);
    else momentsRoot.appendChild(momentEl);
  } else {
    momentsRoot.appendChild(momentEl);
  }

  if (typeof updateMomentIndexes === 'function') updateMomentIndexes(modEl);
}
function insertActivity(payload, moduleIndex, momentIndex, position, refStepIndex) {
  const modules = listModules();
  const modEl = modules[moduleIndex];
  if (!modEl) throw new Error("Module cible introuvable.");
  const momentEl = Array.from(modEl.querySelectorAll('.moment-group'))[momentIndex];
  if (!momentEl) throw new Error("Moment cible introuvable.");
  const stepsContainer = momentEl.querySelector('.activity-steps-container');
  if (!stepsContainer) throw new Error("Conteneur d'activités introuvable.");

  const tpl = document.getElementById('step-template');
  if (!tpl) throw new Error("Template d'activité introuvable.");
  const clone = tpl.content.cloneNode(true);
  const stepEl = clone.querySelector('.step-card') || clone.firstElementChild;

  stepEl.querySelector('.step-input-title').value = payload.title || "";
  stepEl.querySelector('.learning-type-select').value = payload.type || "acquisition";
  stepEl.querySelector('.duration-input').value = payload.duration || 0;
  stepEl.querySelector('.duration-unit').value = payload.unit || (typeof getDefaultDurationUnitKey === 'function' ? getDefaultDurationUnitKey() : "60");

  const existing = Array.from(__ldFilterStepNodeList(stepsContainer.querySelectorAll('.step-card')));
  if (position === 'start') {
    stepsContainer.insertBefore(stepEl, existing[0] || null);
  } else if (position === 'before') {
    const ref = existing[refStepIndex] || null;
    if (ref) stepsContainer.insertBefore(stepEl, ref);
    else stepsContainer.appendChild(stepEl);
  } else if (position === 'after') {
    const ref = existing[refStepIndex] || null;
    if (ref && ref.nextSibling) stepsContainer.insertBefore(stepEl, ref.nextSibling);
    else stepsContainer.appendChild(stepEl);
  } else {
    stepsContainer.appendChild(stepEl);
  }

  if (typeof initSortableSteps === 'function') initSortableSteps(stepsContainer);
  
  try { setupCompactTextareas(stepsContainer); } catch(_){ __ldSilentErr(_); }
if (typeof updateMomentIndexes === 'function') updateMomentIndexes(modEl);
}


  function doImport() {
    setError('template-import-error', '');
    if (!loadedTemplate) { setError('template-import-error', "Aucun modèle chargé."); return; }

    try {
      if (loadedTemplate.type === 'module') {
        const pos = $('tpl-module-position')?.value || 'end';
        const afterIndex = parseInt($('tpl-module-after')?.value || "0", 10);
        insertModule(loadedTemplate.payload, pos, afterIndex);
      } else if (loadedTemplate.type === 'moment') {
        const modIndex = parseInt($('tpl-moment-module')?.value || "0", 10);
        const pos = $('tpl-moment-position')?.value || 'end';
        const afterIndex = parseInt($('tpl-moment-after')?.value || "0", 10);
        insertMoment(loadedTemplate.payload, modIndex, pos, afterIndex);
      } else {
        const modIndex = parseInt($('tpl-act-module')?.value || "0", 10);
        const momIndex = parseInt($('tpl-act-moment')?.value || "0", 10);
        const pos = $('tpl-act-position')?.value || 'end';
        const afterIndex = parseInt($('tpl-act-after')?.value || "0", 10);
        insertActivity(loadedTemplate.payload, modIndex, momIndex, pos, afterIndex);
      }

      if (typeof updateStats === 'function') updateStats();
      closeImport();
    } catch (e) {
      setError('template-import-error', e?.message || "Erreur lors de l’import.");
    }
  }


  // Expose minimal API for environments where click listeners are neutralised
  window.__realOpenTemplateExport = openExport;
  window.__realOpenTemplateImport = openImport;
  if (typeof window.__flushPendingTemplateModal === 'function') window.__flushPendingTemplateModal();

  // Assure un déclenchement immédiat des boutons Modèles, même si un routeur global intercepte les clics.
  // Strictement limité aux IDs des boutons Modèles pour éviter toute interférence avec les autres actions.

  // Bind UI (direct, no interaction with the global router)
function bind() {
  // Toolbar buttons
  $('btn-template-export')?.addEventListener('click', openExport);
  $('btn-template-import')?.addEventListener('click', openImport);

  // Export modal controls
  $('template-export-close')?.addEventListener('click', closeExport);
  $('template-export-cancel')?.addEventListener('click', closeExport);
  $('template-export-do')?.addEventListener('click', exportTemplateNow);
  $('template-export-type')?.addEventListener('change', populateExportItems);

  // Import modal controls
  $('template-import-close')?.addEventListener('click', closeImport);
  $('template-import-cancel')?.addEventListener('click', closeImport);
  $('template-import-do')?.addEventListener('click', doImport);
  $('template-import-pick')?.addEventListener('click', () => $('template-file-input')?.click());

  // File input
  $('template-file-input')?.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    readTemplateFile(f);
    e.target.value = '';
  });

  // Hide "after/before" selectors when not needed
  $('tpl-module-position')?.addEventListener('change', () => {
    const val = $('tpl-module-position').value;
    const needsRef = (val === 'after' || val === 'before');
    $('tpl-module-after').disabled = !needsRef;
  });
  $('tpl-moment-position')?.addEventListener('change', () => {
    const val = $('tpl-moment-position').value;
    const needsRef = (val === 'after' || val === 'before');
    $('tpl-moment-after').disabled = !needsRef;
  });
  $('tpl-act-position')?.addEventListener('change', () => {
    const val = $('tpl-act-position').value;
    const needsRef = (val === 'after' || val === 'before');
    $('tpl-act-after').disabled = !needsRef;
  });
}


  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bind, { once: true });
  } else {
    bind();
  }
})();




// ---- Unit labels override ----
// Target duration unit dropdowns: full words. Designed durations: abbreviated.
function __ldGetUnitLabelByKey(unitKey, format) {
    const k = (unitKey || 'mins').toString();
    const shortMap = { mins: 'min', hours: 'h', days: 'j', weeks: 'sem', months: 'mois' };
    const longMap  = { mins: 'Minutes', hours: 'Heures', days: 'Jours', weeks: 'Semaines', months: 'Mois' };
    return (format === 'long') ? (longMap[k] || longMap.mins) : (shortMap[k] || shortMap.mins);
}
function __ldGetUnitLabelBySecs(unitSecs, format) {
    const s = parseFloat(unitSecs) || 60;
    if (s === 60) return __ldGetUnitLabelByKey('mins', format);
    if (s === 3600) return __ldGetUnitLabelByKey('hours', format);
    if (s === 86400) return __ldGetUnitLabelByKey('days', format);
    if (s === 604800) return __ldGetUnitLabelByKey('weeks', format);
    if (s === 2592000) return __ldGetUnitLabelByKey('months', format);
    return __ldGetUnitLabelByKey('mins', format);
}
function __ldApplyUnitLabelFormat() {
    try {
        // Course target (key-based): long
        const globalSel = document.getElementById('param-learning-unit');
        if (globalSel) {
            Array.from(globalSel.options || []).forEach(opt => {
                opt.textContent = __ldGetUnitLabelByKey(opt.value, 'long');
            });
        }
        // Keep hidden "designed time unit" selector aligned (used by exports/imports)
        const designedSel = document.getElementById('param-designed-unit');
        if (designedSel) {
            try {
                Array.from(designedSel.options || []).forEach(opt => {
                    opt.textContent = __ldGetUnitLabelByKey(opt.value, 'long');
                });
                if (globalSel && globalSel.value) designedSel.value = globalSel.value;
            } catch(_){ __ldSilentErr(_); }
        }

        // Preferred unit selector: long
        const prefSel = document.getElementById('param-preferred-unit');
        if (prefSel) {
            Array.from(prefSel.options || []).forEach(opt => {
                opt.textContent = __ldGetUnitLabelBySecs(opt.value, 'long');
            });
        }
        // Target unit selects (seconds-based): long
        document.querySelectorAll('.activity-target-unit, .moment-target-unit').forEach(sel => {
            Array.from(sel.options || []).forEach(opt => {
                const secs = parseFloat(opt.value);
                if (!isNaN(secs)) opt.textContent = __ldGetUnitLabelBySecs(secs, 'long');
            });
        });
        // Designed duration unit selects (steps): short
        document.querySelectorAll('.duration-unit').forEach(sel => {
            Array.from(sel.options || []).forEach(opt => {
                const secs = parseFloat(opt.value);
                if (!isNaN(secs)) opt.textContent = __ldGetUnitLabelBySecs(secs, 'short');
            });
        });
        try { updateStats(); } catch(_){ __ldSilentErr(_); }
    } catch(_){ __ldSilentErr(_); }
}
document.addEventListener('DOMContentLoaded', () => { try { __ldApplyUnitLabelFormat(); } catch(_){ __ldSilentErr(_); } });




// ---- Step duration unit conversion (preserve seconds) ----
// Allows user to change the unit per activity step without changing the underlying duration (in seconds).
function __ldConvertNumberPreserveSecs(valStr, fromSecs, toSecs) {
  const v = parseFloat(valStr);
  if (isNaN(v)) return '';
  const secs = v * (fromSecs || 60);
  let out = secs / (toSecs || 60);
  if ((toSecs || 60) === 60) out = Math.round(out);
  else out = parseFloat(out.toFixed(2));
  return (typeof __ldTrimNumber === 'function') ? __ldTrimNumber(out) : String(out);
}
function __ldInitDurationUnitSelect(sel) {
  try {
    if (!sel) return;
    sel.disabled = false;
    sel.dataset.prevSecs = String(parseFloat(sel.value) || 60);
  } catch(_){ __ldSilentErr(_); }
}
document.addEventListener('change', (e) => {
  const t = e.target;
  if (!t || !t.classList || !t.classList.contains('duration-unit')) return;

  try {
    const stepEl = t.closest('.step-card');
    const input = stepEl ? stepEl.querySelector('.duration-input') : null;

    const oldSecs = parseFloat(t.dataset.prevSecs || t.value || 60) || 60;
    const newSecs = parseFloat(t.value || 60) || 60;

    if (input && input.value !== '' && oldSecs > 0 && newSecs > 0) {
      input.value = __ldConvertNumberPreserveSecs(input.value, oldSecs, newSecs);
    }
    t.dataset.prevSecs = String(newSecs);
  } catch(_){ __ldSilentErr(_); }

  try { updateStats(); } catch(_){ __ldSilentErr(_); }
}, true);

document.addEventListener('DOMContentLoaded', () => {
  try { document.querySelectorAll('.duration-unit').forEach(__ldInitDurationUnitSelect); } catch(_){ __ldSilentErr(_); }
});




// ---- Guard interactions for duration unit dropdowns ----
// Prevent drag/toggle handlers from hijacking native select interactions inside step headers.
(function(){
  const guard = (e) => {
    const t = e.target;
    if (!t) return;
    if (t.matches && t.matches('select.duration-unit')) {
      try { e.stopPropagation(); } catch(_){ __ldSilentErr(_); }
      try { e.stopImmediatePropagation(); } catch(_){ __ldSilentErr(_); }
    }
  };
  document.addEventListener('pointerdown', guard, true);
  document.addEventListener('mousedown', guard, true);
  document.addEventListener('click', guard, true);
})();




// Init duration-unit selects for dynamically added steps
(function(){
  try {
    const root = document.getElementById('activities-root') || document.body;
    const obs = new MutationObserver((muts) => {
      muts.forEach(m => {
        (m.addedNodes || []).forEach(n => {
          if (!n || n.nodeType !== 1) return;
          try {
            if (n.matches && n.matches('select.duration-unit')) __ldInitDurationUnitSelect(n);
            if (n.querySelectorAll) n.querySelectorAll('select.duration-unit').forEach(__ldInitDurationUnitSelect);
          } catch(_){ __ldSilentErr(_); }
        });
      });
    });
    obs.observe(root, { childList: true, subtree: true });
  } catch(_){ __ldSilentErr(_); }
})();

</script>
<div id="js-error-banner" style="display:none; position:fixed; bottom:12px; left:12px; right:12px; z-index:9999; background:#fee2e2; color:#7f1d1d; padding:8px 10px; border:1px solid #fecaca; border-radius:10px; font-size:12px; line-height:1.2; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; box-shadow:0 10px 30px rgba(15,23,42,0.15);">
<div style="display:flex; gap:10px; align-items:flex-start;">
<div style="flex:1;">
<div style="font-weight:700; margin-bottom:3px;">
      Erreur
     </div>
<div data-js-error-text="">
      Une erreur est survenue.
     </div>
</div>
<button aria-label="Fermer" data-action="hide-js-error-banner" style="background:transparent; border:0; color:#7f1d1d; font-weight:700; cursor:pointer; padding:0 6px; line-height:1;" type="button">
     ×
    </button>
</div>


<!-- Diagnostic UI panel -->
<div id="ui-debug-panel" class="hidden fixed bottom-16 right-4 w-[440px] max-w-[calc(100vw-2rem)] bg-white border border-slate-200 rounded-2xl shadow-2xl z-[9998] no-print">
  <div class="flex items-center justify-between px-3 py-2 border-b border-slate-200">
    <div class="text-sm font-semibold text-slate-800">Diagnostic UI</div>
    <div class="flex items-center gap-2">
      <button class="text-xs font-semibold px-2 py-1 rounded bg-slate-50 hover:bg-slate-100 border border-slate-200" data-action="copy-debug-report" data-i18n="btn_copy_report">Copier rapport</button>
      <button class="text-xs font-semibold px-2 py-1 rounded bg-slate-50 hover:bg-slate-100 border border-slate-200" data-action="download-debug-report" data-i18n="btn_download">Télécharger</button>
      <button class="text-xs font-semibold px-2 py-1 rounded bg-slate-50 hover:bg-slate-100 border border-slate-200" data-action="clear-debug-log" data-i18n="btn_clear">Effacer</button>
      <button class="text-slate-500 hover:text-slate-800 px-2 py-1 rounded" data-action="toggle-debug-ui" type="button">✕</button>
    </div>
  </div>
  <div class="px-3 py-2 text-[11px] text-slate-600 flex items-center gap-4 border-b border-slate-200">
    <div><span class="font-bold">Actions:</span> <span id="ui-debug-actions-count">0</span></div>
    <div><span class="font-bold">Erreurs:</span> <span id="ui-debug-errors-count">0</span></div>
    <div class="ml-auto text-[10px] text-slate-400">Survol: affiche data-action · Raccourcis: Ctrl+Alt+D/C/S</div>
  </div>
  <div class="grid grid-cols-1 md:grid-cols-2 gap-2 p-3">
    <div class="border border-slate-200 rounded-xl p-2 bg-slate-50">
      <div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-1">Dernières actions</div>
      <div id="ui-debug-actions" class="max-h-44 overflow-auto text-[11px] font-mono text-slate-700"></div>
    </div>
    <div class="border border-slate-200 rounded-xl p-2 bg-slate-50">
      <div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-1">Dernières erreurs</div>
      <div id="ui-debug-errors" class="max-h-44 overflow-auto text-[11px] font-mono text-slate-700"></div>
    </div>
  </div>
</div>
<div id="ui-debug-hover" class="hidden fixed z-[9999] pointer-events-none px-2 py-1 rounded-lg bg-white text-slate-900 border border-slate-200 text-[11px] font-mono shadow-lg"></div>
</div>
<!-- i18n : Outil de vérification des traductions -->
<div class="hidden fixed inset-0 z-[9999] bg-black/50 flex items-center justify-center p-4 no-print" data-display="flex" id="i18n-audit-modal">
<div class="bg-white w-full max-w-3xl rounded-xl shadow-xl border border-slate-200 overflow-hidden">
<div class="flex items-center justify-between px-4 py-3 border-b border-slate-200">
<div>
<div class="text-sm font-semibold text-slate-800" data-i18n="i18n_audit_title">Vérification des traductions</div>
<div class="text-xs text-slate-500" data-i18n="i18n_audit_subtitle">Détecte les clés manquantes dans le pack chargé et les textes statiques non couverts par data-i18n.</div>
</div>
<button class="text-slate-500 hover:text-slate-800 px-2 py-1 rounded" data-action="close-i18n-audit" type="button">✕</button>
</div>
<div class="p-4 space-y-4">
<div class="grid grid-cols-2 md:grid-cols-4 gap-2">
<div class="border border-slate-200 rounded-lg p-2">
<div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider" data-i18n="i18n_audit_used_label">Clés UI</div>
<div class="text-lg font-semibold text-slate-800" id="i18n-audit-used">0</div>
</div>
<div class="border border-slate-200 rounded-lg p-2">
<div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider" data-i18n="i18n_audit_missing_pack_label">Manquantes (pack)</div>
<div class="text-lg font-semibold text-slate-800" id="i18n-audit-missing-pack-count">0</div>
</div>
<div class="border border-slate-200 rounded-lg p-2">
<div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider" data-i18n="i18n_audit_missing_fr_label">Clés inconnues (FR)</div>
<div class="text-lg font-semibold text-slate-800" id="i18n-audit-missing-fr-count">0</div>
</div>
<div class="border border-slate-200 rounded-lg p-2">
<div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider" data-i18n="i18n_audit_uncovered_label">Textes non couverts</div>
<div class="text-lg font-semibold text-slate-800" id="i18n-audit-uncovered-count">0</div>
</div>
</div>
<div class="space-y-2">
<details class="border border-slate-200 rounded-lg p-3" open="">
<summary class="cursor-pointer text-sm font-semibold text-slate-800" data-i18n="i18n_audit_section_missing_pack">Clés utilisées mais absentes du pack chargé (fallback FR)</summary>
<pre class="mt-2 text-xs bg-slate-50 border border-slate-200 rounded-md p-2 overflow-auto max-h-44" id="i18n-audit-missing-pack">—</pre>
</details>
<details class="border border-slate-200 rounded-lg p-3">
<summary class="cursor-pointer text-sm font-semibold text-slate-800" data-i18n="i18n_audit_section_missing_fr">Clés utilisées mais absentes du FR (à corriger dans le code)</summary>
<pre class="mt-2 text-xs bg-slate-50 border border-slate-200 rounded-md p-2 overflow-auto max-h-44" id="i18n-audit-missing-fr">—</pre>
</details>
<details class="border border-slate-200 rounded-lg p-3">
<summary class="cursor-pointer text-sm font-semibold text-slate-800" data-i18n="i18n_audit_section_uncovered">Éléments visibles avec texte statique sans data-i18n (échantillon)</summary>
<pre class="mt-2 text-xs bg-slate-50 border border-slate-200 rounded-md p-2 overflow-auto max-h-52" id="i18n-audit-uncovered">—</pre>
</details>
</div>
<div class="flex items-center justify-end gap-2 pt-2">
<button class="px-3 py-1.5 rounded-md border border-slate-300 text-sm text-slate-700 hover:bg-slate-50" data-i18n="btn_refresh" data-action="run-i18n-audit" type="button">Rafraîchir</button>
<button class="px-3 py-1.5 rounded-md border border-slate-300 text-sm text-slate-700 hover:bg-slate-50" data-i18n="btn_download_report" data-action="download-i18n-audit-report" type="button">Télécharger rapport</button>
<button class="px-3 py-1.5 rounded-md bg-indigo-600 text-white text-sm hover:bg-indigo-700" data-i18n="btn_close" data-action="close-i18n-audit" type="button">Fermer</button>
</div>
</div>
</div>
</div>
<!-- Modèles : Export / Import (DOM réel) -->
<div class="hidden fixed inset-0 z-[9999] bg-black/50 flex items-center justify-center p-4 no-print" data-display="flex" id="template-export-modal">
<div class="bg-white w-full max-w-xl rounded-xl shadow-xl border border-slate-200 overflow-hidden">
<div class="flex items-center justify-between px-4 py-3 border-b border-slate-200">
<div>
<div class="text-sm font-semibold text-slate-800">Exporter un modèle</div>
<div class="text-xs text-slate-500">Choisissez précisément l’élément à exporter.</div>
</div>
<button class="text-slate-500 hover:text-slate-800 px-2 py-1 rounded" id="template-export-close" type="button">✕</button>
</div>
<div class="p-4 space-y-4">
<div class="grid grid-cols-1 md:grid-cols-2 gap-3">
<div>
<label class="text-xs font-medium text-slate-700">Niveau</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="template-export-type">
<option value="module">Module</option>
<option value="moment">Moment</option>
<option value="activity">Activité</option>
</select>
</div>
<div>
<label class="text-xs font-medium text-slate-700">Élément</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="template-export-item"></select>
</div>
</div>
<div class="flex items-center justify-end gap-2 pt-2">
<button class="px-3 py-1.5 rounded-md border border-slate-300 text-sm text-slate-700 hover:bg-slate-50" id="template-export-cancel" type="button">Annuler</button>
<button class="px-3 py-1.5 rounded-md bg-indigo-600 text-white text-sm hover:bg-indigo-700" id="template-export-do" type="button">Exporter</button>
</div>
<div class="hidden text-sm text-red-600" id="template-export-error"></div>
</div>
</div>
</div>
<!-- Modèles : Import -->
<div class="hidden fixed inset-0 z-[9999] bg-black/50 flex items-center justify-center p-4 no-print" data-display="flex" id="template-import-modal">
<div class="bg-white w-full max-w-2xl rounded-xl shadow-xl border border-slate-200 overflow-hidden">
<div class="flex items-center justify-between px-4 py-3 border-b border-slate-200">
<div>
<div class="text-sm font-semibold text-slate-800">Importer un modèle</div>
<div class="text-xs text-slate-500">Choisissez précisément où insérer le modèle.</div>
</div>
<button class="text-slate-500 hover:text-slate-800 px-2 py-1 rounded" id="template-import-close" type="button">✕</button>
</div>
<div class="p-4 space-y-4">
<div class="flex items-center gap-2">
<button class="px-3 py-1.5 rounded-md bg-indigo-600 text-white text-sm hover:bg-indigo-700" id="template-import-pick" type="button">Choisir un fichier…</button>
<div class="text-sm text-slate-600 truncate" id="template-import-filelabel"></div>
</div>
<div class="hidden space-y-3" id="template-import-placements">
<div class="text-xs text-slate-500">Type détecté : <span class="font-semibold text-slate-700" id="template-import-type"></span></div>
<!-- Placement module -->
<div class="hidden border border-slate-200 rounded-lg p-3" id="tpl-place-module">
<div class="grid grid-cols-1 md:grid-cols-2 gap-3">
<div>
<label class="text-xs font-medium text-slate-700">Position</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-module-position">
<option value="start">Au début</option>
<option value="end">À la fin</option>
<option value="before">Avant…</option>
<option value="after">Après…</option>
</select>
</div>
<div>
<label class="text-xs font-medium text-slate-700">Module de référence</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-module-after"></select>
</div>
</div>
</div>
<!-- Placement moment -->
<div class="hidden border border-slate-200 rounded-lg p-3" id="tpl-place-moment">
<div class="grid grid-cols-1 md:grid-cols-3 gap-3">
<div>
<label class="text-xs font-medium text-slate-700">Module cible</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-moment-module"></select>
</div>
<div>
<label class="text-xs font-medium text-slate-700">Position</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-moment-position">
<option value="start">Au début</option>
<option value="end">À la fin</option>
<option value="before">Avant…</option>
<option value="after">Après…</option>
</select>
</div>
<div>
<label class="text-xs font-medium text-slate-700">Moment de référence</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-moment-after"></select>
</div>
</div>
</div>
<!-- Placement activité -->
<div class="hidden border border-slate-200 rounded-lg p-3" id="tpl-place-activity">
<div class="grid grid-cols-1 md:grid-cols-4 gap-3">
<div>
<label class="text-xs font-medium text-slate-700">Module cible</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-act-module"></select>
</div>
<div>
<label class="text-xs font-medium text-slate-700">Moment cible</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-act-moment"></select>
</div>
<div>
<label class="text-xs font-medium text-slate-700">Position</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-act-position">
<option value="start">Au début</option>
<option value="end">À la fin</option>
<option value="before">Avant…</option>
<option value="after">Après…</option>
</select>
</div>
<div>
<label class="text-xs font-medium text-slate-700">Activité de référence</label>
<select class="mt-1 w-full border border-slate-300 rounded-md px-2 py-1.5 text-sm" id="tpl-act-after"></select>
</div>
</div>
</div>
<div class="flex items-center justify-end gap-2 pt-2">
<button class="px-3 py-1.5 rounded-md border border-slate-300 text-sm text-slate-700 hover:bg-slate-50" id="template-import-cancel" type="button">Annuler</button>
<button class="px-3 py-1.5 rounded-md bg-indigo-600 text-white text-sm hover:bg-indigo-700" id="template-import-do" type="button">Importer</button>
</div>
</div>
<div class="hidden text-sm text-red-600" id="template-import-error"></div>
</div>
</div>
</div>
<!-- Fin Modèles (DOM réel) -->
<script>
// Key parameters wizard (Option 6) — minimal, self-contained, defensive.
(function(){
  function initKeyParamsWizard(){
    const bar = document.getElementById('kpwiz-bar');
    const wrapper = document.getElementById('kpwiz-steps-wrapper');
    if(!bar || !wrapper) return;

    const stepNums = Array.from(bar.querySelectorAll("[data-kpwiz-step]"))
      .map(b => parseInt(b.getAttribute("data-kpwiz-step"), 10))
      .filter(n => Number.isFinite(n))
      .sort((a,b)=>a-b);

    const steps = stepNums
      .map(n => {
        const el = document.getElementById("kpwiz-step-" + n) || wrapper.querySelector("#kpwiz-step-" + n);
        return el ? { el, n } : null;
      })
      .filter(Boolean);

    if(!steps.length) return;

    let current = 1;
    let showAll = false;

    function setActiveBtn(n){
      const btns = bar.querySelectorAll('[data-kpwiz-step]');
      btns.forEach(b => {
        const bn = parseInt(b.getAttribute('data-kpwiz-step'), 10);
        const active = bn === n;
        b.setAttribute('aria-current', active ? 'step' : 'false');
        b.classList.toggle('bg-indigo-100', active);
        b.classList.toggle('text-indigo-700', active);
        b.classList.toggle('border-indigo-200', active);
        b.classList.toggle('bg-slate-50', !active);
        b.classList.toggle('text-slate-700', !active);
        b.classList.toggle('border-slate-200', !active);
      });
    }

    function render(){
      if(showAll){
        steps.forEach(x => x.el.classList.remove('hidden'));
        setActiveBtn(current);
        const btn = bar.querySelector('[data-kpwiz-action="showall"]');
        if(btn) btn.textContent = 'Tout replier';
        return;
      }
      steps.forEach(x => {
        if(x.n === current) x.el.classList.remove('hidden');
        else x.el.classList.add('hidden');
      });
      setActiveBtn(current);
      const btn = bar.querySelector('[data-kpwiz-action="showall"]');
      if(btn) btn.textContent = 'Tout afficher';
    }

    function setStep(n){
      const max = steps[steps.length-1].n;
      const nn = Math.max(1, Math.min(max, n));
      current = nn;
      render();
    }

    function toggleShowAll(){
      showAll = !showAll;
      render();
    }

    // Click delegation (keeps event surface small)
    bar.addEventListener('click', function(e){
      const t = e.target.closest('[data-kpwiz-step],[data-kpwiz-action]');
      if(!t) return;
      const stepAttr = t.getAttribute('data-kpwiz-step');
      if(stepAttr){
        e.preventDefault();
        showAll = false;
        setStep(parseInt(stepAttr, 10) || 1);
        return;
      }
      const act = t.getAttribute('data-kpwiz-action');
      if(!act) return;
      e.preventDefault();
      if(act === 'prev') setStep(current - 1);
      else if(act === 'next') setStep(current + 1);
      else if(act === 'showall') toggleShowAll();
    }, { passive: false });

    // Initialise
    current = 1;
    showAll = false;
    render();
  }

  document.addEventListener('DOMContentLoaded', function(){
    try{ initKeyParamsWizard(); }catch(e){ console.error('KeyParams wizard init failed', e); }
  }, { once:true });
})();


        // --- UI v10: Chips de synthèse (activité) + filtres Outils & matériel ---
        function __countSelectedFromMultiSelect(sel) {
            if (!sel) return 0;
            try {
                return Array.from(sel.selectedOptions || [])
                    .map(o => String(o.value || '').trim())
                    .filter(Boolean).length;
            } catch (_) { return 0; }
        }

        function updateStepHeaderChips(stepEl) {
            if (!stepEl) return;

            const evalSel = stepEl.querySelector('select.evaluation-select');
            const aimsSel = stepEl.querySelector('select.step-aims-select');
            const outSel  = stepEl.querySelector('select.step-outcomes-select');
            const tmSel   = stepEl.querySelector('select.step-tools-materials-select');

            const evalVal = evalSel ? String(evalSel.value || '').trim() : '';
            const aimsN = __countSelectedFromMultiSelect(aimsSel);
            const outN  = __countSelectedFromMultiSelect(outSel);
            const tmN   = __countSelectedFromMultiSelect(tmSel);

            let notesN = 0;
            try {
                if (typeof getSelectedStepToolsMaterialsNotes === 'function') {
                    const m = getSelectedStepToolsMaterialsNotes(stepEl) || {};
                    notesN = Object.keys(m).length;
                } else {
                    const m = __getStepToolMatNotesMap(stepEl) || {};
                    notesN = Object.keys(m).filter(k => String(m[k] || '').trim()).length;
                }
            } catch (_) { notesN = 0; }

            const chipEval = stepEl.querySelector('.step-chip-eval');
            const chipAims = stepEl.querySelector('.step-chip-aims');
            const chipOut  = stepEl.querySelector('.step-chip-outcomes');
            const chipTools = stepEl.querySelector('.step-chip-tools');
            const chipNotes = stepEl.querySelector('.step-chip-toolnotes');

            if (chipEval) chipEval.textContent = `Évaluation: ${evalVal || '—'}`;
            if (chipAims) chipAims.textContent = `Objectifs: ${aimsN}`;
            if (chipOut)  chipOut.textContent  = `Résultats: ${outN}`;
            if (chipTools) chipTools.textContent = `Outils: ${tmN}`;

            if (chipNotes) {
                chipNotes.textContent = `Notes outils: ${notesN}`;
                if (notesN > 0) chipNotes.classList.remove('hidden');
                else chipNotes.classList.add('hidden');
            }

            // Update the per-activity tools selected count label (next to the toggle)
            try {
                const lbl = stepEl.querySelector('.tm-selected-count');
                if (lbl) lbl.textContent = tmN ? `${tmN} sélectionné(s)` : '';
            } catch(_){ __ldSilentErr(_); }
        }

        function updateAllStepHeaderChips() {
            __ldFilterStepNodeList(__ldFilterStepNodeList(document.querySelectorAll('.step-card'))).forEach(stepEl => {
                try { updateStepHeaderChips(stepEl); } catch(_){ __ldSilentErr(_); }
            });
        }

        function __initStepToolsSelectedOnlyToggle(stepEl) {
            if (!stepEl) return;
            const tgl = stepEl.querySelector('input.tm-show-selected-toggle');
            if (!tgl) return;

            // restore state
            const st = (stepEl.dataset && stepEl.dataset.tmShowSelected) ? String(stepEl.dataset.tmShowSelected) : '';
            tgl.checked = (st === '1' || st === 'true');

            if (tgl.dataset && tgl.dataset.bound === '1') return;
            try { if (tgl.dataset) tgl.dataset.bound = '1'; } catch(_){ __ldSilentErr(_); }

            tgl.addEventListener('change', () => {
                try {
                    if (stepEl.dataset) stepEl.dataset.tmShowSelected = tgl.checked ? '1' : '';
                } catch(_){ __ldSilentErr(_); }
                try { applyStepToolsSelectedOnly(stepEl); } catch(_){ __ldSilentErr(_); }
                try { updateStepHeaderChips(stepEl); } catch(_){ __ldSilentErr(_); }
            });
        }

        function applyStepToolsSelectedOnly(stepEl) {
            if (!stepEl) return;
            const tgl = stepEl.querySelector('input.tm-show-selected-toggle');
            const showSelectedOnly = !!(tgl && tgl.checked);

            const rows = stepEl.querySelectorAll('.step-tools-materials-checkboxes [data-tm-row="1"]');
            rows.forEach(row => {
                const cb = row.querySelector('input.step-toolmat-cb');
                const checked = !!(cb && cb.checked);
                if (showSelectedOnly && !checked) row.classList.add('hidden');
                else row.classList.remove('hidden');
            });

            // keep count label fresh
            try { updateStepHeaderChips(stepEl); } catch(_){ __ldSilentErr(_); }
        }

        function __tmGetListItems() {
            const list = document.getElementById('tools-materials-list');
            if (!list) return [];
            return Array.from(list.querySelectorAll('li[data-item]'));
        }

        function refreshToolsMaterialsFilterUI() {
            const search = document.getElementById('tools-materials-search');
            const catSel = document.getElementById('tools-materials-filter-cat');
            const subSel = document.getElementById('tools-materials-filter-subcat');
            if (!search || !catSel || !subSel) return;

            const items = __tmGetListItems();
            const cats = new Set();
            const subsByCat = new Map();

            items.forEach(li => {
                const c = String(li.getAttribute('data-cat') || '').trim();
                const s = String(li.getAttribute('data-subcat') || '').trim();
                if (c) cats.add(c);
                const key = c || '';
                if (!subsByCat.has(key)) subsByCat.set(key, new Set());
                if (s) subsByCat.get(key).add(s);
            });

            const prevCat = String(catSel.value || '');
            const prevSub = String(subSel.value || '');

            // Rebuild category options
            const catArr = Array.from(cats).sort((a,b) => a.localeCompare(b, 'fr'));
            catSel.innerHTML = '<option value="" data-i18n="opt_all_categories">Toutes</option>' + catArr.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');
            if (catArr.includes(prevCat)) catSel.value = prevCat;

            // Rebuild sub-category options based on selected category (or all)
            const selCat = String(catSel.value || '');
            const subSet = new Set();
            if (selCat) {
                (subsByCat.get(selCat) || new Set()).forEach(v => subSet.add(v));
            } else {
                // all subs
                subsByCat.forEach(set => set.forEach(v => subSet.add(v)));
            }
            const subArr = Array.from(subSet).sort((a,b) => a.localeCompare(b, 'fr'));
            subSel.innerHTML = '<option value="" data-i18n="opt_all_categories">Toutes</option>' + subArr.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join('');
            if (subArr.includes(prevSub)) subSel.value = prevSub;

            try { applyToolsMaterialsListFilters(); } catch(_){ __ldSilentErr(_); }
        }

        function applyToolsMaterialsListFilters() {
            const search = document.getElementById('tools-materials-search');
            const catSel = document.getElementById('tools-materials-filter-cat');
            const subSel = document.getElementById('tools-materials-filter-subcat');
            const countEl = document.getElementById('tools-materials-filter-count');
            const emptyEl = document.getElementById('tools-materials-filter-empty');
            if (!search || !catSel || !subSel) return;

            const q = String(search.value || '').trim().toLowerCase();
            const cat = String(catSel.value || '').trim();
            const sub = String(subSel.value || '').trim();

            const items = __tmGetListItems();
            let visible = 0;

            items.forEach(li => {
                const c = String(li.getAttribute('data-cat') || '').trim();
                const s = String(li.getAttribute('data-subcat') || '').trim();
                const it = String(li.getAttribute('data-item') || '').trim();

                let ok = true;
                if (cat && c !== cat) ok = false;
                if (ok && sub && s !== sub) ok = false;
                if (ok && q) {
                    const hay = (c + ' ' + s + ' ' + it).toLowerCase();
                    if (!hay.includes(q)) ok = false;
                }

                li.style.display = ok ? '' : 'none';
                if (ok) visible += 1;
            });

            const total = items.length;
            if (countEl) countEl.textContent = `${visible}/${total} affichés`;
            if (emptyEl) {
                if (total > 0 && visible === 0) emptyEl.classList.remove('hidden');
                else emptyEl.classList.add('hidden');
            }
        }

        function initToolsMaterialsFilters() {
            const search = document.getElementById('tools-materials-search');
            const catSel = document.getElementById('tools-materials-filter-cat');
            const subSel = document.getElementById('tools-materials-filter-subcat');
            const resetBtn = document.getElementById('tools-materials-filter-reset');
            if (!search || !catSel || !subSel || !resetBtn) return;

            if (search.dataset && search.dataset.bound === '1') return;
            try { if (search.dataset) search.dataset.bound = '1'; } catch(_){ __ldSilentErr(_); }

            search.addEventListener('input', () => { try { applyToolsMaterialsListFilters(); } catch(_){ __ldSilentErr(_); } });
            catSel.addEventListener('change', () => {
                try { refreshToolsMaterialsFilterUI(); } catch(_){ __ldSilentErr(_); }
            });
            subSel.addEventListener('change', () => { try { applyToolsMaterialsListFilters(); } catch(_){ __ldSilentErr(_); } });

            resetBtn.addEventListener('click', () => {
                search.value = '';
                catSel.value = '';
                subSel.value = '';
                try { refreshToolsMaterialsFilterUI(); } catch(_){ __ldSilentErr(_); }
            });

            // Observer to refresh options when list changes (add/remove/reorder)
            const list = document.getElementById('tools-materials-list');
            if (list) {
                try {
                    const obs = new MutationObserver(() => {
                        try { refreshToolsMaterialsFilterUI(); } catch(_){ __ldSilentErr(_); }
                    });
                    obs.observe(list, { childList: true, subtree: true });
                } catch(_){ __ldSilentErr(_); }
            }

            try { refreshToolsMaterialsFilterUI(); } catch(_){ __ldSilentErr(_); }
        }

        document.addEventListener('DOMContentLoaded', function(){
            try { initToolsMaterialsFilters(); } catch(_){ __ldSilentErr(_); }
            try { updateAllStepHeaderChips(); } catch(_){ __ldSilentErr(_); }
        });


/* === Jump to… (Modules / Activités) ===================================== */
(function(){
  let __jumpIndex = new Map();
  let __jumpTimer = null;

  function ensureJumpKey(el, prefix){
    try {
      if (!el || !el.dataset) return '';
      if (!el.dataset.jumpKey) el.dataset.jumpKey = String(prefix || 'k') + '-' + Math.random().toString(16).slice(2);
      return el.dataset.jumpKey;
    } catch (_) { return ''; }
  }

  function getLabelForModule(modEl, idx){
    const t = modEl ? modEl.querySelector('input.activity-title') : null;
    const v = t ? String(t.value || '').trim() : '';
    return v ? v : ('Module ' + (idx + 1));
  }

  function getLabelForStep(stepEl, idx){
    const t = stepEl ? stepEl.querySelector('input.step-input-title') : null;
    const v = t ? String(t.value || '').trim() : '';
    return v ? v : ('Activité ' + (idx + 1));
  }

  function refreshJumpToOptions(preserve){
    const sel = document.getElementById('jump-to-select');
    const root = document.getElementById('activities-root');
    if (!sel || !root) return;

    const prev = preserve ? sel.value : '';
    __jumpIndex = new Map();

    // reset
    while (sel.firstChild) sel.removeChild(sel.firstChild);
    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = 'Aller à…';
    sel.appendChild(opt0);

    const modules = Array.from(root.querySelectorAll(':scope > .activity-group'));
    modules.forEach(function(modEl, mi){
      const modKey = ensureJumpKey(modEl, 'mod');
      const modLabel = getLabelForModule(modEl, mi);
      const opt = document.createElement('option');
      opt.value = modKey;
      opt.textContent = 'Module ' + (mi + 1) + ' — ' + modLabel;
      sel.appendChild(opt);
      __jumpIndex.set(modKey, { el: modEl, type: 'module' });

      const steps = Array.from(__ldFilterStepNodeList(modEl.querySelectorAll('.step-card')));
      steps.forEach(function(stepEl, si){
        const stepKey = ensureJumpKey(stepEl, 'act');
        const stepLabel = getLabelForStep(stepEl, si);
        const optS = document.createElement('option');
        optS.value = stepKey;
        optS.textContent = '↳ Activité ' + (si + 1) + ' — ' + stepLabel;
        sel.appendChild(optS);
        __jumpIndex.set(stepKey, { el: stepEl, type: 'step', moduleEl: modEl });
      });
    });

    if (prev && __jumpIndex.has(prev)) sel.value = prev;
  }

  function refreshJumpToOptionsDebounced(){
    if (__jumpTimer) clearTimeout(__jumpTimer);
    __jumpTimer = setTimeout(function(){
      try { refreshJumpToOptions(true); } catch(_){ __ldSilentErr(_); }
    }, 180);
  }

  function ensureModuleExpanded(modEl){
    try {
      if (!modEl) return;
      const body = modEl.querySelector('.activity-body');
      if (body && !body.classList.contains('open')) {
        const btn = modEl.querySelector('[data-action="toggle-module"]');
        if (btn) btn.click();
        else body.classList.add('open');
      }
    } catch(_){ __ldSilentErr(_); }
  }

  function openAncestorDetails(el){
    try {
      let lead = el;
      while (lead) {
        const det = (lead.closest ? lead.closest('details') : null);
        if (!det) break;
        det.open = true;
        lead = det.parentElement;
      }
    } catch(_){ __ldSilentErr(_); }
  }

  function highlightJumpTarget(el){
    try {
      if (!el) return;
      el.classList.add('ring-2','ring-indigo-300');
      setTimeout(function(){
        try { el.classList.remove('ring-2','ring-indigo-300'); } catch(_){ __ldSilentErr(_); }
      }, 1200);
    } catch(_){ __ldSilentErr(_); }
  }

  function jumpToSelection(){
    const sel = document.getElementById('jump-to-select');
    if (!sel) return;
    const key = sel.value;
    if (!key) return;

    const item = __jumpIndex.get(key);
    if (!item || !item.el) return;

    try {
      if (item.type === 'step') {
        const modEl = item.moduleEl || (item.el.closest ? item.el.closest('.activity-group') : null);
        ensureModuleExpanded(modEl);
        openAncestorDetails(item.el);
      } else if (item.type === 'module') {
        ensureModuleExpanded(item.el);
      }

      item.el.scrollIntoView({ behavior: 'smooth', block: 'start' });
      highlightJumpTarget(item.el);
    } catch(_){ __ldSilentErr(_); }
  }

  function initJumpToNavigator(){
    const sel = document.getElementById('jump-to-select');
    const btn = document.getElementById('jump-to-refresh');
    const root = document.getElementById('activities-root');
    if (!sel || !root) return;

    refreshJumpToOptions(false);

    sel.addEventListener('change', function(){ jumpToSelection(); });
    if (btn) btn.addEventListener('click', function(){ refreshJumpToOptions(true); });

    // Observe add/remove/reorder of modules/steps
    try {
      const obs = new MutationObserver(function(){ refreshJumpToOptionsDebounced(); });
      obs.observe(root, { childList: true, subtree: true });
    } catch(_){ __ldSilentErr(_); }

    // Update labels when titles change
    document.addEventListener('input', function(e){
      const t = e.target;
      if (!t || !t.classList) return;
      if (t.classList.contains('activity-title') || t.classList.contains('step-input-title')) {
        refreshJumpToOptionsDebounced();
      }
    }, true);
  }

  document.addEventListener('DOMContentLoaded', function(){
    try { initJumpToNavigator(); } catch(_){ __ldSilentErr(_); }
  });
})();



/* ===========================
   v12 – Productivité & Exports
   - Duplication d’activité (options)
   =========================== */

(function(){
  'use strict';

  function __qs(sel, root){ return (root || document).querySelector(sel); }
  function __qsa(sel, root){ return Array.from((root || document).querySelectorAll(sel)); }
  function __isOpenModal(modal){ return !!(modal && !modal.classList.contains('hidden')); }

  function __asText(v){ return (v == null) ? '' : String(v); }
  function __trim(v){ return __asText(v).trim(); }
  function __has(v){ return __trim(v).length > 0; }
  function __safeList(arr){
    return (Array.isArray(arr) ? arr : []).map(v => __trim(v)).filter(Boolean);
  }
  function __oneLine(v){
    return __asText(v).replace(/\r\n|\r|\n/g, ' ').replace(/\s+/g,' ').trim();
  }

  function __escapeMd(s){
    // Minimal escaping for Markdown readability.
    const t = __asText(s);
    return t.replace(/[\\`*_{}[\]()#+\-.!|>]/g, '\\$&');
  }

  function __escapeHtml2(s){
    const t = __asText(s);
    return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  }

  // -------------------------
  // Duplication d’activité (options)
  // -------------------------
  function __ensureDuplicateStepMenu(){
    let menu = __qs('#duplicate-step-menu');
    if (menu) return menu;

    menu = document.createElement('div');
    menu.id = 'duplicate-step-menu';
    menu.className = 'fixed z-[120] hidden bg-white border border-slate-200 rounded-lg shadow-lg p-1 w-[240px]';
    menu.innerHTML = `
      <div class="text-[11px] font-bold text-slate-600 uppercase tracking-wider px-2 py-1">Dupliquer</div>
      <button type="button" class="w-full text-left px-2 py-1.5 text-xs rounded hover:bg-slate-100" data-mode="all">Dupliquer tout</button>
      <button type="button" class="w-full text-left px-2 py-1.5 text-xs rounded hover:bg-slate-100" data-mode="no-align">Sans alignement</button>
      <button type="button" class="w-full text-left px-2 py-1.5 text-xs rounded hover:bg-slate-100" data-mode="no-tools">Sans outils & matériel</button>
      <button type="button" class="w-full text-left px-2 py-1.5 text-xs rounded hover:bg-slate-100" data-mode="skeleton">Squelette (contenu vidé)</button>
    `;
    document.body.appendChild(menu);

    // Close on outside click
    document.addEventListener('click', function(e){
      try {
        if (menu.classList.contains('hidden')) return;
        const inside = e.target && (e.target === menu || (e.target.closest && e.target.closest('#duplicate-step-menu')));
        const onBtn = e.target && e.target.closest && e.target.closest('[data-action="duplicate-step"]');
        if (inside || onBtn) return;
        menu.classList.add('hidden');
      } catch(_){ __ldSilentErr(_); }
    }, true);

    // Choose mode
    menu.addEventListener('click', function(e){
      const btn = e.target && e.target.closest ? e.target.closest('button[data-mode]') : null;
      if (!btn) return;
      const mode = btn.getAttribute('data-mode') || 'all';
      const srcBtn = menu.__sourceBtn;
      menu.classList.add('hidden');
      menu.__sourceBtn = null;
      try { window.cloneStepWithOptions(srcBtn, mode); } catch(err){ try { window.reportError(err, { action: 'duplicate-step-option' }); } catch(_){ __ldSilentErr(_); } }
    });

    return menu;
  }

  window.openDuplicateStepMenu = function(btn, event){
    try { event && event.preventDefault && event.preventDefault(); } catch(_){ __ldSilentErr(_); }
    const menu = __ensureDuplicateStepMenu();
    if (!menu || !btn) return;

    menu.__sourceBtn = btn;

    const r = btn.getBoundingClientRect();
    const x = Math.min(window.innerWidth - 260, Math.max(8, r.right - 240));
    const y = Math.min(window.innerHeight - 220, Math.max(8, r.bottom + 6));
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    menu.classList.remove('hidden');
  };

  window.cloneStepWithOptions = function(btn, mode){
    if (!btn) return;
    if (typeof historyCaptureNow === 'function') { try { historyCaptureNow(); } catch(_){ __ldSilentErr(_); } }

    const original = btn.closest('.step-card');
    if (!original) return;
    const clone = original.cloneNode(true);
    original.after(clone);
    try { copyFormValues(original, clone); } catch(_){ __ldSilentErr(_); }

    // Ensure unique IDs/render for checkbox lists by re-populating selects
    try { populateStepCompetencesSelect(clone, (typeof getSelectedStepCompetenceIds === 'function') ? getSelectedStepCompetenceIds(clone) : []); } catch(_){ __ldSilentErr(_); }
    try { populateStepCompetencesTransversalesSelect(clone, (typeof getSelectedStepCompetencesTransversalesIds === 'function') ? getSelectedStepCompetencesTransversalesIds(clone) : []); } catch(_){ __ldSilentErr(_); }
    try { populateStepAimsSelect(clone, (typeof getSelectedStepAims === 'function') ? getSelectedStepAims(clone) : []); } catch(_){ __ldSilentErr(_); }
    try { populateStepOutcomesSelect(clone, (typeof getSelectedStepOutcomes === 'function') ? getSelectedStepOutcomes(clone) : []); } catch(_){ __ldSilentErr(_); }
    try { populateStepToolsMaterialsSelect(clone, (typeof getSelectedStepToolsMaterials === 'function') ? getSelectedStepToolsMaterials(clone) : []); } catch(_){ __ldSilentErr(_); }

    // Apply mode rules
    const m = __trim(mode || 'all');

    function clearMultiSelect(className, popFn){
      try {
        const sel = clone.querySelector(className);
        if (sel) Array.from(sel.options || []).forEach(o => o.selected = false);
      } catch(_){ __ldSilentErr(_); }
      try { popFn && popFn(); } catch(_){ __ldSilentErr(_); }
    }

    if (m === 'no-align' || m === 'skeleton') {
      try { clearMultiSelect('.step-competences-select', () => populateStepCompetencesSelect(clone, [])); } catch(_){ __ldSilentErr(_); }
      try { clearMultiSelect('.step-competences-transversales-select', () => populateStepCompetencesTransversalesSelect(clone, [])); } catch(_){ __ldSilentErr(_); }
      try { clearMultiSelect('.step-aims-select', () => populateStepAimsSelect(clone, [])); } catch(_){ __ldSilentErr(_); }
      try { clearMultiSelect('.step-outcomes-select', () => populateStepOutcomesSelect(clone, [])); } catch(_){ __ldSilentErr(_); }
    }

    if (m === 'no-tools' || m === 'skeleton') {
      try {
        clone.dataset.tmNotes = '{}';
      } catch(_){ __ldSilentErr(_); }
      try { clearMultiSelect('.step-tools-materials-select', () => populateStepToolsMaterialsSelect(clone, [])); } catch(_){ __ldSilentErr(_); }
    }

    if (m === 'skeleton') {
      // Clear pedagogical content; keep logistics (grouping, time, evaluation, duration)
      try { const t = clone.querySelector('.step-input-objective'); if (t) t.value = ''; } catch(_){ __ldSilentErr(_); }
      try { const t = clone.querySelector('.step-input-tasks'); if (t) t.value = ''; } catch(_){ __ldSilentErr(_); }
      try { const t = clone.querySelector('.step-input-trainer-tasks'); if (t) t.value = ''; } catch(_){ __ldSilentErr(_); }
      try { const t = clone.querySelector('.step-input-notes'); if (t) t.value = ''; } catch(_){ __ldSilentErr(_); }
    }

    // Visual cue in title (non-destructive)
    try {
      const title = clone.querySelector('.step-input-title');
      if (title && title.value && !/\(copie\)\s*$/i.test(title.value)) title.value = title.value + ' (copie)';
    } catch(_){ __ldSilentErr(_); }

    // Reapply type UI + stats
    try { const select = clone.querySelector('.learning-type-select'); if (select) updateStepType(select); } catch(_){ __ldSilentErr(_); }
    try { if (typeof updateStats === 'function') updateStats(); } catch(_){ __ldSilentErr(_); }

    // Refresh jump-to if available
    try { if (typeof refreshJumpToOptionsDebounced === 'function') refreshJumpToOptionsDebounced(); } catch(_){ __ldSilentErr(_); }
  };

})();





/* =========================================================
   Contextual Side Panel + Global Search
   ========================================================= */
(function(){
  // Contextual Side Panel + Global Search
  // ------------------------------
  let __ctxSelectedStep = null;
  let __ctxPanelPinned = false;
  let __ctxSearchIndex = null;
  let __ctxSearchHits = [];

  function __ctxQ(sel, root){ try { return (root || document).querySelector(sel); } catch(_) { return null; } }
  function __ctxQA(sel, root){ try { return Array.from((root || document).querySelectorAll(sel)); } catch(_) { return []; } }

  function __ctxGetText(v){ return (v == null) ? '' : String(v); }

  function __ctxSelectedOptions(selectEl){
    try {
      if (!selectEl) return [];
      return Array.from(selectEl.selectedOptions || [])
        .map(o => __ctxGetText(o.value || o.textContent || '').trim())
        .filter(Boolean);
    } catch(_) { return []; }
  }

  function __ctxGetTools(stepEl){
    try {
      const sel = __ctxQ('.step-tools-materials-select', stepEl);
      return __ctxSelectedOptions(sel);
    } catch(_) { return []; }
  }

  function __ctxGetToolNotesMap(stepEl){
    try {
      if (typeof __getStepToolMatNotesMap === 'function') return (__getStepToolMatNotesMap(stepEl) || {});
      const raw = (stepEl && stepEl.dataset) ? stepEl.dataset.tmNotes : '';
      return raw ? (JSON.parse(raw) || {}) : {};
    } catch(_) { return {}; }
  }

  function __ctxFindGroup(stepEl){
    try { return stepEl ? stepEl.closest('.activity-group') : null; } catch(_) { return null; }
  }

  function __ctxComputePath(stepEl){
    try {
      const group = __ctxFindGroup(stepEl);
      const modTitleEl = group ? __ctxQ('.activity-title', group) : null;
      const modTitle = __ctxGetText(modTitleEl ? modTitleEl.value : '').trim() || 'Module';
      const steps = group ? __ctxQA('.step-card', group) : [];
      const idx = steps.indexOf(stepEl);
      const stepNum = (idx >= 0) ? (idx + 1) : '';
      return modTitle + (stepNum ? (' — Activité ' + stepNum) : '');
    } catch(_) { return ''; }
  }

  function __ctxOpenPanel(){
    const panel = __ctxQ('#context-panel');
    const handle = __ctxQ('#context-panel-handle');
    if (panel) panel.classList.remove('hidden');
    if (panel) panel.classList.add('flex');
    if (handle) handle.classList.add('hidden');
  }

  function __ctxClosePanel(force){
    if (!force && __ctxPanelPinned) return;
    const panel = __ctxQ('#context-panel');
    const handle = __ctxQ('#context-panel-handle');
    if (panel) { panel.classList.add('hidden'); panel.classList.remove('flex'); }
    if (handle) handle.classList.remove('hidden');
  }

  function __ctxSetPinned(v){
    __ctxPanelPinned = !!v;
    const btn = __ctxQ('#context-panel-pin');
    if (btn) {
      btn.classList.toggle('bg-indigo-50', __ctxPanelPinned);
      btn.classList.toggle('text-indigo-700', __ctxPanelPinned);
      btn.classList.toggle('text-slate-600', !__ctxPanelPinned);
    }
  }

  function __ctxSelectStep(stepEl, opts){
    if (!stepEl) return;
    const prev = __ctxSelectedStep;
    if (prev && prev !== stepEl) {
      prev.classList.remove('ring-2','ring-indigo-400','ring-offset-1');
    }
    __ctxSelectedStep = stepEl;
    stepEl.classList.add('ring-2','ring-indigo-400','ring-offset-1');

    __ctxUpdatePanel(stepEl);
    if (!opts || opts.openPanel !== false) __ctxOpenPanel();
  }

  function __ctxUpdatePanel(stepEl){
    const pathEl = __ctxQ('#context-panel-path');
    const hintEl = __ctxQ('#ctx-hint');
    if (pathEl) pathEl.textContent = __ctxComputePath(stepEl);
    if (hintEl) hintEl.textContent = '';

    const titleSrc = __ctxQ('.step-input-title', stepEl);
    const durSrc = __ctxQ('.duration-input', stepEl);
    const durUnitSrc = __ctxQ('.duration-unit', stepEl);
    const evalSrc = __ctxQ('.evaluation-select', stepEl);
    const objSrc = __ctxQ('.step-input-objective', stepEl);

    const title = __ctxQ('#ctx-title');
    const dur = __ctxQ('#ctx-duration');
    const durUnit = __ctxQ('#ctx-duration-unit');
    const evalSel = __ctxQ('#ctx-evaluation');
    const obj = __ctxQ('#ctx-objective');

    if (title && titleSrc) title.value = titleSrc.value || '';
    if (dur && durSrc) dur.value = durSrc.value || '';
    if (durUnit && durUnitSrc) durUnit.value = durUnitSrc.value || '60';
    if (evalSel && evalSrc) evalSel.value = evalSrc.value || 'Aucune';
    if (obj && objSrc) obj.value = objSrc.value || '';

    // Alignement
    const alignBox = __ctxQ('#ctx-align');
    if (alignBox) {
      const comps = __ctxSelectedOptions(__ctxQ('.step-competences-select', stepEl));
      const compsT = __ctxSelectedOptions(__ctxQ('.step-competences-transversales-select', stepEl));
      const aims = __ctxSelectedOptions(__ctxQ('.step-aims-select', stepEl));
      const outs = __ctxSelectedOptions(__ctxQ('.step-outcomes-select', stepEl));
      const lines = [];
      if (comps.length) lines.push('<div class="text-xs"><span class="font-semibold">Compétences</span> : ' + comps.map(__ctxEsc).join(', ') + '</div>');
      if (compsT.length) lines.push('<div class="text-xs"><span class="font-semibold">Transversales</span> : ' + compsT.map(__ctxEsc).join(', ') + '</div>');
      if (aims.length) lines.push('<div class="text-xs"><span class="font-semibold">Objectifs</span> : ' + aims.map(__ctxEsc).join(', ') + '</div>');
      if (outs.length) lines.push('<div class="text-xs"><span class="font-semibold">Résultats</span> : ' + outs.map(__ctxEsc).join(', ') + '</div>');
      alignBox.innerHTML = lines.length ? lines.join('') : '<div class="text-xs text-slate-500">Aucun élément sélectionné.</div>';
    }

    // Tools + notes
    const toolsBox = __ctxQ('#ctx-tools');
    if (toolsBox) {
      const tools = __ctxGetTools(stepEl);
      const notes = __ctxGetToolNotesMap(stepEl);
      if (!tools.length) {
        toolsBox.innerHTML = '<div class="text-xs text-slate-500">Aucun outil/matériel sélectionné.</div>';
      } else {
        const html = tools.map(t => {
          const n = (notes && Object.prototype.hasOwnProperty.call(notes, t)) ? __ctxGetText(notes[t]).trim() : '';
          const notePreview = n ? ('<div class="text-[11px] text-slate-600 mt-0.5 whitespace-pre-wrap">' + __ctxEsc(n) + '</div>') : '<div class="text-[11px] text-slate-400 mt-0.5 italic">Aucune remarque</div>';
          return (
            '<button type="button" class="w-full text-left rounded-lg border border-slate-200 p-2 hover:bg-slate-50" data-ctx-tool="' + __ctxEscAttr(t) + '">' +
              '<div class="text-xs font-semibold text-slate-800">' + __ctxEsc(t) + '</div>' +
              notePreview +
            '</button>'
          );
        }).join('<div class="h-2"></div>');
        toolsBox.innerHTML = html;
      }
    }

    // Scroll button
    const scrollBtn = __ctxQ('#ctx-scroll-to-step');
    if (scrollBtn) scrollBtn.disabled = !stepEl;
  }

  function __ctxEsc(s){
    return __ctxGetText(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c] || c));
  }
  function __ctxEscAttr(s){
    return __ctxGetText(s).replace(/"/g, '&quot;');
  }

  
  function __ctxFocusToolNote(stepEl, toolName){
    try {
      if (!stepEl || !toolName) return;

      // Ensure the step panel is open
      const body = stepEl.querySelector('.step-body');
      if (body && body.classList.contains('collapsed')) {
        body.classList.remove('collapsed');
        const mainToggleBtn = stepEl.querySelector('button[data-action="toggle-step"]');
        const mainIcon = mainToggleBtn ? mainToggleBtn.querySelector('.rotate-icon') : null;
        if (mainIcon) mainIcon.style.transform = 'rotate(180deg)';
      }

      // Ensure the "Ressources" tab is visible when tabs are enabled
      try {
        if (typeof window.__setStepTab === 'function') {
          window.__setStepTab(stepEl, 'resources', { focus: false });
        } else {
          // Fallback: show resources panel if present
          const panels = Array.from(stepEl.querySelectorAll('.step-tabpanel[data-step-panel]'));
          const tabs = Array.from(stepEl.querySelectorAll('.step-tab[data-step-tab]'));
          if (panels.length && tabs.length) {
            panels.forEach(p => { p.hidden = (p.getAttribute('data-step-panel') !== 'resources'); });
            tabs.forEach(t => {
              const isActive = (t.getAttribute('data-step-tab') === 'resources');
              t.setAttribute('aria-selected', isActive ? 'true' : 'false');
              t.tabIndex = isActive ? 0 : -1;
            });
          }
        }
      } catch(_){ __ldSilentErr(_); }

      // Ensure the tools/materials section is expanded
      const toolsDetails =
        __ctxQ('details.step-right-section[data-section="tools-materials"]', stepEl) ||
        __ctxQ('details.step-right-group[data-section="tools-materials"]', stepEl) ||
        __ctxQ('details.step-right-section', stepEl) ||
        __ctxQ('details.step-right-group', stepEl);
      if (toolsDetails && toolsDetails.tagName === 'DETAILS') toolsDetails.open = true;
    } catch(_){ __ldSilentErr(_); }

    // Focus matching note textarea if present
    try {
      const ta = stepEl.querySelector('textarea.step-toolmat-note[data-tool="' + CSS.escape(toolName) + '"]');
      if (ta) {
        ta.scrollIntoView({ behavior: 'smooth', block: 'center' });
        ta.focus();
      } else {
        stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    } catch(_) {
      try { stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch(__) {}
    }
  }


  function __ctxBuildSearchIndex(){
    const items = [];
    const groups = __ctxQA('.activity-group');
    groups.forEach((g, gi) => {
      const modTitleEl = __ctxQ('.activity-title', g);
      const modTitle = __ctxGetText(modTitleEl ? modTitleEl.value : '').trim();
      const modText = modTitle || ('Module ' + (gi+1));
      items.push({ kind: 'module', title: modText, text: modText, el: g });

      const steps = __ctxQA('.step-card', g);
      steps.forEach((s, si) => {
        const stepTitleEl = __ctxQ('.step-input-title', s);
        const stepTitle = __ctxGetText(stepTitleEl ? stepTitleEl.value : '').trim() || ('Activité ' + (si+1));
        const evalEl = __ctxQ('.evaluation-select', s);
        const evalVal = __ctxGetText(evalEl ? evalEl.value : '').trim();
        const durEl = __ctxQ('.duration-input', s);
        const durUnitEl = __ctxQ('.duration-unit', s);
        const durVal = __ctxGetText(durEl ? durEl.value : '').trim();
        const durUnitVal = __ctxGetText(durUnitEl ? durUnitEl.value : '').trim();
        const left = [
          modText,
          stepTitle,
          evalVal,
          durVal,
          durUnitVal,
          __ctxGetText(__ctxQ('.step-input-objective', s)?.value),
          __ctxGetText(__ctxQ('.step-input-tasks', s)?.value),
          __ctxGetText(__ctxQ('.step-input-trainer-tasks', s)?.value),
          __ctxGetText(__ctxQ('.step-input-logbook', s)?.value),
          __ctxGetText(__ctxQ('.step-input-resources', s)?.value)
        ].join('\n');

        const inAlign = __ctxSelectedOptions(__ctxQ('.step-competences-select', s))
          .concat(__ctxSelectedOptions(__ctxQ('.step-competences-transversales-select', s)))
          .concat(__ctxSelectedOptions(__ctxQ('.step-aims-select', s)))
          .concat(__ctxSelectedOptions(__ctxQ('.step-outcomes-select', s)))
          .join('\n');

        const inTools = __ctxGetTools(s).join('\n') + '\n' + Object.values(__ctxGetToolNotesMap(s) || {}).join('\n');

        items.push({
          kind: 'step',
          title: (modText ? (modText + ' — ') : '') + stepTitle,
          text: left,
          textAlign: inAlign,
          textTools: inTools,
          el: s
        });
      });
    });
    __ctxSearchIndex = items;
    return items;
  }

  function __ctxSnippet(text, q){
    try {
      const t = __ctxGetText(text);
      const qq = __ctxGetText(q).trim().toLowerCase();
      if (!qq) return '';
      const i = t.toLowerCase().indexOf(qq);
      if (i < 0) return '';
      const start = Math.max(0, i - 40);
      const end = Math.min(t.length, i + qq.length + 60);
      return (start > 0 ? '…' : '') + t.slice(start, end).replace(/\s+/g, ' ') + (end < t.length ? '…' : '');
    } catch(_) { return ''; }
  }

  function __ctxRunSearch(query){
    const q = __ctxGetText(query).trim();
    const resBox = __ctxQ('#global-search-results');
    const empty = __ctxQ('#global-search-empty');
    const countEl = __ctxQ('#global-search-count');
    if (!resBox) return;

    if (!__ctxSearchIndex) __ctxBuildSearchIndex();
    const inTools = !!(__ctxQ('#global-search-in-tools')?.checked);
    const inAlign = !!(__ctxQ('#global-search-in-align')?.checked);

    const qq = q.toLowerCase();
    __ctxSearchHits = [];
    if (qq) {
      __ctxSearchIndex.forEach((it) => {
        const hay = (__ctxGetText(it.text) + '\n' + (inAlign ? __ctxGetText(it.textAlign) : '') + '\n' + (inTools ? __ctxGetText(it.textTools) : '')).toLowerCase();
        if (hay.indexOf(qq) >= 0) __ctxSearchHits.push(it);
      });
    }

    resBox.innerHTML = '';
    if (!qq) {
      if (empty) empty.classList.add('hidden');
      if (countEl) countEl.textContent = 'Saisissez un terme de recherche.';
      return;
    }

    if (!__ctxSearchHits.length) {
      if (empty) empty.classList.remove('hidden');
      if (countEl) countEl.textContent = '0 résultat.';
      return;
    }

    if (empty) empty.classList.add('hidden');
    if (countEl) countEl.textContent = __ctxSearchHits.length + ' résultat' + (__ctxSearchHits.length > 1 ? 's' : '') + '.';

    __ctxSearchHits.slice(0, 200).forEach((hit, idx) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'w-full text-left px-4 py-3 hover:bg-slate-50 focus:outline-none focus:bg-slate-50';
      btn.dataset.hitIndex = String(idx);

      const kindLabel = (hit.kind === 'module') ? 'Module' : 'Activité';
      const snippet = __ctxSnippet(hit.text + '\n' + __ctxGetText(hit.textAlign) + '\n' + __ctxGetText(hit.textTools), q);

      btn.innerHTML =
        '<div class="flex items-start justify-between gap-3">' +
          '<div class="min-w-0">' +
            '<div class="text-xs text-slate-500">' + kindLabel + '</div>' +
            '<div class="text-sm font-semibold text-slate-800 truncate">' + __ctxEsc(hit.title || '') + '</div>' +
            (snippet ? '<div class="text-xs text-slate-600 mt-0.5">' + __ctxEsc(snippet) + '</div>' : '') +
          '</div>' +
          '<span class="material-icons-round text-[18px] text-slate-300">arrow_forward</span>' +
        '</div>';

      btn.addEventListener('click', () => {
        try {
          const el = hit.el;
          if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            if (hit.kind === 'step') __ctxSelectStep(el, { openPanel: true });
          }
        } catch(_){ __ldSilentErr(_); }
        __ctxCloseSearch();
      });
      resBox.appendChild(btn);
    });
  }

  function __ctxOpenSearch(){
    const modal = __ctxQ('#global-search-modal');
    if (!modal) return;
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    if (!__ctxSearchIndex) __ctxBuildSearchIndex();
    const input = __ctxQ('#global-search-input');
    if (input) {
      try { input.focus(); input.select(); } catch(_){ __ldSilentErr(_); }
      __ctxRunSearch(input.value || '');
    }
  }

  function __ctxCloseSearch(){
    const modal = __ctxQ('#global-search-modal');
    if (!modal) return;
    modal.classList.add('hidden');
    modal.classList.remove('flex');
  }

  function initContextPanelAndGlobalSearch(){
    // Panel open/close
    const handle = __ctxQ('#context-panel-handle');
    const close = __ctxQ('#context-panel-close');
    const pin = __ctxQ('#context-panel-pin');
    const scrollBtn = __ctxQ('#ctx-scroll-to-step');

    if (handle) handle.addEventListener('click', () => {
      if (__ctxSelectedStep) __ctxOpenPanel();
      else __ctxOpenPanel();
    });
    if (close) close.addEventListener('click', () => __ctxClosePanel(true));
    if (pin) pin.addEventListener('click', () => __ctxSetPinned(!__ctxPanelPinned));
    if (scrollBtn) scrollBtn.addEventListener('click', () => {
      if (!__ctxSelectedStep) return;
      try { __ctxSelectedStep.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch(_){ __ldSilentErr(_); }
    });

    // Quick-edit bindings
    const ctxTitle = __ctxQ('#ctx-title');
    const ctxDur = __ctxQ('#ctx-duration');
    const ctxDurUnit = __ctxQ('#ctx-duration-unit');
    const ctxEval = __ctxQ('#ctx-evaluation');
    const ctxObj = __ctxQ('#ctx-objective');

    function mirrorInput(ctxEl, srcSelector, evtName){
      if (!ctxEl) return;
      ctxEl.addEventListener('input', () => {
        if (!__ctxSelectedStep) return;
        const src = __ctxQ(srcSelector, __ctxSelectedStep);
        if (!src) return;
        src.value = ctxEl.value;
        try { src.dispatchEvent(new Event(evtName || 'input', { bubbles: true })); } catch(_){ __ldSilentErr(_); }
      });
      ctxEl.addEventListener('change', () => {
        if (!__ctxSelectedStep) return;
        const src = __ctxQ(srcSelector, __ctxSelectedStep);
        if (!src) return;
        src.value = ctxEl.value;
        try { src.dispatchEvent(new Event('change', { bubbles: true })); } catch(_){ __ldSilentErr(_); }
      });
    }
    mirrorInput(ctxTitle, '.step-input-title', 'input');
    mirrorInput(ctxDur, '.duration-input', 'input');
    mirrorInput(ctxDurUnit, '.duration-unit', 'change');
    mirrorInput(ctxEval, '.evaluation-select', 'change');
    mirrorInput(ctxObj, '.step-input-objective', 'input');

    // Click-to-select step
    document.addEventListener('click', (e) => {
      const step = e.target && e.target.closest ? e.target.closest('.step-card') : null;
      if (step) __ctxSelectStep(step, { openPanel: false });
    }, true);

    // Live update when selected step changes
    document.addEventListener('input', (e) => {
      if (!__ctxSelectedStep) return;
      if (__ctxSelectedStep.contains(e.target)) __ctxUpdatePanel(__ctxSelectedStep);
    }, true);
    document.addEventListener('change', (e) => {
      if (!__ctxSelectedStep) return;
      if (__ctxSelectedStep.contains(e.target)) __ctxUpdatePanel(__ctxSelectedStep);
    }, true);

    // Tool note focus from panel
    const panel = __ctxQ('#context-panel');
    if (panel) {
      panel.addEventListener('click', (e) => {
        const btn = e.target && e.target.closest ? e.target.closest('[data-ctx-tool]') : null;
        if (!btn || !__ctxSelectedStep) return;
        const tool = btn.getAttribute('data-ctx-tool') || '';
        if (tool) __ctxFocusToolNote(__ctxSelectedStep, tool);
      });
    }

    // Global search wiring
    const openBtn = __ctxQ('#open-global-search-btn');
    const closeBtn = __ctxQ('#global-search-close-btn');
    const refreshBtn = __ctxQ('#global-search-refresh-btn');
    const input = __ctxQ('#global-search-input');
    const backdrop = __ctxQ('[data-role="global-search-backdrop"]');

    if (openBtn) openBtn.addEventListener('click', () => __ctxOpenSearch());
    if (closeBtn) closeBtn.addEventListener('click', () => __ctxCloseSearch());
    if (backdrop) backdrop.addEventListener('click', () => __ctxCloseSearch());
    if (refreshBtn) refreshBtn.addEventListener('click', () => { __ctxBuildSearchIndex(); __ctxRunSearch(input ? input.value : ''); });

    function scheduleSearch(){
      if (!input) return;
      const q = input.value || '';
      try { clearTimeout(__ctxSearchTimer); } catch(_){ __ldSilentErr(_); }
      __ctxSearchTimer = setTimeout(() => __ctxRunSearch(q), 120);
    }

    if (input) {
      input.addEventListener('input', scheduleSearch);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') { e.preventDefault(); __ctxCloseSearch(); }
      });
    }
    const inTools = __ctxQ('#global-search-in-tools');
    const inAlign = __ctxQ('#global-search-in-align');
    if (inTools) inTools.addEventListener('change', scheduleSearch);
    if (inAlign) inAlign.addEventListener('change', scheduleSearch);

    // Ctrl/Cmd + K shortcut
    document.addEventListener('keydown', (e) => {
      const isCmdCtrl = !!(e.ctrlKey || e.metaKey);
      if (!isCmdCtrl) return;
      const k = String(e.key || '').toLowerCase();
      if (k === 'k') {
        e.preventDefault();
        __ctxOpenSearch();
      }
      if (k === 'escape') {
        __ctxCloseSearch();
      }
    }, true);

    // Initialise panel state
    __ctxClosePanel(true);
  }

function init(){
    try { initContextPanelAndGlobalSearch(); } catch(_){ __ldSilentErr(_); }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

</script>
<!-- Contextual Side Panel (Activity) -->
<div class="fixed top-3 right-3 bottom-3 w-[360px] max-w-[92vw] bg-white border border-slate-200 rounded-xl shadow-xl z-[105] hidden flex flex-col"
     id="context-panel"
     role="complementary"
     aria-label="Panneau contextuel">
  <div class="flex items-center justify-between px-4 py-3 border-b border-slate-200 bg-white">
    <div class="flex items-center gap-2">
      <span class="material-icons-round text-slate-500">view_sidebar</span>
      <div class="font-semibold text-sm">Panneau contextuel</div>
    </div>
    <div class="flex items-center gap-1">
      <button class="p-1.5 rounded hover:bg-slate-200 text-slate-600"
              id="context-panel-pin"
              type="button"
              title="Épingler">
        <span class="material-icons-round text-[18px]">push_pin</span>
      </button>
      <button class="p-1.5 rounded hover:bg-slate-200 text-slate-600"
              id="context-panel-close"
              type="button"
              title="Fermer">
        <span class="material-icons-round text-[18px]">close</span>
      </button>
    </div>
  </div>

  <div class="px-4 py-3 overflow-auto space-y-3">
    <div class="text-xs text-slate-500" id="context-panel-path"></div>

    <div>
      <label class="text-[11px] text-slate-500 font-semibold uppercase">Titre</label>
      <input class="w-full px-2 py-1.5 text-sm border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none"
             id="ctx-title"
             type="text" />
    </div>

    <div class="grid grid-cols-2 gap-2">
      <div>
        <label class="text-[11px] text-slate-500 font-semibold uppercase">Durée</label>
        <input class="w-full px-2 py-1.5 text-sm border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none"
               id="ctx-duration"
               type="number"
               min="0" />
      </div>
      <div>
        <label class="text-[11px] text-slate-500 font-semibold uppercase">Unité</label>
        <select class="w-full px-2 py-1.5 text-sm border border-slate-200 rounded-lg bg-white focus:ring-1 focus:ring-indigo-500 outline-none"
                id="ctx-duration-unit">
          <option value="60">Minutes</option>
          <option value="3600">Heures</option>
          <option value="86400">Jours</option>
          <option value="604800">Semaines</option>
        </select>
      </div>
    </div>

    <div>
      <label class="text-[11px] text-slate-500 font-semibold uppercase">Évaluation</label>
      <select class="w-full px-2 py-1.5 text-sm border border-slate-200 rounded-lg bg-white focus:ring-1 focus:ring-indigo-500 outline-none"
              id="ctx-evaluation">
        <option value="Aucune">Aucune</option>
        <option value="Diagnostique">Diagnostique</option>
        <option value="Formative">Formative</option>
        <option value="Certificative/Sommative">Certificative/Sommative</option>
      </select>
    </div>

    <div>
      <label class="text-[11px] text-slate-500 font-semibold uppercase">Objectif</label>
      <textarea class="w-full px-2 py-1.5 text-sm border border-slate-200 rounded-lg focus:ring-1 focus:ring-indigo-500 outline-none resize-y"
                id="ctx-objective"
                rows="2"></textarea>
    </div>

    <details class="border border-slate-200 rounded-lg bg-white" open>
      <summary class="cursor-pointer select-none flex items-center justify-between px-3 py-2 text-sm font-semibold text-slate-700">
        Alignement
        <span class="material-icons-round text-[16px] text-slate-400">expand_more</span>
      </summary>
      <div class="px-3 pb-3 text-sm text-slate-700" id="ctx-align"></div>
    </details>

    <details class="border border-slate-200 rounded-lg bg-white" open>
      <summary class="cursor-pointer select-none flex items-center justify-between px-3 py-2 text-sm font-semibold text-slate-700">
        Outils et matériel
        <span class="material-icons-round text-[16px] text-slate-400">expand_more</span>
      </summary>
      <div class="px-3 pb-3 text-sm text-slate-700" id="ctx-tools"></div>
    </details>
  </div>

  <div class="px-4 py-3 border-t border-slate-200 bg-slate-50 flex items-center justify-between gap-2">
    <div class="text-xs text-slate-500" id="ctx-hint">Cliquez une activité pour afficher ses détails.</div>
    <button class="px-3 py-2 text-xs rounded-lg border border-slate-200 bg-white hover:bg-slate-50"
            id="ctx-scroll-to-step"
            type="button">Aller à l’activité</button>
  </div>
</div>

<button class="fixed right-3 bottom-3 z-[104] px-3 py-2 rounded-lg border border-slate-200 bg-white hover:bg-slate-50 shadow-sm flex items-center gap-2"
        id="context-panel-handle"
        type="button"
        title="Ouvrir le panneau contextuel">
  <span class="material-icons-round text-[18px] text-slate-600">view_sidebar</span>
  <span class="text-xs font-medium text-slate-700 hidden md:inline">Panneau</span>
</button>


<!-- Barre : Actions groupées -->
<div id="batch-actions-bar" class="fixed bottom-0 left-0 right-0 hidden no-print z-[105]">
  <div class="ld-page p-2">
    <div class="batch-actions-inner bg-white border border-slate-200 rounded-xl shadow-lg p-2 flex flex-wrap items-center gap-2">
      <div class="flex items-center gap-2">
        <span class="material-icons-round text-slate-400 text-[18px]">done_all</span>
        <span class="text-xs font-semibold text-slate-700">Actions groupées</span>
        <span id="batch-selected-count" class="text-[11px] font-bold px-2 py-0.5 rounded bg-slate-100 text-slate-700">0</span>
      </div>

      <div class="h-6 w-px bg-slate-200 mx-1 hidden sm:block"></div>

      <div class="flex items-center gap-1">
        <span class="text-[10px] font-bold text-slate-500 uppercase">Évaluation</span>
        <select id="batch-evaluation" class="w-48 px-2 py-1 text-xs border border-slate-200 rounded outline-none focus:ring-2 focus:ring-indigo-200">
          <option value="">— choisir —</option>
          <option value="Aucune">Aucune</option>
          <option value="Diagnostique">Diagnostique</option>
          <option value="Formative">Formative</option>
          <option value="Certificative/Sommative">Certificative/Sommative</option>
        </select>
        <button id="batch-apply-evaluation" type="button" class="px-2 py-1 rounded-md bg-slate-800 text-white text-xs hover:bg-slate-900">Appliquer</button>
      </div>

      <div class="flex items-center gap-1">
        <span class="text-[10px] font-bold text-slate-500 uppercase">État</span>
        <select id="batch-status" class="w-40 px-2 py-1 text-xs border border-slate-200 rounded outline-none focus:ring-2 focus:ring-indigo-200">
          <option value="">— choisir —</option>
          <option value="in_progress" data-i18n="opt_status_inprogress">En cours</option>
          <option value="done" data-i18n="opt_status_completed">Finalisé</option>
          <option value="review" data-i18n="opt_status_review">À revoir</option>
        </select>
        <button id="batch-apply-status" type="button" class="px-2 py-1 rounded-md bg-slate-800 text-white text-xs hover:bg-slate-900">Appliquer</button>
      </div>


      <div class="h-6 w-px bg-slate-200 mx-1 hidden md:block"></div>

      <div class="flex items-center gap-1">
        <button id="batch-add-tool" type="button" class="px-2 py-1 rounded-md border border-slate-200 text-slate-700 text-xs hover:bg-slate-50">Ajouter outil</button>
        <button id="batch-remove-tool" type="button" class="px-2 py-1 rounded-md border border-slate-200 text-slate-700 text-xs hover:bg-slate-50">Retirer outil</button>
      </div>
      <div class="h-6 w-px bg-slate-200 mx-1 hidden lg:block"></div>

      <div class="flex items-center gap-1">
        <span class="text-[10px] font-bold text-slate-500 uppercase">Alignement</span>
        <select id="batch-alignment-kind" class="w-56 px-2 py-1 text-xs border border-slate-200 rounded outline-none focus:ring-2 focus:ring-indigo-200">
          <option value="aim">Objectif</option>
          <option value="outcome">Résultat</option>
          <option value="comp">Compétence</option>
          <option value="compT">Compétence transversale</option>
        </select>
        <button id="batch-add-alignment" type="button" class="px-2 py-1 rounded-md border border-slate-200 text-slate-700 text-xs hover:bg-slate-50">Ajouter</button>
        <button id="batch-remove-alignment" type="button" class="px-2 py-1 rounded-md border border-slate-200 text-slate-700 text-xs hover:bg-slate-50">Retirer</button>
      </div>

      <div class="h-6 w-px bg-slate-200 mx-1 hidden xl:block"></div>

      <div class="flex items-center gap-1">
        <span class="text-[10px] font-bold text-slate-500 uppercase">Déplacement</span>
        <select id="batch-move-target" class="w-80 px-2 py-1 text-xs border border-slate-200 rounded outline-none focus:ring-2 focus:ring-indigo-200" title="Déplacer les activités sélectionnées vers un module, un moment ou un sous-moment">
          <option value="">— choisir —</option>
        </select>
        <button id="batch-apply-move" type="button" class="px-2 py-1 rounded-md border border-slate-200 text-slate-700 text-xs hover:bg-slate-50">Déplacer</button>
      </div>

      <div class="flex-1"></div>

      <button id="batch-clear-selection" type="button" class="px-2 py-1 rounded-md border border-slate-200 text-slate-700 text-xs hover:bg-slate-50">Désélectionner</button>
    </div>
  </div>
</div>


<script>

(function(){
  const Q = (window.Q ? window.Q : (sel, root=document) => root.querySelector(sel));
  const QA = (window.QA ? window.QA : (sel, root=document) => Array.from(root.querySelectorAll(sel)));

  const bar = Q('#batch-actions-bar');

  const moveSelect = Q('#batch-move-target');
  const moveBtn = Q('#batch-apply-move');

  function selectedSteps(){
    return QA('.step-batch-select:checked').map(chk => chk.closest('.step-card')).filter(Boolean);
  }

  function updateBatchBar(){
    const n = selectedSteps().length;
    const nEl = Q('#batch-selected-count');
    if (nEl) nEl.textContent = String(n);
    if (!bar) return;
    if (n > 0){
      bar.classList.remove('hidden');
      document.body.classList.add('has-batch-bar');
      try { refreshMoveTargets(); } catch(_){ __ldSilentErr(_); }
    } else {
      bar.classList.add('hidden');
      document.body.classList.remove('has-batch-bar');
    }
  }

  function clearSelection(){
    QA('.step-batch-select:checked').forEach(chk => { chk.checked = false; });
    updateBatchBar();
  }


  // --- Batch move (selected activities) ---
  function _genMoveKey(prefix='mk'){
    try { if (window.crypto && crypto.randomUUID) return `${prefix}_${crypto.randomUUID()}`; } catch(_){ __ldSilentErr(_); }
    return `${prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
  }
  function ensureMoveKey(el, prefix){
    if (!el) return '';
    if (!el.dataset) return '';
    if (!el.dataset.moveKey) el.dataset.moveKey = _genMoveKey(prefix);
    return el.dataset.moveKey;
  }
  function _esc(s){
    return String(s ?? '').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));
  }
  function _txtInput(sel, root){
    const el = Q(sel, root);
    return el ? String(el.value || el.textContent || '').trim() : '';
  }
  function _txt(sel, root){
    const el = Q(sel, root);
    return el ? String(el.textContent || '').trim() : '';
  }

  function refreshMoveTargets(){
    if (!moveSelect) return;
    const prev = moveSelect.value || '';

    // Ensure stable move keys
    QA('.activity-group').forEach(a => ensureMoveKey(a, 'mod'));
    QA('.moment-group').forEach(m => ensureMoveKey(m, 'mom'));
    QA('.submoment-card').forEach(s => ensureMoveKey(s, 'sm'));

    const opts = [];
    opts.push(`<option value="">— choisir —</option>`);

    // Modules
    const modules = QA('.activity-group');
    if (modules.length){
      opts.push(`<optgroup label="Modules">`);
      modules.forEach((modEl, i) => {
        const idx = _txt('.activity-index', modEl) || String(i+1);
        const title = _txtInput('.activity-title', modEl) || `Module ${idx}`;
        const key = modEl.dataset.moveKey;
        opts.push(`<option value="module::${_esc(key)}">${_esc(`Module ${idx} — ${title}`)}</option>`);
      });
      opts.push(`</optgroup>`);
    }

    // Moments
    const moments = QA('.moment-group');
    if (moments.length){
      opts.push(`<optgroup label="Moments">`);
      moments.forEach((momEl, j) => {
        const modEl = momEl.closest('.activity-group');
        const modIdx = modEl ? (_txt('.activity-index', modEl) || '') : '';
        const modTitle = modEl ? (_txtInput('.activity-title', modEl) || '') : '';
        const momIdx = _txt('.moment-index', momEl) || String(j+1);
        const momTitle = _txtInput('.moment-title', momEl) || `Moment ${momIdx}`;
        const key = momEl.dataset.moveKey;
        const prefix = (modIdx || modTitle) ? `Module ${modIdx} — ${modTitle} › ` : '';
        opts.push(`<option value="moment::${_esc(key)}">${_esc(`${prefix}Moment ${momIdx} — ${momTitle}`)}</option>`);
      });
      opts.push(`</optgroup>`);
    }

    // Sous-moments
    const submoments = QA('.submoment-card');
    if (submoments.length){
      opts.push(`<optgroup label="Sous-moments">`);
      submoments.forEach((smEl, k) => {
        const momEl = smEl.closest('.moment-group');
        const modEl = smEl.closest('.activity-group');
        const modIdx = modEl ? (_txt('.activity-index', modEl) || '') : '';
        const modTitle = modEl ? (_txtInput('.activity-title', modEl) || '') : '';
        const momIdx = momEl ? (_txt('.moment-index', momEl) || '') : '';
        const momTitle = momEl ? (_txtInput('.moment-title', momEl) || '') : '';
        // submoment index within moment
        let smIdx = '';
        try {
          if (momEl){
            const list = QA('.submoments-container .submoment-card', momEl);
            const pos = list.indexOf(smEl);
            smIdx = (pos >= 0) ? String(pos + 1) : String(k+1);
          } else {
            smIdx = String(k+1);
          }
        } catch(_) { smIdx = String(k+1); }

        const smTitle = _txtInput('.submoment-title', smEl) || `Sous-moment ${smIdx}`;
        const key = smEl.dataset.moveKey;

        const prefix = (modIdx || modTitle || momIdx || momTitle)
          ? `Module ${modIdx} — ${modTitle} › Moment ${momIdx} — ${momTitle} › `
          : '';
        opts.push(`<option value="submoment::${_esc(key)}">${_esc(`${prefix}Sous-moment ${smIdx} — ${smTitle}`)}</option>`);
      });
      opts.push(`</optgroup>`);
    }

    moveSelect.innerHTML = opts.join('');
    if (prev && moveSelect.querySelector(`option[value="${CSS.escape(prev)}"]`)){
      moveSelect.value = prev;
    }
  }

  function _initSortableStepsLocal(container){
    try {
      if (typeof Sortable === 'undefined' || !container) return;
      if (container.__ldSortable) return;
      container.__ldSortable = new Sortable(container, {
        group: 'shared-steps',
        animation: 150,
        handle: '.drag-handle-step',
        ghostClass: 'sortable-ghost',
        dragClass: 'sortable-drag',
        onEnd: () => { try { window.updateStats && window.updateStats(); } catch(_){ __ldSilentErr(_); } }
      });
    } catch(_){ __ldSilentErr(_); }
  }

  function _ensureMomentDirectVisibility(momentEl){
    try {
      if (!momentEl) return;
      const hasSub = QA('.submoments-container .submoment-card', momentEl).length > 0;
      const direct = Q('.moment-direct-steps', momentEl);
      const directHasSteps = QA('.moment-direct-steps .step-card', momentEl).length > 0;
      if (direct) direct.classList.toggle('hidden', hasSub && !directHasSteps);
    } catch(_){ __ldSilentErr(_); }
  }

  function _getMomentDirectContainer(momentEl){
    if (!momentEl) return null;
    return Q('.moment-direct-steps .activity-steps-container', momentEl) || Q('.activity-steps-container', momentEl);
  }

  function _createFallbackMomentInModule(moduleEl){
    try {
      const cont = Q('.activity-moments-container', moduleEl);
      const tmpl = document.getElementById('moment-template');
      if (!cont || !tmpl) return null;
      const clone = tmpl.content.cloneNode(true);
      cont.appendChild(clone);
      const momEl = cont.lastElementChild;
      // Provide a default title if blank
      const idx = QA('.moment-group', moduleEl).length;
      const title = Q('.moment-title', momEl);
      if (title && !String(title.value || '').trim()) title.value = `Moment ${idx}`;
      const stepsCont = Q('.activity-steps-container', momEl);
      _initSortableStepsLocal(stepsCont);
      try { window.updateMomentIndexes && window.updateMomentIndexes(moduleEl); } catch(_){ __ldSilentErr(_); }
      _ensureMomentDirectVisibility(momEl);
      return momEl;
    } catch(_) { return null; }
  }

  function _resolveMoveTarget(val){
    const parts = String(val || '').split('::');
    if (parts.length !== 2) return null;
    const kind = parts[0];
    const key = parts[1];
    let el = null;
    try { el = document.querySelector(`[data-move-key="${CSS.escape(key)}"]`); } catch(_){ __ldSilentErr(_); }
    if (!el) return null;

    if (kind === 'module'){
      const moduleEl = el.closest('.activity-group') || el;
      let momEl = Q('.moment-group', moduleEl);
      if (!momEl) momEl = _createFallbackMomentInModule(moduleEl);
      const container = _getMomentDirectContainer(momEl);
      return { kind, moduleEl, momEl, container };
    }
    if (kind === 'moment'){
      const momEl = el.closest('.moment-group') || el;
      const container = _getMomentDirectContainer(momEl);
      return { kind, momEl, container };
    }
    if (kind === 'submoment'){
      const smEl = el.closest('.submoment-card') || el;
      const container = Q('.submoment-steps', smEl) || Q('.activity-steps-container', smEl);
      const momEl = smEl.closest('.moment-group');
      return { kind, smEl, momEl, container };
    }
    return null;
  }

  function batchMoveSelected(){
    const val = moveSelect ? moveSelect.value : '';
    if (!val) return;
    const target = _resolveMoveTarget(val);
    if (!target || !target.container){
      refreshMoveTargets();
      return;
    }
    const steps = selectedSteps();
    if (!steps.length) return;

    // Track affected moments for visibility refresh
    const affectedMoments = new Set();
    steps.forEach(stepEl => {
      try {
        const m = stepEl.closest('.moment-group');
        if (m) affectedMoments.add(m);
      } catch(_){ __ldSilentErr(_); }
    });
    if (target.momEl) affectedMoments.add(target.momEl);

    // If everything is already in the target container, do not reorder; just clear selection.
    try {
      const allSame = steps.every(stepEl => stepEl.parentElement === target.container);
      if (allSame){
        clearSelection();
        return;
      }
    } catch(_){ __ldSilentErr(_); }

    // Move in DOM order
    steps.forEach(stepEl => {
      try {
        target.container.appendChild(stepEl);
        const chk = Q('.step-batch-select', stepEl);
        if (chk) chk.checked = false;
        // If moving to moment-direct while submoments exist, ensure direct zone can display
        if (target.kind === 'module' || target.kind === 'moment'){
          const momEl = target.momEl || stepEl.closest('.moment-group');
          if (momEl){
            const direct = Q('.moment-direct-steps', momEl);
            if (direct) direct.classList.remove('hidden');
          }
        }
        try { updateStepCoherence(stepEl); } catch(_){ __ldSilentErr(_); }
      } catch(_){ __ldSilentErr(_); }
    });

    // Refresh visibility of direct containers
    affectedMoments.forEach(m => { _ensureMomentDirectVisibility(m); });

    try { window.updateStats && window.updateStats(); } catch(_){ __ldSilentErr(_); }
    updateBatchBar();
    refreshMoveTargets();
  }


  function getDurationMinutes(stepEl){
    const v = parseFloat(Q('.duration-input', stepEl)?.value || '0');
    const unit = parseFloat(Q('.duration-unit', stepEl)?.value || '60'); // seconds per unit
    if (!isFinite(v) || v <= 0) return 0;
    if (!isFinite(unit) || unit <= 0) return 0;
    return (v * unit) / 60;
  }

  function getAlignmentCount(stepEl){
    const aims = Q('.step-aims-select', stepEl);
    const outs = Q('.step-outcomes-select', stepEl);
    const kcs  = Q('.step-competences-select', stepEl);
    const n1 = aims ? (aims.selectedOptions ? aims.selectedOptions.length : 0) : 0;
    const n2 = outs ? (outs.selectedOptions ? outs.selectedOptions.length : 0) : 0;
    const n3 = kcs  ? (kcs.selectedOptions  ? kcs.selectedOptions.length  : 0) : 0;
    return n1 + n2 + n3;
  }

  function computeCoherenceIssues(stepEl){
    const issues = [];
    const title = String(Q('.step-input-title', stepEl)?.value || '').trim();
    if (!title) issues.push("Titre manquant");
    const dur = getDurationMinutes(stepEl);
    if (!dur || dur <= 0) issues.push("Durée = 0");
    if (getAlignmentCount(stepEl) === 0) issues.push("Alignement non renseigné");
    return issues;
  }

  function updateStepCoherence(stepEl){
    const ind = Q('.step-coherence-indicator', stepEl);
    if (!ind) return;
    const issues = computeCoherenceIssues(stepEl);
    if (issues.length){
      ind.classList.remove('hidden');
      ind.title = issues.join(" • ");
    } else {
      ind.classList.add('hidden');
      ind.title = "";
    }
  }

  function promptListChoice(title, options, defaultValue){
    const opts = (Array.isArray(options) ? options : []).map(o => String(o || '').trim()).filter(Boolean);
    if (!opts.length) return null;
    const list = opts.slice(0, 50).map(o => "- " + o).join("\n");
    const msg =
      title + "\n\n" +
      list +
      (opts.length > 50 ? "\n… (liste tronquée)" : "");
    const choice = window.prompt(msg, defaultValue || opts[0] || '');
    if (choice == null) return null;
    const c = String(choice || '').trim();
    if (!c) return null;
    return c;
  }

  function promptAimChoice(){
    let options = [];
    try{ if (typeof getGlobalLearningAimsOptions === 'function') options = getGlobalLearningAimsOptions() || []; }catch(_){ __ldSilentErr(_); }
    if (!options || !options.length){
      alert("Aucun objectif n'est défini. Ajoutez/en chargez dans l’onglet Objectifs.");
      return null;
    }
    return promptListChoice("Choisissez un objectif (copiez/collez une ligne exacte depuis la liste ci-dessous) :", options, options[0] || '');
  }

  function promptOutcomeChoice(){
    let options = [];
    try{ if (typeof getGlobalLearningOutcomesOptions === 'function') options = getGlobalLearningOutcomesOptions() || []; }catch(_){ __ldSilentErr(_); }
    if (!options || !options.length){
      alert("Aucun résultat d’apprentissage n'est défini. Ajoutez/en chargez dans l’onglet Résultats d’apprentissage.");
      return null;
    }
    return promptListChoice("Choisissez un résultat d’apprentissage (copiez/collez une ligne exacte depuis la liste ci-dessous) :", options, options[0] || '');
  }

  function promptCompetenceChoice(isTransversal){
    let items = [];
    try{
      if (isTransversal && typeof getCompetencesTransversalesFromUI === 'function') items = getCompetencesTransversalesFromUI() || [];
      if (!isTransversal && typeof getCompetencesFromUI === 'function') items = getCompetencesFromUI() || [];
    }catch(_){ __ldSilentErr(_); }
    items = Array.isArray(items) ? items : [];
    if (!items.length){
      alert(isTransversal ? "Aucune compétence transversale n'est définie." : "Aucune compétence n'est définie.");
      return null;
    }

    const entries = items.map(it => {
      const cat = String(it.categorie || '').trim() || '—';
      const sub = String(it.sousCategorie || '').trim() || '—';
      const label = String(it.label || '').trim();
      return (cat + " / " + sub + " — " + label);
    }).filter(Boolean);

    const choice = promptListChoice(
      isTransversal
        ? "Choisissez une compétence transversale (copiez/collez une ligne exacte) :"
        : "Choisissez une compétence (copiez/collez une ligne exacte) :",
      entries,
      entries[0] || ''
    );
    if (!choice) return null;

    const parts = String(choice).split(" — ");
    const label = (parts.length >= 2 ? parts.slice(1).join(" — ") : String(choice)).trim();
    let cat = '';
    let sub = '';
    if (parts.length >= 2){
      const left = String(parts[0] || '').trim();
      const cs = left.split(" / ");
      cat = (cs[0] || '').trim();
      sub = (cs[1] || '').trim();
      if (cat === '—') cat = '';
      if (sub === '—') sub = '';
    }

    // Match first exact label, then case-insensitive; if cat/sub provided, use them
    let found = items.find(it => {
      const l = String(it.label || '').trim();
      if (l !== label) return false;
      if (cat && String(it.categorie || '').trim() !== cat) return false;
      if (sub && String(it.sousCategorie || '').trim() !== sub) return false;
      return true;
    });

    if (!found){
      const lower = label.toLowerCase();
      found = items.find(it => String(it.label || '').trim().toLowerCase() === lower);
    }

    if (!found) return null;
    return { id: found.id, label: String(found.label || '').trim() };
  }

  function batchApplyEvaluation(){
    const v = (Q('#batch-evaluation')?.value || '').trim();
    if (!v) return;
    selectedSteps().forEach(stepEl => {
      const sel = Q('.evaluation-select', stepEl);
      if (sel){
        sel.value = v;
        try{ sel.dispatchEvent(new Event('change', {bubbles:true})); }catch(_){ __ldSilentErr(_); }
      }
      updateStepCoherence(stepEl);
    });
  }

  function batchApplyStatus(){
    const v = (Q('#batch-status')?.value || '').trim();
    if (!v) return;
    selectedSteps().forEach(stepEl => {
      const sel = Q('.step-status-select', stepEl);
      if (sel){
        sel.value = v;
        try{ sel.dispatchEvent(new Event('change', {bubbles:true})); }catch(_){ __ldSilentErr(_); }
      } else {
        try { if (typeof applyStepStatus === 'function') applyStepStatus(stepEl, v); } catch(_){ __ldSilentErr(_); }
      }
    });
  }


  function promptToolChoice(){
    let options = [];
    try{
      if (typeof getGlobalToolsMaterialsOptions === 'function'){
        options = getGlobalToolsMaterialsOptions() || [];
      }
    }catch(_){ __ldSilentErr(_); }
    options = (Array.isArray(options) ? options : []).map(o => String(o || '').trim()).filter(Boolean);
    if (!options.length){
      alert("Aucun outil/matériel n'est défini. Ajoutez-en dans l’onglet 5.");
      return null;
    }
    const list = options.slice(0, 50).map(o => "- " + o).join("\n");
    const msg =
      "Choisissez un outil/matériel (copiez/collez une ligne exacte depuis la liste ci-dessous) :\n\n" +
      list +
      (options.length > 50 ? "\n… (liste tronquée)" : "");
    const choice = window.prompt(msg, options[0] || '');
    if (choice == null) return null;
    const c = String(choice || '').trim();
    if (!c) return null;
    return c;
  }

  function batchAddTool(){
    const tool = promptToolChoice();
    if (!tool) return;
    const notePrompt = window.prompt("Remarque (optionnelle) pour cet outil/matériel :", "");
    const note = (notePrompt == null) ? "" : String(notePrompt || "");
    selectedSteps().forEach(stepEl => {
      let selTools = [];
      try{
        if (typeof getSelectedStepToolsMaterials === 'function'){
          selTools = getSelectedStepToolsMaterials(stepEl) || [];
        }
      }catch(_){ __ldSilentErr(_); }
      selTools = Array.isArray(selTools) ? selTools : [];
      if (!selTools.includes(tool)) selTools.push(tool);
      try{
        if (typeof populateStepToolsMaterialsSelect === 'function'){
          populateStepToolsMaterialsSelect(stepEl, selTools);
        }
      }catch(_){ __ldSilentErr(_); }
      if (note && typeof __getStepToolMatNotesMap === 'function' && typeof __setStepToolMatNotesMap === 'function'){
        const m = __getStepToolMatNotesMap(stepEl) || {};
        m[tool] = note;
        __setStepToolMatNotesMap(stepEl, m);
        try{ if (typeof renderStepToolsMaterialsNotes === 'function') renderStepToolsMaterialsNotes(stepEl); }catch(_){ __ldSilentErr(_); }
      }
      updateStepCoherence(stepEl);
    });
  }

  function batchRemoveTool(){
    const tool = promptToolChoice();
    if (!tool) return;
    selectedSteps().forEach(stepEl => {
      let selTools = [];
      try{
        if (typeof getSelectedStepToolsMaterials === 'function'){
          selTools = getSelectedStepToolsMaterials(stepEl) || [];
        }
      }catch(_){ __ldSilentErr(_); }
      selTools = (Array.isArray(selTools) ? selTools : []).filter(t => String(t || '').trim() !== tool);
      try{
        if (typeof populateStepToolsMaterialsSelect === 'function'){
          populateStepToolsMaterialsSelect(stepEl, selTools);
        }
      }catch(_){ __ldSilentErr(_); }
      try{
        if (typeof __getStepToolMatNotesMap === 'function' && typeof __setStepToolMatNotesMap === 'function'){
          const m = __getStepToolMatNotesMap(stepEl) || {};
          delete m[tool];
          __setStepToolMatNotesMap(stepEl, m);
          if (typeof renderStepToolsMaterialsNotes === 'function') renderStepToolsMaterialsNotes(stepEl);
        }
      }catch(_){ __ldSilentErr(_); }
      updateStepCoherence(stepEl);
    });
  }

  function getSelectedTextFromSelect(sel){
    if (!sel) return [];
    return Array.from(sel.selectedOptions || []).map(o => String(o.value || '').trim()).filter(Boolean);
  }

  function batchAddAlignment(){
    const kind = (Q('#batch-alignment-kind')?.value || 'aim').trim();
    let picked = null;

    if (kind === 'aim') picked = promptAimChoice();
    else if (kind === 'outcome') picked = promptOutcomeChoice();
    else if (kind === 'comp') picked = promptCompetenceChoice(false);
    else if (kind === 'compT') picked = promptCompetenceChoice(true);

    if (!picked) return;

    selectedSteps().forEach(stepEl => {
      try{
        if (kind === 'aim'){
          const current = (typeof getSelectedStepAims === 'function') ? (getSelectedStepAims(stepEl) || []) : getSelectedTextFromSelect(Q('.step-aims-select', stepEl));
          const next = Array.from(new Set([...(current||[]), String(picked).trim()].filter(Boolean)));
          if (typeof populateStepAimsSelect === 'function') populateStepAimsSelect(stepEl, next);
        } else if (kind === 'outcome'){
          const current = (typeof getSelectedStepOutcomes === 'function') ? (getSelectedStepOutcomes(stepEl) || []) : getSelectedTextFromSelect(Q('.step-outcomes-select', stepEl));
          const next = Array.from(new Set([...(current||[]), String(picked).trim()].filter(Boolean)));
          if (typeof populateStepOutcomesSelect === 'function') populateStepOutcomesSelect(stepEl, next);
        } else if (kind === 'comp'){
          const id = String(picked.id || '').trim();
          if (!id) return;
          const current = (typeof getSelectedStepCompetenceIds === 'function') ? (getSelectedStepCompetenceIds(stepEl) || []) : [];
          const next = Array.from(new Set([...(current||[]), id].filter(Boolean)));
          if (typeof populateStepCompetencesSelect === 'function') populateStepCompetencesSelect(stepEl, next);
        } else if (kind === 'compT'){
          const id = String(picked.id || '').trim();
          if (!id) return;
          const current = (typeof getSelectedStepCompetencesTransversalesIds === 'function') ? (getSelectedStepCompetencesTransversalesIds(stepEl) || []) : [];
          const next = Array.from(new Set([...(current||[]), id].filter(Boolean)));
          if (typeof populateStepCompetencesTransversalesSelect === 'function') populateStepCompetencesTransversalesSelect(stepEl, next);
        }
      }catch(_){ __ldSilentErr(_); }
      updateStepCoherence(stepEl);
    });
  }

  function batchRemoveAlignment(){
    const kind = (Q('#batch-alignment-kind')?.value || 'aim').trim();
    let picked = null;

    if (kind === 'aim') picked = promptAimChoice();
    else if (kind === 'outcome') picked = promptOutcomeChoice();
    else if (kind === 'comp') picked = promptCompetenceChoice(false);
    else if (kind === 'compT') picked = promptCompetenceChoice(true);

    if (!picked) return;

    selectedSteps().forEach(stepEl => {
      try{
        if (kind === 'aim'){
          const current = (typeof getSelectedStepAims === 'function') ? (getSelectedStepAims(stepEl) || []) : getSelectedTextFromSelect(Q('.step-aims-select', stepEl));
          const target = String(picked).trim();
          const next = (current||[]).filter(v => String(v || '').trim() !== target);
          if (typeof populateStepAimsSelect === 'function') populateStepAimsSelect(stepEl, next);
        } else if (kind === 'outcome'){
          const current = (typeof getSelectedStepOutcomes === 'function') ? (getSelectedStepOutcomes(stepEl) || []) : getSelectedTextFromSelect(Q('.step-outcomes-select', stepEl));
          const target = String(picked).trim();
          const next = (current||[]).filter(v => String(v || '').trim() !== target);
          if (typeof populateStepOutcomesSelect === 'function') populateStepOutcomesSelect(stepEl, next);
        } else if (kind === 'comp'){
          const id = String(picked.id || '').trim();
          if (!id) return;
          const current = (typeof getSelectedStepCompetenceIds === 'function') ? (getSelectedStepCompetenceIds(stepEl) || []) : [];
          const next = (current||[]).filter(v => String(v || '').trim() !== id);
          if (typeof populateStepCompetencesSelect === 'function') populateStepCompetencesSelect(stepEl, next);
        } else if (kind === 'compT'){
          const id = String(picked.id || '').trim();
          if (!id) return;
          const current = (typeof getSelectedStepCompetencesTransversalesIds === 'function') ? (getSelectedStepCompetencesTransversalesIds(stepEl) || []) : [];
          const next = (current||[]).filter(v => String(v || '').trim() !== id);
          if (typeof populateStepCompetencesTransversalesSelect === 'function') populateStepCompetencesTransversalesSelect(stepEl, next);
        }
      }catch(_){ __ldSilentErr(_); }
      updateStepCoherence(stepEl);
    });
  }

  // Wiring
  Q('#batch-apply-evaluation')?.addEventListener('click', batchApplyEvaluation);
  Q('#batch-apply-status')?.addEventListener('click', batchApplyStatus);
  Q('#batch-add-tool')?.addEventListener('click', batchAddTool);
  Q('#batch-remove-tool')?.addEventListener('click', batchRemoveTool);
  Q('#batch-add-alignment')?.addEventListener('click', batchAddAlignment);
  Q('#batch-remove-alignment')?.addEventListener('click', batchRemoveAlignment);
  moveBtn?.addEventListener('click', batchMoveSelected);
  moveSelect?.addEventListener('mousedown', () => { try{ refreshMoveTargets(); } catch(_){ __ldSilentErr(_); } });
  moveSelect?.addEventListener('focus', () => { try{ refreshMoveTargets(); } catch(_){ __ldSilentErr(_); } });
  Q('#batch-clear-selection')?.addEventListener('click', clearSelection);

  document.addEventListener('change', function(e){
    const t = e.target;
    if (!t) return;
    if (t.matches('.step-batch-select')) { updateBatchBar(); return; }
    const stepEl = t.closest ? t.closest('.step-card') : null;
    if (stepEl) updateStepCoherence(stepEl);
  }, true);

  document.addEventListener('input', function(e){
    const t = e.target;
    if (!t) return;
    const stepEl = t.closest ? t.closest('.step-card') : null;
    if (stepEl) updateStepCoherence(stepEl);
  }, true);

  // Init
  function init(){
    QA('.step-card').forEach(stepEl => { try{ updateStepCoherence(stepEl); }catch(_){ __ldSilentErr(_); } });
    updateBatchBar();
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();

})();

</script>


<script>
/* A11Y-ERGONOMIE: focus/ARIA/Esc/keyboard-dnd */
(function(){
  'use strict';

  function qs(sel, ctx){ return (ctx||document).querySelector(sel); }
  function qsa(sel, ctx){ return Array.prototype.slice.call((ctx||document).querySelectorAll(sel)); }
  function ensureId(el, prefix){
    if (!el) return null;
    if (el.id) return el.id;
    const id = prefix + '-' + Math.random().toString(36).slice(2, 9);
    el.id = id;
    return id;
  }
  function isHidden(el){
    if (!el) return true;
    if (el.classList.contains('hidden')) return true;
    const cs = window.getComputedStyle ? getComputedStyle(el) : null;
    if (cs && (cs.display === 'none' || cs.visibility === 'hidden')) return true;
    return false;
  }
  function live(msg){
    try {
      let lr = qs('#a11y-live-region');
      if (!lr) {
        lr = document.createElement('div');
        lr.id = 'a11y-live-region';
        lr.setAttribute('aria-live', 'polite');
        lr.setAttribute('aria-atomic', 'true');
        lr.style.position = 'absolute';
        lr.style.width = '1px';
        lr.style.height = '1px';
        lr.style.margin = '-1px';
        lr.style.border = '0';
        lr.style.padding = '0';
        lr.style.overflow = 'hidden';
        lr.style.clip = 'rect(0 0 0 0)';
        lr.style.clipPath = 'inset(50%)';
        document.body.appendChild(lr);
      }
      lr.textContent = msg;
    } catch(_){ __ldSilentErr(_); }
  }

  // ---------- ARIA: "Plus..." menu ----------
  function initMoreMenuA11y(){
    const btn = qs('#btn-more');
    const menu = qs('#more-menu');
    if (!btn || !menu) return;

    btn.setAttribute('aria-haspopup', 'menu');
    btn.setAttribute('aria-controls', 'more-menu');
    btn.setAttribute('aria-expanded', menu.classList.contains('hidden') ? 'false' : 'true');

    menu.setAttribute('role', 'menu');
    menu.setAttribute('aria-label', 'Menu Plus');
    const items = qsa('button, [role="menuitem"]', menu).filter(el => el.tagName === 'BUTTON');
    items.forEach((it) => {
      it.setAttribute('role', 'menuitem');
      // roving tabindex
      it.tabIndex = -1;
    });

    let lastOpener = null;

    function setExpanded(open){
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
    }

    function openMenu(){
      if (!menu.classList.contains('hidden')) return;
      lastOpener = document.activeElement;
      menu.classList.remove('hidden');
      setExpanded(true);
      const first = items.find(x => !x.disabled) || items[0];
      items.forEach(it => { it.tabIndex = -1; });
      if (first) {
        first.tabIndex = 0;
        setTimeout(() => { try { first.focus(); } catch(_){ __ldSilentErr(_); } }, 0);
      }
    }

    function closeMenu(opts){
      if (menu.classList.contains('hidden')) return;
      menu.classList.add('hidden');
      setExpanded(false);
      const restore = (opts && opts.restoreFocus);
      if (restore) {
        const target = (lastOpener && lastOpener.isConnected) ? lastOpener : btn;
        try { target.focus(); } catch(_){ __ldSilentErr(_); }
      }
    }

    // Wrap existing functions (if present) so other code keeps working.
    const origToggle = window.toggleMoreMenu;
    const origClose = window.closeMoreMenu;

    window.closeMoreMenu = function(){
      try { closeMenu({ restoreFocus: false }); } catch(_){ __ldSilentErr(_); }
      try { if (typeof origClose === 'function') origClose(); } catch(_){ __ldSilentErr(_); }
    };

    window.toggleMoreMenu = function(ev){
      // prefer our a11y open/close behaviour
      try {
        if (ev && ev.preventDefault) ev.preventDefault();
        if (ev && ev.stopPropagation) ev.stopPropagation();
      } catch(_){ __ldSilentErr(_); }
      const willOpen = menu.classList.contains('hidden');
      if (willOpen) openMenu(); else closeMenu({ restoreFocus: true });
    };

    // Keyboard navigation within menu
    menu.addEventListener('keydown', (e) => {
      const k = e.key;
      const enabled = items.filter(x => !x.disabled);
      const cur = document.activeElement;
      const i = enabled.indexOf(cur);
      if (k === 'Escape') {
        e.preventDefault();
        closeMenu({ restoreFocus: true });
      } else if (k === 'ArrowDown') {
        e.preventDefault();
        const next = enabled[(i + 1 + enabled.length) % enabled.length] || enabled[0];
        if (next) next.focus();
      } else if (k === 'ArrowUp') {
        e.preventDefault();
        const prev = enabled[(i - 1 + enabled.length) % enabled.length] || enabled[0];
        if (prev) prev.focus();
      } else if (k === 'Home') {
        e.preventDefault(); if (enabled[0]) enabled[0].focus();
      } else if (k === 'End') {
        e.preventDefault(); if (enabled[enabled.length-1]) enabled[enabled.length-1].focus();
      } else if (k === 'Tab') {
        // leave menu -> close
        closeMenu({ restoreFocus: false });
      }
    });

    // Open on ArrowDown when focused on trigger
    btn.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
        if (menu.classList.contains('hidden')) {
          e.preventDefault();
          openMenu();
        }
      }
      if (e.key === 'Escape' && !menu.classList.contains('hidden')) {
        e.preventDefault();
        closeMenu({ restoreFocus: true });
      }
    }, true);

    // Click outside already handled elsewhere; just keep aria in sync (MutationObserver)
    const mo = new MutationObserver(() => {
      const open = !menu.classList.contains('hidden');
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
      // If menu closed while focus is inside, restore focus to trigger.
      try {
        const ae = document.activeElement;
        if (!open && ae && menu.contains(ae)) btn.focus();
      } catch(_){ __ldSilentErr(_); }
    });
mo.observe(menu, { attributes: true, attributeFilter: ['class','style'] });
  }

  // ---------- ARIA: accordion-like toggles (modules / steps / moments / panels) ----------
  function syncToggle(btn, panel, expanded){
    if (!btn || !panel) return;
    ensureId(panel, 'panel');
    btn.setAttribute('aria-controls', panel.id);
    btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
  }

  function updateAriaForModule(btn){
    try {
      const group = btn.closest('.activity-group');
      const body = group ? group.querySelector('.activity-body') : null;
      if (!body) return;
      const expanded = !body.classList.contains('collapsed');
      syncToggle(btn, body, expanded);
    } catch(_){ __ldSilentErr(_); }
  }

  function updateAriaForStep(btn){
    try {
      const card = btn.closest('.step-card');
      const body = card ? card.querySelector('.step-body') : null;
      if (!body) return;
      const expanded = !body.classList.contains('collapsed');
      syncToggle(btn, body, expanded);
    } catch(_){ __ldSilentErr(_); }
  }

  function updateAriaForMoment(btn){
    try {
      const group = btn.closest('.moment-group');
      const body = group ? group.querySelector('.moment-body') : null;
      if (!body) return;
      const expanded = !body.classList.contains('collapsed');
      syncToggle(btn, body, expanded);
    } catch(_){ __ldSilentErr(_); }
  }

  function updateAriaForPanel(panelId){
    try {
      const panel = qs('#' + panelId);
      if (!panel) return;
      const open = panel.classList.contains('open') && !isHidden(panel);
      qsa('[data-action="toggle-panel"][data-panel="'+panelId+'"]').forEach(btn => {
        syncToggle(btn, panel, open);
      });
    } catch(_){ __ldSilentErr(_); }
  }

  function wrapFn(name, after){
    const orig = window[name];
    if (typeof orig !== 'function') return;
    if (orig.__a11y_wrapped) return;
    const wrapped = function(){
      const res = orig.apply(this, arguments);
      try { after.apply(this, arguments); } catch(_){ __ldSilentErr(_); }
      return res;
    };
    wrapped.__a11y_wrapped = true;
    window[name] = wrapped;
  }

  function initAccordionAria(){
    // Initial sync for existing DOM
    qsa('button[data-action="toggle-module"]').forEach(updateAriaForModule);
    qsa('button[data-action="toggle-step"]').forEach(updateAriaForStep);
    qsa('button[data-action="toggle-moment"]').forEach(updateAriaForMoment);
    qsa('button[data-action="toggle-panel"][data-panel]').forEach(btn => updateAriaForPanel(btn.dataset.panel));

    // Wrap togglers so aria stays in sync
    wrapFn('toggleActivity', function(btn){ updateAriaForModule(btn); });
    wrapFn('toggleStep', function(btn){ updateAriaForStep(btn); });
    wrapFn('toggleMoment', function(btn){ updateAriaForMoment(btn); });
    wrapFn('toggleAllActivities', function(){
      qsa('button[data-action="toggle-module"]').forEach(updateAriaForModule);
    });
    wrapFn('togglePanel', function(panelId){ updateAriaForPanel(panelId); });

    // Observe added nodes (new modules/steps/moments)
    const root = qs('#activities-root');
    if (root) {
      const obs = new MutationObserver((muts) => {
        muts.forEach(m => {
          m.addedNodes && Array.prototype.forEach.call(m.addedNodes, (n) => {
            if (!n || n.nodeType !== 1) return;
            qsa('button[data-action="toggle-module"]', n).forEach(updateAriaForModule);
            qsa('button[data-action="toggle-step"]', n).forEach(updateAriaForStep);
            qsa('button[data-action="toggle-moment"]', n).forEach(updateAriaForMoment);
          });
        });
      });
      obs.observe(root, { childList: true, subtree: true });
    }
  }


  // ---------- Tabs: colonne droite d'une activité (Déroulé / Alignement / Ressources) ----------
  function initStepTabs(){
    function setup(stepEl){
      if (!stepEl || stepEl.__stepTabsInit) return;
      const tablist = qs('.step-tabs', stepEl);
      if (!tablist) return;

      const tabs = qsa('.step-tab[data-step-tab]', tablist);
      const panels = qsa('.step-tabpanel[data-step-panel]', stepEl);
      if (!tabs.length || !panels.length) return;

      tablist.setAttribute('role', 'tablist');

      // Link tabs <-> panels
      tabs.forEach((tab) => {
        tab.setAttribute('role', 'tab');
        tab.setAttribute('type', 'button');
        const name = tab.getAttribute('data-step-tab');
        const panel = panels.find(p => p.getAttribute('data-step-panel') === name);
        if (!panel) return;

        const tabId = ensureId(tab, 'step-tab');
        const panelId = ensureId(panel, 'step-panel');

        tab.setAttribute('aria-controls', panelId);
        panel.setAttribute('role', 'tabpanel');
        panel.setAttribute('aria-labelledby', tabId);
      });

      function activate(tab, opts){
        if (!tab) return;
        const name = tab.getAttribute('data-step-tab');

        tabs.forEach(t => {
          const sel = (t === tab);
          t.setAttribute('aria-selected', sel ? 'true' : 'false');
          t.tabIndex = sel ? 0 : -1;
        });

        panels.forEach(p => {
          const isActive = (p.getAttribute('data-step-panel') === name);
          p.hidden = !isActive;
          if (isActive && name === 'notes') {
            try {
              p.querySelectorAll('details.step-right-section').forEach(d => { d.open = true; });
            } catch(_){ __ldSilentErr(_); }
          }
        });

        if (opts && opts.focus) {
          try { tab.focus(); } catch(_){ __ldSilentErr(_); }
        }
      }

      function deactivate(keepTab, opts){
        tabs.forEach(t => {
          t.setAttribute('aria-selected', 'false');
          t.tabIndex = (t === keepTab) ? 0 : -1;
        });
        panels.forEach(p => { p.hidden = true; });

        if (opts && opts.focus && keepTab) {
          try { keepTab.focus(); } catch(_){ __ldSilentErr(_); }
        }
      }


      // Initial active tab: aria-selected="true" else first
      const initial = tabs.find(t => t.getAttribute('aria-selected') === 'true') || tabs[0];
      activate(initial, { focus: false });

      // Interactions: click + roving focus + activation
      tabs.forEach((tab, idx) => {
        tab.addEventListener('click', () => {
          const isSelected = (tab.getAttribute('aria-selected') === 'true');
          if (isSelected) {
            deactivate(tab, { focus: false });
          } else {
            activate(tab, { focus: false });
          }
        });
        tab.addEventListener('keydown', (e) => {
          const k = e.key;
          const n = tabs.length;
          if (!n) return;

          if (k === 'ArrowRight' || k === 'ArrowDown') {
            e.preventDefault();
            const ni = (idx + 1) % n;
            try { tabs[ni].focus(); } catch(_){ __ldSilentErr(_); }
            return;
          }
          if (k === 'ArrowLeft' || k === 'ArrowUp') {
            e.preventDefault();
            const ni = (idx - 1 + n) % n;
            try { tabs[ni].focus(); } catch(_){ __ldSilentErr(_); }
            return;
          }
          if (k === 'Home') {
            e.preventDefault();
            try { tabs[0].focus(); } catch(_){ __ldSilentErr(_); }
            return;
          }
          if (k === 'End') {
            e.preventDefault();
            try { tabs[n-1].focus(); } catch(_){ __ldSilentErr(_); }
            return;
          }
          if (k === 'Enter' || k === ' ') {
            e.preventDefault();
            const isSelected = (tab.getAttribute('aria-selected') === 'true');
            if (isSelected) {
              deactivate(tab, { focus: true });
            } else {
              activate(tab, { focus: true });
            }
            return;
          }
        });
      });

      stepEl.__stepTabsActivate = activate;
      stepEl.__stepTabsInit = true;
    }

    // Init existing
    qsa('.step-card').forEach(setup);

    // Init dynamically added steps
    const root = qs('#activities-root') || document.body;
    const obs = new MutationObserver((muts) => {
      muts.forEach(m => {
        m.addedNodes && Array.prototype.forEach.call(m.addedNodes, (n) => {
          if (!n || n.nodeType !== 1) return;
          if (n.classList && n.classList.contains('step-card')) setup(n);
          qsa('.step-card', n).forEach(setup);
        });
      });
    });
    obs.observe(root, { childList: true, subtree: true });

    // Global helper (used by search/context shortcuts)
    window.__setStepTab = function(stepEl, tabName, opts){
      try{
        if (!stepEl) return;
        setup(stepEl);
        const esc = (window.CSS && CSS.escape) ? CSS.escape : (s => String(s).replace(/["\\]/g, "\\$&"));
        const tab = qs('.step-tab[data-step-tab="' + esc(tabName) + '"]', stepEl);
        if (tab && typeof stepEl.__stepTabsActivate === 'function') {
          stepEl.__stepTabsActivate(tab, opts || {});
        }
      } catch(_){ __ldSilentErr(_); }
    };
  }

  // ---------- Keyboard drag & drop (reorder) ----------
  const KBD = {
    active: false,
    handle: null,
    item: null,
    container: null,
    snapshot: null
  };

  function getReorderItemFromHandle(handle){
    if (!handle) return null;
    return handle.closest('li, .step-card, .moment-group, .activity-group');
  }
  function getContainerForItem(item){
    if (!item) return null;
    return item.parentElement;
  }
  function itemIndex(item){
    if (!item || !item.parentElement) return -1;
    const kids = Array.prototype.filter.call(item.parentElement.children, el => el.nodeType===1);
    return kids.indexOf(item);
  }
  function itemCount(container){
    if (!container) return 0;
    return Array.prototype.filter.call(container.children, el => el.nodeType===1).length;
  }
  function syncAfterReorder(container){
    try {
      if (!container) return;
      const id = container.id || '';
      if (id === 'aims-list' && typeof window.syncAimsTextareaFromList === 'function') window.syncAimsTextareaFromList();
      if (id === 'outcomes-text-list' && typeof window.syncOutcomesTextTextareaFromList === 'function') window.syncOutcomesTextTextareaFromList();
      if (id === 'tools-materials-list' && typeof window.syncToolsMaterialsTextareaFromList === 'function') window.syncToolsMaterialsTextareaFromList();
      if (typeof window.refreshAllStepToolsMaterialsOptions === 'function' && id === 'tools-materials-list') window.refreshAllStepToolsMaterialsOptions();
      if ((id === 'competences-list' || id === 'competences-transversales-list') && typeof window.notifyCompetencesUpdated === 'function') window.notifyCompetencesUpdated();
      // Steps/moments/modules: update derived views
      if (typeof window.updateMomentIndexes === 'function' && container.closest('.activity-group') && container.classList.contains('activity-moments-container')) {
        window.updateMomentIndexes(container.closest('.activity-group'));
      }
      if (typeof window.updateStats === 'function') window.updateStats();
      if (typeof window.updateEmptyState === 'function') window.updateEmptyState();
    } catch(_){ __ldSilentErr(_); }
  }

  function startGrab(handle){
    const item = getReorderItemFromHandle(handle);
    const container = getContainerForItem(item);
    if (!item || !container) return;

    // Snapshot for undo if available
    try {
      if (typeof window.snapshotProject === 'function') {
        KBD.snapshot = window.snapshotProject();
      } else {
        KBD.snapshot = null;
      }
    } catch(_) { KBD.snapshot = null; }

    KBD.active = true;
    KBD.handle = handle;
    KBD.item = item;
    KBD.container = container;

    handle.setAttribute('aria-pressed', 'true');
    item.classList.add('kbd-grabbed');
    live('Mode réorganisation activé. Utilisez les flèches haut/bas pour déplacer. Échap pour annuler.');
  }

  function endGrab(cancel){
    if (!KBD.active) return;

    try {
      if (!cancel && KBD.snapshot && typeof window.pushUndoSnapshot === 'function') {
        window.pushUndoSnapshot(KBD.snapshot);
      }
    } catch(_){ __ldSilentErr(_); }

    try {
      if (KBD.handle) KBD.handle.setAttribute('aria-pressed', 'false');
      if (KBD.item) KBD.item.classList.remove('kbd-grabbed');
    } catch(_){ __ldSilentErr(_); }

    KBD.active = false;
    KBD.handle = null;
    KBD.item = null;
    KBD.container = null;
    KBD.snapshot = null;

    if (cancel) live('Réorganisation annulée.'); else live('Réorganisation terminée.');
  }

  function moveItem(delta){
    if (!KBD.active || !KBD.item || !KBD.container) return;
    const item = KBD.item;
    const container = KBD.container;
    const beforeIndex = itemIndex(item);
    if (beforeIndex < 0) return;

    const siblings = Array.prototype.filter.call(container.children, el => el.nodeType===1);
    const targetIndex = beforeIndex + delta;
    if (targetIndex < 0 || targetIndex >= siblings.length) {
      live('Déplacement impossible.');
      return;
    }

    const ref = siblings[targetIndex];
    if (delta < 0) {
      container.insertBefore(item, ref);
    } else {
      container.insertBefore(item, ref.nextSibling);
    }

    // keep focus
    try { KBD.handle.focus(); } catch(_){ __ldSilentErr(_); }

    syncAfterReorder(container);

    const afterIndex = itemIndex(item);
    const total = itemCount(container);
    live('Élément déplacé en position ' + (afterIndex + 1) + ' sur ' + total + '.');
  }

  function decorateHandles(ctx){
    const handles = qsa('.drag-handle', ctx || document);
    handles.forEach(h => {
      // Avoid affecting real buttons (already focusable)
      if (h.tagName === 'BUTTON' || h.getAttribute('role') === 'button') {
        // still ensure aria
      } else {
        h.setAttribute('role', 'button');
      }
      if (!h.hasAttribute('tabindex')) h.tabIndex = 0;
      if (!h.hasAttribute('aria-label')) h.setAttribute('aria-label', 'Réordonner');
      h.setAttribute('aria-pressed', 'false');
    });
  }

  function initKeyboardDnD(){
    // Add minimal visual cue when grabbed
    const styleId = 'a11y-kbd-dnd-style';
    if (!qs('#' + styleId)) {
      const st = document.createElement('style');
      st.id = styleId;
      st.textContent = '.kbd-grabbed{ outline: 2px dashed rgba(99,102,241,0.9); outline-offset: 2px; }';
      document.head.appendChild(st);
    }

    decorateHandles(document);

    // When nodes are added dynamically, decorate again
    const root = qs('#activities-root') || document.body;
    const obs = new MutationObserver((muts) => {
      muts.forEach(m => {
        m.addedNodes && Array.prototype.forEach.call(m.addedNodes, (n) => {
          if (n && n.nodeType === 1) decorateHandles(n);
        });
      });
    });
    obs.observe(root, { childList: true, subtree: true });

    // Key handling on handles
    document.addEventListener('keydown', (e) => {
      const handle = e.target && (e.target.classList && e.target.classList.contains('drag-handle')) ? e.target : null;
      const k = e.key;

      // Global cancellation of keyboard grab
      if (k === 'Escape' && KBD.active) {
        e.preventDefault();
        endGrab(true);
        return;
      }

      if (!handle) return;

      if (k === ' ' || k === 'Enter') {
        e.preventDefault();
        if (KBD.active && KBD.handle === handle) endGrab(false);
        else if (!KBD.active) startGrab(handle);
        return;
      }

      if (!KBD.active || KBD.handle !== handle) return;

      if (k === 'ArrowUp') { e.preventDefault(); moveItem(-1); return; }
      if (k === 'ArrowDown') { e.preventDefault(); moveItem(+1); return; }
      if (k === 'Home') { e.preventDefault(); while (itemIndex(KBD.item) > 0) moveItem(-1); return; }
      if (k === 'End') { e.preventDefault(); while (itemIndex(KBD.item) < itemCount(KBD.container)-1) moveItem(+1); return; }
    }, true);
  }

  // ---------- ESC: close top-most overlay/menu ----------
  function initGlobalEscape(){
    document.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;

      // If keyboard DnD active, handled elsewhere.
      if (KBD.active) return;

      // 1) Close duplicate step menu if open
      const dup = qs('#duplicate-step-menu');
      if (dup && !isHidden(dup)) {
        e.preventDefault();
        dup.classList.add('hidden');
        return;
      }

      // 2) Close more menu if open
      const more = qs('#more-menu');
      if (more && !more.classList.contains('hidden')) {
        e.preventDefault();
        try { if (typeof window.closeMoreMenu === 'function') window.closeMoreMenu(); else more.classList.add('hidden'); } catch(_){ __ldSilentErr(_); }
        return;
      }

      // 3) Close global search modal if open
      const gsm = qs('#global-search-modal');
      if (gsm && !gsm.classList.contains('hidden')) {
        e.preventDefault();
        try {
        gsm.classList.add('hidden');
        gsm.classList.remove('flex');
      } catch(_){ __ldSilentErr(_); }
        return;
      }

      // 5) Close template/i18n modals if open
      const modalIds = ['template-export-modal','template-import-modal','i18n-audit-modal','import-error-modal'];
      for (let i=0;i<modalIds.length;i++) {
        const el = qs('#' + modalIds[i]);
        if (el && !el.classList.contains('hidden')) {
          e.preventDefault();
          // Prefer existing close handlers when available
          try {
            if (modalIds[i] === 'template-export-modal' && typeof window.closeExport === 'function') window.closeExport();
            else if (modalIds[i] === 'template-import-modal' && typeof window.closeImport === 'function') window.closeImport();
            else if (modalIds[i] === 'i18n-audit-modal' && typeof window.closeI18nAudit === 'function') window.closeI18nAudit();
            else {
              el.classList.add('hidden');
              el.classList.remove('flex');
            }
          } catch(_) {
            el.classList.add('hidden');
          }
          return;
        }
      }
    }, true);
  }

  // ---------- ARIA roles for key modals (dialog basics) ----------
  function initModalAria(){
    const modalIds = [
      ['template-export-modal','Exporter un modèle'],
      ['template-import-modal','Importer un modèle'],
      ['i18n-audit-modal','Vérifier traductions']
    ];
    modalIds.forEach(([id,label]) => {
      const el = qs('#' + id);
      if (!el) return;
      el.setAttribute('role', 'dialog');
      el.setAttribute('aria-modal', 'true');
      if (!el.getAttribute('aria-label') && !el.getAttribute('aria-labelledby')) {
        el.setAttribute('aria-label', label);
      }
    });
  }

  function boot(){
    try { initMoreMenuA11y(); } catch(_){ __ldSilentErr(_); }
    try { initAccordionAria(); } catch(_){ __ldSilentErr(_); }
    try { initStepTabs(); } catch(_){ __ldSilentErr(_); }
    try { initKeyboardDnD(); } catch(_){ __ldSilentErr(_); }
    try { initGlobalEscape(); } catch(_){ __ldSilentErr(_); }
    try { initModalAria(); } catch(_){ __ldSilentErr(_); }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
})();
</script>



<script id="top-level-tabs-script">
(function(){
  const STORAGE_KEY = 'ld_top_tab_v1';
  const tabs = [
    { id: 'info',    btnId: 'top-tab-btn-info',    panelId: 'key-params-wrapper' },
    { id: 'visual',  btnId: 'top-tab-btn-visual',  panelId: 'visualisations-wrapper' },
    { id: 'analysis',btnId: 'top-tab-btn-analysis',panelId: 'analysis-tabs-wrap', isDetails: true }
  ];

  function setActive(tabId, save){
    const hasTab = !!tabId;

    if(hasTab){
      document.body.dataset.topTab = tabId;
    } else {
      try { delete document.body.dataset.topTab; } catch(e) { document.body.dataset.topTab = ''; }
    }

    tabs.forEach(t => {
      const btn = document.getElementById(t.btnId);
      const panel = document.getElementById(t.panelId);
      if(!btn || !panel) return;

      const active = hasTab && (t.id === tabId);
      btn.setAttribute('aria-selected', active ? 'true' : 'false');

      // Accessibility: when a tab is active, roving tabindex; when none is active, allow normal Tab traversal
      btn.tabIndex = hasTab ? (active ? 0 : -1) : 0;

      if(active){
        panel.style.display = '';
        if(t.isDetails){
          try { panel.open = true; } catch(e){}
        }
        if (t.id === 'analysis') {
          try {
            if (typeof requestUpdateCharts === 'function') requestUpdateCharts();
            else if (typeof updateCharts === 'function') updateCharts();
          } catch(_){ __ldSilentErr(_); }
        }
      } else {
        panel.style.display = 'none';
        if(t.isDetails){
          // Keep details closed when hidden to avoid confusing state if styles change later
          try { panel.open = false; } catch(e){}
        }
      }
    });

    if(save){
      try {
        if(hasTab) localStorage.setItem(STORAGE_KEY, tabId);
        else localStorage.removeItem(STORAGE_KEY);
      } catch(e){}
    }
  }

  function focusTab(tabId){
    const t = tabs.find(x => x.id === tabId);
    if(!t) return;
    const btn = document.getElementById(t.btnId);
    if(btn) btn.focus();
  }

  function init(){
    document.body.classList.add('top-tabs-enabled');

    tabs.forEach(t => {
      const btn = document.getElementById(t.btnId);
      if(!btn) return;

      btn.addEventListener('click', () => {
        const cur = document.body.dataset.topTab || '';
        if(cur === t.id) setActive(null, true); // second click collapses
        else setActive(t.id, true);
      });

      btn.addEventListener('keydown', (e) => {
        if(e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
        e.preventDefault();

        const cur = document.body.dataset.topTab || 'visual';
        const idx = tabs.findIndex(x => x.id === cur);
        const startIdx = (idx >= 0) ? idx : tabs.findIndex(x => x.id === 'visual');
        const dir = (e.key === 'ArrowRight') ? 1 : -1;
        const nextIdx = (startIdx + dir + tabs.length) % tabs.length;
        const next = tabs[nextIdx].id;

        setActive(next, true);
        focusTab(next);
      });
    });

    // Start with all top-level panels collapsed.
    setActive(null, false);
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>

<script>
/* Confort de sélection : tout sélectionner dans un moment + sélection par plage (Shift+clic) */
(function(){
  'use strict';

  function isElementVisible(el){
    if (!el) return false;
    try{
      if (el.classList && el.classList.contains('hidden')) return false;
      const cs = window.getComputedStyle ? getComputedStyle(el) : null;
      if (cs && (cs.display === 'none' || cs.visibility === 'hidden')) return false;
      if (typeof el.getClientRects === 'function' && el.getClientRects().length === 0) return false;
      return true;
    } catch(_){
      return true;
    }
  }

  function getStepRangeContainer(chk){
    if (!chk || !chk.closest) return document;
    return chk.closest('.submoment-steps')
        || chk.closest('.activity-steps-container')
        || chk.closest('.steps-container')
        || chk.closest('.submoment-card')
        || chk.closest('.moment-group')
        || chk.closest('.activity-group')
        || document;
  }

  function getVisibleStepBatchCheckboxes(container){
    const root = container || document;
    const all = Array.from(root.querySelectorAll('.step-batch-select'));
    return all.filter(cb => {
      const card = cb.closest ? cb.closest('.step-card') : null;
      return isElementVisible(card || cb);
    });
  }

  // ---- Tout sélectionner / désélectionner dans le moment ----
  window.selectAllStepsInMoment = function(btn){
    const momentEl = btn && btn.closest ? btn.closest('.moment-group') : null;
    if (!momentEl) return;

    const cbs = getVisibleStepBatchCheckboxes(momentEl);
    if (!cbs.length) return;

    const shouldCheck = cbs.some(cb => !cb.checked); // si au moins une non cochée => tout cocher, sinon tout décocher
    cbs.forEach(cb => { cb.checked = shouldCheck; });

    // Rafraîchir la barre d’actions groupées (updateBatchBar est interne, on déclenche donc un change synthétique)
    try{
      const anchor = cbs[0];
      if (anchor) anchor.dispatchEvent(new Event('change', { bubbles: true }));
    } catch(_){ __ldSilentErr(_); }
  };

  // ---- Sélection par plage (Shift+clic) ----
  let lastStepBatchCheckbox = null;
  let lastPanoramaCheckbox = null;

  function applyStepRangeSelection(current, last, container){
    const boxes = getVisibleStepBatchCheckboxes(container);
    const i1 = boxes.indexOf(last);
    const i2 = boxes.indexOf(current);
    if (i1 < 0 || i2 < 0) return;
    const start = Math.min(i1, i2);
    const end = Math.max(i1, i2);
    const state = !!current.checked;
    for (let i = start; i <= end; i++){
      boxes[i].checked = state;
    }
    // Le change du checkbox cliqué déclenchera updateBatchBar() via le listener existant
  }

  function applyPanoramaRangeSelection(current, last){
    const table = document.getElementById('panorama-table');
    const scope = (current && current.closest) ? (current.closest('tbody') || table) : table;
    if (!scope) return;

    const boxes = Array.from(scope.querySelectorAll('.pano-select')).filter(cb => {
      const tr = cb.closest ? cb.closest('tr') : null;
      return isElementVisible(tr || cb);
    });

    const i1 = boxes.indexOf(last);
    const i2 = boxes.indexOf(current);
    if (i1 < 0 || i2 < 0) return;

    const start = Math.min(i1, i2);
    const end = Math.max(i1, i2);
    const state = !!current.checked;

    for (let i = start; i <= end; i++){
      const cb = boxes[i];
      cb.checked = state;

      // Mettre à jour la sélection Panorama (les "change" ne se déclenchent pas sur les cases modifiées par script)
      try{
        const pid = cb.getAttribute('data-pano-select');
        if (pid){
          if (state) __ldPanoramaSelected.add(pid);
          else __ldPanoramaSelected.delete(pid);
        }
      } catch(_){ __ldSilentErr(_); }
    }

    try{ if (typeof __ldUpdatePanoramaBatchUI === 'function') __ldUpdatePanoramaBatchUI(); } catch(_){ __ldSilentErr(_); }
  }

  // Handler : clics sur checkboxes (capture pour capter shiftKey avant d’éventuels stopPropagation)
  document.addEventListener('click', function(e){
    const t = e.target;

    // Range sélection sur activités (actions groupées)
    if (t && t.matches && t.matches('.step-batch-select')) {
      if (e.shiftKey && lastStepBatchCheckbox && lastStepBatchCheckbox !== t) {
        const c1 = getStepRangeContainer(t);
        const c2 = getStepRangeContainer(lastStepBatchCheckbox);
        if (c1 === c2) applyStepRangeSelection(t, lastStepBatchCheckbox, c1);
      }
      lastStepBatchCheckbox = t;
      return;
    }

    // Range sélection sur Panorama
    if (t && t.classList && t.classList.contains('pano-select')) {
      if (e.shiftKey && lastPanoramaCheckbox && lastPanoramaCheckbox !== t) {
        applyPanoramaRangeSelection(t, lastPanoramaCheckbox);
      }
      lastPanoramaCheckbox = t;
      return;
    }
  }, true);

})();
</script>


</body>
</html>
